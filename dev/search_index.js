var documenterSearchIndex = {"docs":
[{"location":"api/bvector/#B-vector","page":"B vector","title":"B vector","text":"","category":"section"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"The bmb-vectors connect kpoint bmk to its neighboring kpoints bmk+bmb, for calculating WF centers, spreads in reciprocal space.","category":"page"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"The bvectors are first arranged in layers of shells, which contain bvectors having same norm. Then parallel shells are deleted, and the shells satisfying B1 condition are the final bvectors. At last, the bvectors are sorted at each kpoint, to reproduce exactly the same order as Wannier90. This ensures that we have the same order as mmn file.","category":"page"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"note: Note\nTo reproduce the same order as Wannier90, we need to be careful with some floating point comparison, i.e., the atol keyword arguments in the following functions. Their default value reproduce the Wannier90 order. Note the kmesh_tol in the win file also influence the search of bvectors.","category":"page"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"tip: Tip\nIn most cases, the user only need to call get_bvectors to generate bvectors having the same order as Wannier90. Other functions are intermediate steps that are called inside get_bvectors.","category":"page"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"CurrentModule = Wannier","category":"page"},{"location":"api/bvector/#Contents","page":"B vector","title":"Contents","text":"","category":"section"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"Pages = [\"bvector.md\"]\nDepth = 2","category":"page"},{"location":"api/bvector/#Index","page":"B vector","title":"Index","text":"","category":"section"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"Pages = [\"bvector.md\"]","category":"page"},{"location":"api/bvector/#B-vector-shells-and-B-vectors","page":"B vector","title":"B vector shells and B vectors","text":"","category":"section"},{"location":"api/bvector/","page":"B vector","title":"B vector","text":"Modules = [Wannier]\nPages   = [\"bvector.jl\"]","category":"page"},{"location":"api/bvector/#Wannier.BVectorShells","page":"B vector","title":"Wannier.BVectorShells","text":"BVectorShells\n\nShells of bvectors.\n\nThe bvectors are sorted by norm such that equal-norm bvectors are grouped into one shell.\n\nFields\n\nrecip_lattice: 3 * 3, each column is a reciprocal lattice vector\nkpoints: 3 * n_kpts, in fractional coordinates\nbvectors: vectors of 3 * n_bvecs_per_shell, in cartesian coordinates\nweights: vector of float, weights of each shell\nmultiplicities: number of bvectors in each shell\nn_bvecs: total number of bvectors\n\n\n\n\n\n","category":"type"},{"location":"api/bvector/#Wannier.BVectorShells-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, Any, Any, AbstractVector{T}}} where T<:Real","page":"B vector","title":"Wannier.BVectorShells","text":"BVectorShells(recip_lattice, kpoints, bvectors, weights)\n\nConstructor of BVectorShells.\n\nOnly essential arguments are required, remaing fields of BVectorShells are initialized accordingly. This should be used instead of directly constructing BVectorShells.\n\nArguments\n\nrecip_lattice: 3 * 3, each column is a reciprocal lattice vector\nkpoints: 3 * n_kpts, in fractional coordinates\nbvectors: vectors of 3 * n_bvecs_per_shell, in cartesian coordinates\nweights: vector of float, weights of each shell\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.BVectors","page":"B vector","title":"Wannier.BVectors","text":"BVectors\n\nThe bvectors for each kpoint.\n\nFields\n\nrecip_lattice: 3 * 3, each column is a reciprocal lattice vector\nkpoints: 3 * n_kpts, in fractional coordinates\nbvectors: 3 * n_bvecs, in cartesian coordinates\nweights: n_bvecs, weights of each bvector\nkpb_k: k+b vectors at kpoint k, k -> k + b   (index of periodically equivalent kpoint inside recip_lattice)\nkpb_G: 3 * n_bvecs * n_kpts,   displacements between k + b and its periodic image inside recip_lattice,   such that k+b = kpoints[:, kpb_k[ib, ik]] + kpb_G[:, ib, ik] (in fractional)\nn_kpts: number of kpoints\nn_bvecs: total number of bvectors\n\nnote: Note\nIn principle, we don't need to sort the bvectors for each kpoint, so that the bvectors have the same order as each kpoint. However, since Wannier90 sort the bvectors, and the mmn file is written in that order, so we also sort in the same order as Wannier90.\n\n\n\n\n\n","category":"type"},{"location":"api/bvector/#Wannier._bvec_to_kb-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"B vector","title":"Wannier._bvec_to_kb","text":"Find equivalent kpoint and displacement vector of bvectors bvecs at kpoint k.\n\nall inputs in fractional coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier._sort_kb-Tuple{AbstractVector, AbstractVector{Int64}, AbstractVector{StaticArraysCore.SVector{3, Int64}}, AbstractVector{StaticArraysCore.SVector{3, Int64}}}","page":"B vector","title":"Wannier._sort_kb","text":"Sort bvectors specified by equivalent kpoint indices k and cell displacements b.\n\nSorting order:\n\nlength of bvectors: nearest k+b goes first, this is achieved by comparing  the norm bvecs_norm.\nsupercell index: the supercell are already sorted by sort_supercell,  which generates our input translations.\nindex of kpoint: the smaller index goes first, dictated by the input kpoints.\n\nbvecs_norm: length of bvectors, cartesian norm. k: index in kpoints for equivalent kpoint of bvectors b: cell displacements of bvectors, fractional coordinates translations: of supercell, fractional coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.are_parallel-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"B vector","title":"Wannier.are_parallel","text":"are_parallel(A, B; atol=1e-6)\n\nCheck if the columns of matrix A and columns of matrix B are parallel.\n\nArguments\n\nA: matrix\nB: matrix\n\nKeyword Arguments\n\natol: tolerance to check parallelism\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.check_b1-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T","page":"B vector","title":"Wannier.check_b1","text":"check_b1(shells::BVectorShells; atol=1e-6)\n\nCheck completeness (B1 condition) of BVectorShells.\n\nArguments\n\nshells: BVectorShells containing bvectors in each shell\n\nKeyword Arguments\n\natol: tolerance, equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.compute_weights-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T<:Real","page":"B vector","title":"Wannier.compute_weights","text":"compute_weights(bvectors::Vector{Matrix{T}}; atol=1e-6)\n\nTry to guess bvector weights from MV1997 Eq. (B1).\n\nThe input bvectors are overcomplete vectors found during shell search, i.e. from search_shells. This function tries to find the minimum number of bvector shells that satisfy the B1 condition, and return the new BVectorShells and weights.\n\nArguments\n\nbvectors: vector of bvectors in each shell\n\nKeyword Arguments\n\natol: tolerance to satisfy B1 condition,   equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.compute_weights-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T<:Real","page":"B vector","title":"Wannier.compute_weights","text":"compute_weights(shells::BVectorShells; atol=1e-6)\n\nTry to guess bvector weights from MV1997 Eq. (B1).\n\nArguments\n\nshells: BVectorShells containing bvectors in each shell\n\nKeyword Arguments\n\natol: tolerance to satisfy B1 condition,   equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.delete_parallel-Tuple{Wannier.BVectorShells}","page":"B vector","title":"Wannier.delete_parallel","text":"delete_parallel(shells::BVectorShells)\n\nRemove shells having parallel bvectors.\n\nArguments\n\nshells: BVectorShells containing bvectors in each shell\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.delete_parallel-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T<:Real","page":"B vector","title":"Wannier.delete_parallel","text":"delete_parallel(bvectors::Vector{Matrix{T}})\n\nRemove shells having parallel bvectors.\n\nArguments\n\nbvectors: vector of bvectors in each shell\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.flatten_shells-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T<:Real","page":"B vector","title":"Wannier.flatten_shells","text":"flatten_shells(shells::BVectorShells)\n\nFlatten shell vectors into a matrix.\n\nReturn a tuple of (bvecs, bvecs_weight), where\n\nbvecs: 3 * n_bvecs\nbvecs_weight: n_bvecs\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.get_bvectors-Tuple{Vector{<:StaticArraysCore.SVector{3}}, StaticArraysCore.SMatrix{3, 3, <:Real, 9}}","page":"B vector","title":"Wannier.get_bvectors","text":"get_bvectors(kpoints, recip_lattice; kmesh_tol=1e-6)\n\nGenerate and sort bvectors for all the kpoints.\n\nArguments\n\nkpoints: 3 * n_kpts, kpoints in fractional coordinates\nrecip_lattice: 3 * 3, columns are reciprocal lattice vectors\n\nKeyword Arguments\n\nkmesh_tol: equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.get_bvectors_nearest-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T<:Real","page":"B vector","title":"Wannier.get_bvectors_nearest","text":"get_bvectors_nearest(kpoints, recip_lattice; kmesh_tol=1e-6)\n\nGenerate and sort bvectors for all the kpoints.\n\nArguments\n\nkpoints: 3 * n_kpts, kpoints in fractional coordinates\nrecip_lattice: 3 * 3, columns are reciprocal lattice vectors\n\nKeyword Arguments\n\nkmesh_tol: equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.index_bvector-Tuple{AbstractVector, AbstractVector, Integer, Integer, AbstractVector{<:Integer}}","page":"B vector","title":"Wannier.index_bvector","text":"index_bvector(kpb_k, kpb_G, k1, k2, b)\n\nGiven bvector b connecting kpoints k1 and k2, return the index of the bvector ib.\n\nThis is a reverse search of bvector index if you only know the two kpoints k1 and k2, and the connecting displacement vector b.\n\nArguments\n\nkpb_k: n_bvecs * n_kpts, k+b kpoints at k1\nkpb_G: 3 * n_bvecs * n_kpts, displacement vector for k+b bvectors at k1\nk1: integer, index of kpoint k1\nk2: integer, index of kpoint k2\nb: vector of 3 integer, displacement vector from k1 to k2\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.search_shells-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T<:Real","page":"B vector","title":"Wannier.search_shells","text":"search_shells(kpoints, recip_lattice; atol=1e-6, max_shells=36)\n\nSearch bvector shells satisfing B1 condition.\n\nArguments\n\nkpoints: fractional coordinates\nrecip_lattice: each column is a reciprocal lattice vector\n\nKeyword Arguments\n\natol: tolerance to select a shell (points having equal distances),   equivalent to Wannier90 input parameter kmesh_tol.\nmax_shells: max number of nearest-neighbor shells,   equivalent to Wannier90 input parameter search_shells.\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.sort_bvectors-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T<:Real","page":"B vector","title":"Wannier.sort_bvectors","text":"sort_bvectors(shells::BVectorShells; atol=1e-6)\n\nSort bvectors in shells at each kpoints, to be consistent with Wannier90.\n\nWannier90 use different order of bvectors at each kpoint, in principle, this is not needed. However, the mmn file is written in such order, so we need to sort bvectors and calculate weights, since nnkp file has no section of weights.\n\nArguments\n\nshells: BVectorShells\n\nKeyword Arguments\n\natol: equivalent to Wannier90 input parameter kmesh_tol\n\n\n\n\n\n","category":"method"},{"location":"api/bvector/#Wannier.sort_supercell-Tuple{AbstractVector, AbstractMatrix}","page":"B vector","title":"Wannier.sort_supercell","text":"sort_supercell(translations, recip_lattice; atol=1e-8)\n\nSort supercell to fix the order of bvectors.\n\nBoth input and output translations are in fractional coordinates.\n\nArguments\n\ntranslations: 3 * n_supercell matrix, in fractional coordinates\nrecip_lattice: each column is a reciprocal lattice vector\n\nKeyword Arguments\n\natol: tolerance to compare bvectors,   this is the same as what is hardcoded in Wannier90\n\nnote: Note\nThis is used to reproduce Wannier90 bvector order.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Real-space-WFs","page":"Real space","title":"Real space WFs","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"This page lists functions for processing WFs in real space.","category":"page"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Normally operators are computed in reciprocal space, but sometimes it might be useful to evaluate them in real space. For example, computing higher moment of WFs.","category":"page"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"CurrentModule = Wannier","category":"page"},{"location":"api/realspace/#Contents","page":"Real space","title":"Contents","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Pages = [\"realspace.md\"]\nDepth = 2","category":"page"},{"location":"api/realspace/#Index","page":"Real space","title":"Index","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Pages = [\"realspace.md\"]","category":"page"},{"location":"api/realspace/#Real-space-grid-struct","page":"Real space","title":"Real-space grid struct","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"common/rgrid.jl\"]","category":"page"},{"location":"api/realspace/#Wannier.RGrid","page":"Real space","title":"Wannier.RGrid","text":"struct RGrid(basis, X, Y, Z)\n\nRepresents a regular grid of points.\n\nFields\n\nbasis: each column is a basis vector of the grid,   usually just the lattice vectors.\nX: nx * ny * nz array of fractional coordinate w.r.t basis,   the x coordinate of each point in the grid.\nY: nx * ny * nz array of fractional coordinate w.r.t basis,   the y coordinate of each point in the grid.\nZ: nx * ny * nz array of fractional coordinate w.r.t basis,   the z coordinate of each point in the grid.\n\ntip: Tip\nThe X, Y, and Z are usually generated by LazyGrids.ndgrid. They are fractional and can be outside of [0, 1), so the basis are not necessarily the spanning vectors of the grid. See also origin and span_vectors.Usually the grid does not contain the periodically repeated points, e.g., the x coordinate can be [0.0, 0.25, 0.5, 0.75] without 1.0 which is repeatition of 0.0.\n\n\n\n\n\n","category":"type"},{"location":"api/realspace/#Wannier.RGrid-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}","page":"Real space","title":"Wannier.RGrid","text":"RGrid(basis, origin, X, Y, Z)\n\nConstruct a regular grid of points.\n\nArguments\n\nbasis: each column is a basis vector of the grid,   usually just the lattice vectors.\norigin: 3, origin of the grid in cartesian coordinates\nX: nx vector of fractional coordinate w.r.t basis,   the x coordinate of each point in the grid.\nY: ny vector of fractional coordinate w.r.t basis,   the y coordinate of each point in the grid.\nZ: nz vector of fractional coordinate w.r.t basis,   the z coordinate of each point in the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.cartesianize_xyz-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.cartesianize_xyz","text":"cartesianize_xyz(rgrid::RGrid)\n\nReturn X, Y, Z in cartesian coordinates.\n\nThe size of the returned X, Y, and Z are nx * ny * nz.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.origin-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.origin","text":"origin(rgrid::RGrid)\n\nGet the origin in cartesian coordinates, i.e. the 1st point, of the RGrid.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.span_vectors-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.span_vectors","text":"span_vectors(rgrid::RGrid)\n\nGet the spanning vectors of the RGrid.\n\nEach column in the returned matrix is a spanning vector.\n\nnote: Note\nThere is no limit constraint on the fractional coordinates X, Y, and Z, so the spanning vectors are not necessarily the basis vectors, they can be fractional of the basis vectors, or multiple times of that.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Read/write-real-space-WFs","page":"Real space","title":"Read/write real-space WFs","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"realspace/wavefunction.jl\"]","category":"page"},{"location":"api/realspace/#Wannier._get_unk_ext-Tuple{AbstractString}","page":"Real space","title":"Wannier._get_unk_ext","text":"_get_unk_ext(unkdir::AbstractString)\n\nGet the extension name of UNK files.\n\nFor example:\n\n1 of UNK00001.1, for no-spin calcluation\nNC of UNK00001.NC, for non-collinear calculation\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, Union{Int64, AbstractArray{Int64}}}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(lattice, U, kpoints, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a more user-friendly version, which returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nlattice: each column is a lattice vector\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(U, kpoints, n_supercells, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nArguments\n\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\nkpoints: 3 * n_kpts, each column is a vector for fractional coordinates\nn_supercells: an integer or a vector of 3 integers for 3 directions along lattice vectors,   defines the number of super cells where the real space WF lives\nunkdir: folder containing UNK files\n\nKeyword arguments\n\nR: fractional coordinates w.r.t lattice (actually integers), the cell for WF   n bmR rangle, default is generating WF at home unit cell n bm0 rangle\n\ntip: Tip\nSee also the section Normalization convention of WFs for further explanation.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}, Union{Int64, AbstractArray{Int64}}}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(model, U, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a most user-friendly version, use lattice, U and kpoints from model and returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nmodel: a Model\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{Wannier.Model{T}}, Tuple{T}, Tuple{Wannier.Model{T}, Union{Int64, AbstractArray{Int64}}}, Tuple{Wannier.Model{T}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(model, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a most user-friendly version, use lattice, U and kpoints from model and returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nmodel: a Model\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.write_realspace_wf-Tuple{AbstractString, AbstractArray, Vector, AbstractMatrix, AbstractVector, AbstractVector{String}}","page":"Real space","title":"Wannier.write_realspace_wf","text":"write_realspace_wf(seedname, U, kpoints, lattice, atom_positions, atom_labels;\n    n_supercells=2, unkdir=\".\", part=real, format=:xsf, wf_center=nothing)\n\nWrite real space WFs to xsf or cube files.\n\nArguments\n\nseedname: the name prefix for cube files, e.g., seedname_00001.cube\nU: gauge rotation matrix\nkpoints: each column is a kpoint, fractional coordinates\nlattice: each column is a lattice vector\natom_positions: each column is an atom position, fractional coordinates w.r.t. lattice\natom_labels: each element is an atom label\n\nKeyword arguments\n\nn_supercells: number of supercells in each direction,   equivalent to wannier_plot_supercell of Wannier90\nunkdir: directory of UNK files\npart: which part to plot? pass a Function, e.g. real, imag, abs2\nformat: :xsf or :cube\nwf_center: WF centers in fractional coordinates w.r.t. lattice.   Only used for cube format, add additional atoms around WF centers.\n\nnote: Note\nWannier90 only plot the real part of WFs, so part=real is the default.\n\ntip: Tip\nSee also the section Normalization convention of WFs for further explanation.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.write_realspace_wf-Tuple{String, Wannier.Model}","page":"Real space","title":"Wannier.write_realspace_wf","text":"write_realspace_wf(seedname, model; n_supercells=2, unkdir=\".\", part=real, format=:xsf)\n\nWrite real space WFs to xsf or cube files.\n\nThis is a user-friendly version that use model to fill the arguments of write_realspace_wf.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Evaluate-operators-in-real-space","page":"Real space","title":"Evaluate operators in real space","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"realspace/moment.jl\"]","category":"page"},{"location":"api/realspace/#Wannier.center-Tuple{Wannier.RGrid, AbstractArray}","page":"Real space","title":"Wannier.center","text":"center(rgrid::RGrid, W::AbstractArray)\n\nCompute WF center in real space.\n\nReturned value in Cartesian coordinates.\n\nSee also moment.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.moment-Union{Tuple{U}, Tuple{T}, Tuple{Wannier.RGrid, AbstractArray{T, 3}, U}} where {T<:Complex, U<:Integer}","page":"Real space","title":"Wannier.moment","text":"moment(rgrid::RGrid, W::AbstractArray, n)\n\nCompute WF moment to arbitrary order in real space.\n\nArguments\n\nrgrid: real space grid on which W is defined\nW: WFs, nx * ny * nz * n_wann, or nx * ny * nz for single WF\nn: order of moment, e.g., 1 for WF center, 2 for variance, etc.\n\nReturned value in Cartesian coordinates.\n\nnote: Note\nThe WFs are defined in a supercell that is n_kpts times unit cell, however, usually we only calculate realspace WFs in a smaller supercell that is 2^3 or 3^3 times unit cell (as defined by the n_supercells argument of read_realspace_wf). Some times this is not sufficient if the WFs are truncated by the boundries of the smaller supercell, thus the center calculated by this function is inexact. In principle, we should calculate centers in the n_kpts supercell, however, this is memory-consuming.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.omega-Tuple{Wannier.RGrid, AbstractArray}","page":"Real space","title":"Wannier.omega","text":"omega(rgrid::RGrid, W::AbstractArray)\n\nCompute WF spread in real space.\n\nReturned value in Å^2 unit.\n\nSee also moment.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.position_op-Union{Tuple{T}, Tuple{Wannier.RGrid, AbstractArray{T, 4}}} where T<:Complex","page":"Real space","title":"Wannier.position_op","text":"position_op(rgrid::RGrid, W::AbstractArray{T,4})\n\nCompute position operator matrices in real space.\n\nReturned value in Cartesian coordinates.\n\nSee also center.\n\n\n\n\n\n","category":"method"},{"location":"api/cli/#Command-line-interface","page":"Command line","title":"Command line interface","text":"","category":"section"},{"location":"api/cli/","page":"Command line","title":"Command line","text":"A simple command line interface is generated with Comonicon.jl.","category":"page"},{"location":"api/cli/","page":"Command line","title":"Command line","text":"CurrentModule = Wannier","category":"page"},{"location":"api/cli/#Index","page":"Command line","title":"Index","text":"","category":"section"},{"location":"api/cli/","page":"Command line","title":"Command line","text":"Pages = [\"cli.md\"]","category":"page"},{"location":"api/cli/#Commands","page":"Command line","title":"Commands","text":"","category":"section"},{"location":"api/cli/","page":"Command line","title":"Command line","text":"Modules = [Wannier]\nPages   = [\n    \"cli/main.jl\",\n    \"cli/max_localize.jl\",\n    \"cli/disentangle.jl\",\n    \"cli/parallel_transport.jl\",\n    \"cli/split_wannierize.jl\",\n    \"cli/opt_rotate.jl\",\n    \"cli/truncate.jl\",\n    \"cli/band.jl\",\n    \"cli/fermisurf.jl\",\n]","category":"page"},{"location":"api/cli/#Wannier.COMMAND_ENTRY_DOC_STUB","page":"Command line","title":"Wannier.COMMAND_ENTRY_DOC_STUB","text":"Julia package for Wannier functions.\n\n\n\n\n\n","category":"constant"},{"location":"api/cli/#Wannier.maxloc","page":"Command line","title":"Wannier.maxloc","text":"Maximally localize an isolated group of bands.\n\nArgs\n\nseedname: seedname for win/amn/mmn/eig files\n\nOptions\n\n-o, --output=<str>: filename for output amn. Default is seedname.maxloc.amn\n-m, --maxiter=<int>: max number of iterations. Default is 50\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.dis","page":"Command line","title":"Wannier.dis","text":"Maximally localize a group of entangled bands.\n\nArgs\n\nseedname: seedname for win/amn/mmn/eig files\n\nOptions\n\n-o, --output=<str>: filename for output amn. Default is seedname.dis.amn\n-m, --maxiter=<int>: max number of iterations. Default is 50\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.ptg","page":"Command line","title":"Wannier.ptg","text":"Generate parallel transport gauge Wannier functions.\n\nArgs\n\nseedname: seedname for win/amn/mmn/eig files\n\nOptions\n\n-o, --output: filename for output amn. Default is seedname.ptg.amn\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.splitvc","page":"Command line","title":"Wannier.splitvc","text":"Split valence and conduction Wannier functions.\n\nUsually start from a Wannierization of valence+conduction bands. Then this command split WFs into two independent groups.\n\nArgs\n\nseedname: seedname for win/amn/mmn/eig files\n\nOptions\n\n--nval: number of valence WFs. Default is n_wann ÷ 2\n--outdir-val: dirname for output valence amn/mmn/eig. Default is val\n--outdir-cond: dirname for output conduction amn/mmn/eig. Default is cond\n--config: config file for splitvc command, e.g.   toml   [groups]   indices = [ [ 1, 2,], [ 3, 4, 5, 6,], [ 7, 8,], ]   outdirs = [ \"val_1\", \"val_2\", \"cond_3\",]\n\nFlags\n\n--run-disentangle: read amn and run disentangle first, otherwise read chk to   get unitary matrices from n_bands to n_wann\n--run-optrot: max localize w.r.t. single unitary matrix after parallel transport.   Should further reduce the spread and much closer to the true max localization.\n--run-maxloc: run a final max localize w.r.t. all kpoints.   Should reach the true max localization.\n--rotate-unk: generate unk files for valence and conduction, for plotting WFs\n--binary: write amn/mmn/eig/unk in Fortran binary format\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.optrot","page":"Command line","title":"Wannier.optrot","text":"Maximally localize w.r.t a single unitary rotation of all the kpoints.\n\nUsually should start from parallel transport gauge amn, where the gauge are already smoothened w.r.t. kpoints. However, there is sitll a global unitary transformation freedom, which will be minimized by this optimal rotation function.\n\nArgs\n\nseedname: seedname for win/amn/mmn/eig files\n\nOptions\n\n-o, --output=<str>: filename for output amn. Default is seedname.optrot.amn\n-m, --maxiter=<int>: max number of iterations. Default is 50\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.trunc","page":"Command line","title":"Wannier.trunc","text":"Truncate number of bands in mmn/eig/unk files.\n\nArgs\n\nseedname: seedname for mmn/eig files\nkeep-bands: indices of bands to be kept, start from 1\n\nOptions\n\n--outdir: dirname for output mmn/eig. Default is truncate\n\nFlags\n\n--rotate-unk: also truncate unk files, for plotting WFs\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.band","page":"Command line","title":"Wannier.band","text":"Interpolate band structure.\n\nArgs\n\nseedname: seedname for amn/mmn/eig/chk files\n\nOptions\n\n--out: output seedname for bands.dat. Default is wjl\n--amn: amn filename. If not given, default is read chk.fmt file\n\n\n\n\n\n","category":"function"},{"location":"api/cli/#Wannier.fermisurf","page":"Command line","title":"Wannier.fermisurf","text":"Interpolate Fermi surface.\n\nArgs\n\nseedname: seedname for amn/mmn/eig/chk files or tb/wsvec.dat file\n\nOptions\n\n--nk: number of interpolated kpoints along each reciprocal lattice vector. Default is 50,   on output bxsf, there will be 51 points (the last point is the periodic image of the first point).\n--dk: spacing of interpolated kpoints along each reciprocal lattice vector, in unit of Å^-1.   Default is a negative number, meaning I will use --nk instead; if dk > 0, dk will take precedence.   The number of interpolated kpoints is the nearest integer to a/dk,   where a is the norm of each reciprocal lattice vector. Also plus 1 due to   the same reason in --nk.\n--ef: Fermi energy. Default is 0.0.\n--out: output seedname for bxsf. Default is wjl\n--amn: amn filename. If not given, default is read chk.fmt file\n\nFlags\n\n--tb: read tb/wsvec.dat file instead of amn/mmn/eig/chk files. Default is false.\n\n\n\n\n\n","category":"function"},{"location":"examples_foreword/#Foreword-to-the-examples","page":"Foreword to the examples","title":"Foreword to the examples","text":"","category":"section"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"CurrentModule = Wannier","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"If you have already been familiar with the Wannierization workflow using Wannierization workflow using Quantum ESPRESSO and wannier90, the following examples should be easy to follow. As a side note, some good wannier90 tutorials can be found at","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"examples and tutorials.pdf of Wannier90\nhttps://github.com/wannier-developers/wannier-tutorials","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"warning: Warning\nIn this repo, the convergence parameters (kpoint sampling, ...) when generating the input files (e.g., amn/mmn/eig/...) are quite loose! This is on purpose to reduce storage size and save computational time. Thus, it is expected that the band interpolation might have some defects.In real applications, one should always run calculations with production-quality convergence parameters for high-quality band interpolations.","category":"page"},{"location":"examples_foreword/#WannierDatasets","page":"Foreword to the examples","title":"WannierDatasets","text":"","category":"section"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Throughout the examples, we need to load input files to construct Models for Wannierizations. Often, preparing these input files requires density-functional-theory calculations which can be time-consuming, and distracting ourselves from the main purpose of Wannierizations and Wannier interpolations.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Julia has a convenient artifact system allowing us to load binaries or data files easily in Julia script or REPL, without the need of manually downloading and placing them in the right folder.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"In Wannier.jl, we use such system to load our pre-computed WannierDatasets, which contains some typical materials, e.g., silicon, copper, graphene, etc. This allows easy loading of input files and construct Wannier functions hassle-free.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"The Wannier.Datasets submodule provides several functions to help inspect and load the datasets. First, we need to using the submodule to bring the functions into scope","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"using Wannier.Datasets","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"List all available datasets by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"list_datasets()","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Load a dataset into a Wannier.jl Model by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"model = load_dataset(\"Si2\")","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"The dataset is just a folder containing input files, you can inspect the folder by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"show_dataset(\"Si2\")","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Finally, you can directly access the individual files by dataset string which just returns a string of the path to the file","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"dataset\"Si2/Si2.win\"","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"For example, you can read the content of a file by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"readlines(dataset\"Si2/Si2.win\")","category":"page"},{"location":"api/model/#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The Model is a Julia struct that abstracts a single Wannierization, it contains all the necessary information for maximally localization of the crystal structure.","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"CurrentModule = Wannier","category":"page"},{"location":"api/model/#Contents","page":"Model","title":"Contents","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Pages = [\"model.md\"]\nDepth = 2","category":"page"},{"location":"api/model/#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Pages = [\"model.md\"]","category":"page"},{"location":"api/model/#Model-2","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Modules = [Wannier]\nPages   = [\"src/model.jl\"]  # explicitly add \"src/\" to avoid matching InterpModel","category":"page"},{"location":"api/model/#Wannier.Model","page":"Model","title":"Wannier.Model","text":"struct Model\n\nA struct containing the parameters and matrices of the crystal structure.\n\nFields\n\nlattice: columns are the lattice vectors\natom_positions: columns are the fractional coordinates of atoms\natom_labels: labels of atoms\nkgrid: number of kpoints along 3 lattice vectors\nkpoints: columns are the fractional coordinates of kpoints\nbvectors: bvectors satisfying the B1 condition\nfrozen_bands: indicates which bands are frozen\nM: n_bands * n_bands * n_bvecs * n_kpts, overlap matrix M_bmkbmb\nU: n_bands * n_wann * n_kpts, (semi-)unitary gauge rotation matrix U_bmk\nE: n_bands * n_kpts, energy eigenvalues epsilon_n bmk\nrecip_lattice: columns are the reciprocal lattice vectors\nn_atoms: number of atoms\nn_bands: number of bands\nn_wann: number of wannier functions\nn_kpts: number of kpoints\nn_bvecs: number of bvectors\n\nnote: Note\nThis only cotains the necessary information for maximal localization. For Wannier interpolation, see TBHamiltonian.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.Model-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{<:String}, StaticArraysCore.SVector{3, Int64}, Array{StaticArraysCore.SVector{3, T}, 1}, Wannier.BVectors{T}, Vector{BitVector}, Any, Any, Any}} where T<:Real","page":"Model","title":"Wannier.Model","text":"Model(lattice, atom_positions, atom_labels, kgrid, kpoints, bvectors, frozen_bands, M, U, E)\n\nConstruct a Model struct.\n\nArguments\n\nlattice: columns are the lattice vectors\natom_positions: columns are the fractional coordinates of atoms\natom_labels: labels of atoms\nkgrid: number of kpoints along 3 lattice vectors\nkpoints: columns are the fractional coordinates of kpoints\nbvectors: bvectors satisfying the B1 condition\nfrozen_bands: indicates which bands are frozen\nM: n_bands * n_bands * n_bvecs * n_kpts, overlap matrix M_bmkbmb\nU: n_bands * n_wann * n_kpts, (semi-)unitary gauge rotation matrix U_bmk\nE: n_bands * n_kpts, energy eigenvalues epsilon_n bmk\n\ntip: Tip\nThis is more user-friendly constructor, only necessary information is required. Remaining fields are generated automatically.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.rotate_gauge-Union{Tuple{T}, Tuple{Wannier.Model, Array{Matrix{T}, 1}}} where T<:Number","page":"Model","title":"Wannier.rotate_gauge","text":"rotate_gauge(model::Model, U::Array{T,3}; diag_H=false)\n\nRotate the gauge of a Model.\n\nArguments\n\nmodel: a Model struct\nU: n_bands * n_wann * n_kpts, (semi-)unitary gauge rotation matrix U_bmk\n\nKeyword Arguments\n\ndiag_H: if after rotation, the Hamiltonian is not diagonal, then diagonalize it and   save the eigenvalues to model.E, and the inverse of the eigenvectors to model.U,   so that the model is still in the input gauge U.   Otherwise, if the rotated Hamiltonian is not diagonal, raise error.\n\nnote: Note\nThe original Model.U will be discarded; the M, and E matrices will be rotated by the input U. However, since E is not the Hamiltonian matrices but only the eigenvalues, if diag_H = false, this function only support rotations that keep the Hamiltonian in diagonal form.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Spread","page":"Model","title":"Spread","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Modules = [Wannier]\nPages   = [\"spread.jl\"]","category":"page"},{"location":"api/model/#Wannier.CenterSpreadPenalty","page":"Model","title":"Wannier.CenterSpreadPenalty","text":"Penalty for minimizing the spread as well as maximizing the \"closeness\" to the atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.Spread","page":"Model","title":"Wannier.Spread","text":"struct Spread\n\nThe Marzari-Vanderbilt (MV) spread functional.\n\nFrom MV:\n\nOmega = sum_n langle r^2 rangle_n -  langle r rangle_n ^2\nlangle r rangle_n = -frac1N sum_bmkbmb w_bmb bmb   Im log M_nn^bmkbmb\nlangle r^2 rangle_n = frac1N sum_bmkbmb w_bmb bmb   left left( 1 -  M_nn^bmkbmb ^2 right) +   left( Im log M_nn^bmkbmb right)^2 right\n\nFields\n\nΩ: total spread, unit Å²\nΩI: gauge-invarient part, unit Å²\nΩOD: off-diagonal part, unit Å²\nΩD: diagonal part, unit Å²\nΩ̃: Ω̃ = ΩOD + ΩD, unit Å²\nω: Ω of each WF, unit Å², length(ω) = n_wann\nr: WF center, Cartesian coordinates, unit Å, 3 * n_wann\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.SpreadCenter","page":"Model","title":"Wannier.SpreadCenter","text":"struct SpreadCenter\n\nA struct containing both Spread and WF center penalty.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.SpreadPenalty","page":"Model","title":"Wannier.SpreadPenalty","text":"Standard penalty for minimizing the total spread.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.berry_connection-Union{Tuple{FT}, Tuple{Wannier.BVectors{FT}, Vector, Array{Array{Complex{FT}, 2}, 1}}} where FT<:Real","page":"Model","title":"Wannier.berry_connection","text":"berry_connection(bvectors, M, U)\n\nCompute Berry connection at each kpoint.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Tuple{Wannier.BVectors, Any, Any}","page":"Model","title":"Wannier.center","text":"center(bvectors, M, U)\n\nCompute WF center in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Tuple{Wannier.Model}","page":"Model","title":"Wannier.center","text":"center(model)\n\nCompute WF center in reciprocal space for Model.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Union{Tuple{FT}, Tuple{Wannier.BVectors{FT}, Vector, Array{Complex{FT}, 3}}} where FT<:Real","page":"Model","title":"Wannier.center","text":"center(bvectors, M, U)\n\nCompute WF center in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Union{Tuple{T}, Tuple{Wannier.Model, Array{Matrix{T}, 1}}} where T<:Number","page":"Model","title":"Wannier.center","text":"center(model, U)\n\nCompute WF center in reciprocal space for Model with given U gauge.\n\nArguments\n\nmodel: the Model\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega-Tuple{Wannier.Model}","page":"Model","title":"Wannier.omega","text":"omega(model, [U])\nomega(bvectors, M, U)\n\nCompute WF spread for a Model, potentially for a given gauge U, or by explicitely giving bvectors and M. In case of the first bvectors = model.bvectors and M = model.M.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_center-Tuple","page":"Model","title":"Wannier.omega_center","text":"omega_center(bvectors, M, U, r₀, λ)\n\nCompute WF spread with center penalty, for maximal localization.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\nr₀: 3 * n_wann, WF centers in cartesian coordinates\nλ: penalty strength\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_grad-Tuple{Function, Wannier.BVectors, Any, Any}","page":"Model","title":"Wannier.omega_grad","text":"omega_grad(bvectors, M, U, r)\n\nCompute gradient of WF spread.\n\nSize of output dΩ/dU = n_bands * n_wann * n_kpts.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\nr: 3 * n_wann, the current WF centers in cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_local-Union{Tuple{FT}, Tuple{Wannier.BVectors{FT}, Vector, Array{Array{Complex{FT}, 2}, 1}}} where FT<:Real","page":"Model","title":"Wannier.omega_local","text":"omega_local(bvectors, M, U)\n\nLocal part of the contribution to r^2.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Tuple{Wannier.Model}","page":"Model","title":"Wannier.position_op","text":"position_op(model)\n\nCompute WF postion operator matrix in reciprocal space for Model.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Union{Tuple{FT}, Tuple{Wannier.BVectors{FT}, Vector, Array{Array{Complex{FT}, 2}, 1}}} where FT<:Real","page":"Model","title":"Wannier.position_op","text":"position_op(bvectors, M, U)\n\nCompute WF postion operator matrix in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Union{Tuple{T}, Tuple{Wannier.Model, Array{Matrix{T}, 1}}} where T<:Number","page":"Model","title":"Wannier.position_op","text":"position_op(model, U)\n\nCompute WF postion operator matrix in reciprocal space for Model with given U gauge.\n\nArguments\n\nmodel: the Model\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"start/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"start/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"start/#Julia","page":"Getting Started","title":"Julia","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"First install Julia, you can,","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"use juliaup\nor download releases from https://julialang.org/downloads/","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nQuick notes for installing juliaup, on Linux or macOS:curl -fsSL https://install.julialang.org | sh\njuliaup add release","category":"page"},{"location":"start/#Wannier.jl","page":"Getting Started","title":"Wannier.jl","text":"","category":"section"},{"location":"start/#From-Julia-package-manager","page":"Getting Started","title":"From Julia package manager","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Install with the Julia package manager Pkg, just like any other registered Julia package:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"pkg> add Wannier  # Press ']' to enter the Pkg mode","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"or","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Wannier\")","category":"page"},{"location":"start/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"If you want to play with the code, you can clone the repo:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/qiaojunfeng/Wannier.jl.git\ncd Wannier.jl\njulia --project=. -e 'using Pkg; Pkg.update(); Pkg.resolve(); Pkg.instantiate()'","category":"page"},{"location":"start/#From-tarball","page":"Getting Started","title":"From tarball","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Download releases from https://github.com/qiaojunfeng/Wannier.jl/releases","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tar xvf Wannier.jl.tar.gz\ncd Wannier.jl\njulia --project=. -e 'using Pkg; Pkg.update(); Pkg.resolve(); Pkg.instantiate()'","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nIf you install with Pkg, then start Julia REPL just with julia; if you install with git or tarball, then start with julia --project=PATH_OF_Wannier.jl.","category":"page"},{"location":"start/#Command-line-interface","page":"Getting Started","title":"Command-line interface","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Additionally, there is a command-line interface (CLI)","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\njulia --project deps/build.jl install  # install CLI","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The executable will be installed in ~/.julia/bin/wjl.","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"After appending ~/.julia/bin to your $PATH, you can use the CLI as follows:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"$ wjl -h\n\n\n  wannier v0.1.0\n\nJulia package for Wannier functions.\n\nUsage\n\n  wannier <command>\n...","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"note: Note\nSince julia needs precompilation of the code, there will be some delay when running the CLI.","category":"page"},{"location":"start/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"For example, running a maximal localization can be easily achieved by","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"using Wannier\n\nmodel = read_w90(\"silicon\")\nU = max_localize(model)\nwrite_amn(\"silicon.amn\", U)","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"For a much more detailed usage, please refer to the API documentation and the source code of each function.","category":"page"},{"location":"start/#Development","page":"Getting Started","title":"Development","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The repo is hosted at https://github.com/qiaojunfeng/Wannier.jl","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"To reduce the startup latency of the Wannier.jl package, and to allow smoother user/development experience, some of the functionality are implemented inside standalone packages:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The input/output functions are inside   WannierIO.jl repo,   and its documentation at   io.wannierjl.org\nThe plotting related code is inside   WannierPlots.jl repo,   and its documentation at   plots.wannierjl.org","category":"page"},{"location":"start/#Pre-commit","page":"Getting Started","title":"Pre-commit","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"To ensure uniform code style, we use pre-commit, which auto check and fix code style before each git commit. Install the hooks with","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\npre-commit install","category":"page"},{"location":"start/#Tests","page":"Getting Started","title":"Tests","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Run tests with","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\njulia --project=.  # start REPL\n]                  # activate Pkg mode\ntest               # run tests","category":"page"},{"location":"WannierPlots/api/bvector/#B-vectors","page":"B vectors","title":"B vectors","text":"","category":"section"},{"location":"WannierPlots/api/bvector/","page":"B vectors","title":"B vectors","text":"CurrentModule = WannierPlots","category":"page"},{"location":"WannierPlots/api/bvector/#Contents","page":"B vectors","title":"Contents","text":"","category":"section"},{"location":"WannierPlots/api/bvector/","page":"B vectors","title":"B vectors","text":"Pages = [\"bvector.md\"]\nDepth = 2","category":"page"},{"location":"WannierPlots/api/bvector/#Index","page":"B vectors","title":"Index","text":"","category":"section"},{"location":"WannierPlots/api/bvector/","page":"B vectors","title":"B vectors","text":"Pages = [\"bvector.md\"]","category":"page"},{"location":"WannierPlots/api/bvector/#API","page":"B vectors","title":"API","text":"","category":"section"},{"location":"WannierPlots/api/bvector/","page":"B vectors","title":"B vectors","text":"Modules = [WannierPlots]\nPages   = [\n    \"bvectors.jl\",\n]","category":"page"},{"location":"api/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"This page lists struct and functions for Wannier interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"There are two flavors of interpolation:","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"WS: the Wigner-Seitz interpolation\nMDRS: the Minimal-distance replica selection method","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"MDRS has better interpolation quality[WAN20], so it should be used in most cases. Moreover, we implement two versions of MDRS:","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"MDRSv1: the original version in Wannier90[WAN20].   This is slower than the WS interpolation.\nMDRSv2: a slightly modified version which removes some for loops, same as what is implemented   in Wannier Berri[WBERRI]. The speed is similar to the WS interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"By default, we use the MDRSv2 interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Wannier","category":"page"},{"location":"api/interpolation/#Contents","page":"Interpolation","title":"Contents","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Pages = [\"interpolation.md\"]\nDepth = 2","category":"page"},{"location":"api/interpolation/#Index","page":"Interpolation","title":"Index","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Pages = [\"interpolation.md\"]","category":"page"},{"location":"api/interpolation/#R-vectors","page":"Interpolation","title":"R vectors","text":"","category":"section"},{"location":"api/interpolation/#RVectors","page":"Interpolation","title":"RVectors","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nThe R vectors are automatically generated by calling either of these two approaches:read_w90_with_chk to read the Wannier90 output seedname.chk.fmt file,   and generate an InterpModel,\nInterpModel a constructor   to generate the InterpModel from a Wannierization Model.So usually the user does not need to call the following functions.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/rvector.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.RVectors","page":"Interpolation","title":"Wannier.RVectors","text":"struct RVectors\n\nThe R vectors for interpolation.\n\nFields\n\nlattice: columns are lattice vectors\ngrid: number of FFT grid points in each direction, actually equal to kgrid\nR: 3 * n_rvecs, R vectors in fractional coordinates w.r.t. lattice\nN: n_rvecs, degeneracy of each R vector\n\nnote: Note\nThe R vectors are sorted in the same order as Wannier90.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/#Wannier.RVectors-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVector{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{T}}} where T<:Integer","page":"Interpolation","title":"Wannier.RVectors","text":"RVectors(lattice, grid, R, N)\n\nConstructor for RVectors.\n\nAuto transform lattice and grid to Mat3 and Vec3, respectively.\n\nArguments\n\nlattice: columns are lattice vectors\ngrid: number of FFT grid points in each direction, actually equal to kgrid\nR: 3 * n_rvecs, R vectors in fractional coordinates w.r.t. lattice\nN: n_rvecs, degeneracy of each R vector\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.RVectorsMDRS","page":"Interpolation","title":"Wannier.RVectorsMDRS","text":"struct RVectorsMDRS\n\nThe R vectors for MDRS interpolation.\n\nFields\n\nRvectors: Rvectors for Wigner-Seitz interpolation\n\nFor MDRSv1\n\nT: n_wann * n_wann * n_rvecs, translation vectors w.r.t to lattice for MDRSv1\nNᵀ: n_wann * n_wann * n_rvecs, degeneracy of each T vector for MDRSv1\n\nFor MDRSv2\n\nR̃vectors: RVectors containing expanded set of R + T vectors used in MDRSv2\nR̃_RT: mapping of R̃vectors to R and T vectors\n\nnote: Note\nThe R vectors are sorted in the same order as Wannier90.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/#Wannier.RVectorsMDRS-Tuple{Wannier.RVectors, Vector{Matrix{Vector{StaticArraysCore.SVector{3, Int64}}}}, Vector{Matrix{Int64}}}","page":"Interpolation","title":"Wannier.RVectorsMDRS","text":"RVectorsMDRS(Rvectors, T, Nᵀ)\n\nA friendly constructor for RVectorsMDRS.\n\nThe remaining fields R̃vectors and R̃_RT are only used in MDRSv2, the are calculated automatically based on the input arguments.\n\nArguments\n\nRvectors: RVectors for Wigner-Seitz interpolation\nT: n_wann * n_wann * n_rvecs, translation vectors w.r.t to lattice for MDRSv1\nNᵀ: n_wann * n_wann * n_rvecs, degeneracy of each T vector for MDRSv1\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.check_weights-Tuple{Wannier.RVectors}","page":"Interpolation","title":"Wannier.check_weights","text":"check_weights(R::RVectors)\n\nSanity check for the degeneracies of R vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.get_Rvectors_mdrs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.get_Rvectors_mdrs","text":"get_Rvectors_mdrs(lattice, rgrid, centers; atol=1e-5, max_cell=3)\n\nGenerate R vectors for MDRS interpolation (both v1 and v2).\n\nArguments\n\nlattice: columns are lattice vectors\nrgrid: number of FFT grid points in each direction, actually equal to kgrid\ncenters: 3 * n_wann, WF centers in fractional coordinates\n\nKeyword arguments\n\natol: toerance for checking degeneracy,   equivalent to Wannier90 input parameter ws_distance_tol\nmax_cell: number of neighboring cells to be searched,   equivalent to Wannier90 input parameter ws_search_size\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.get_Rvectors_ws-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{R}}} where {T<:Real, R<:Integer}","page":"Interpolation","title":"Wannier.get_Rvectors_ws","text":"get_Rvectors_ws(lattice, rgrid; atol=1e-5, max_cell=3)\n\nGenerate R vectors for Wigner-Seitz interpolation.\n\nArguments\n\nlattice: columns are lattice vectors\nrgrid: number of FFT grid points in each direction, actually equal to kgrid\n\nKeyword arguments\n\natol: toerance for checking degeneracy,   equivalent to Wannier90 input parameter ws_distance_tol\nmax_cell: number of neighboring cells to be searched,   equivalent to Wannier90 input parameter ws_search_size\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#KRVectors","page":"Interpolation","title":"KRVectors","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"The KRVectors contains both kpoint mappings and RVectors, allowing both forward and inverse Fourier transform.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/krvector.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.KRVectors","page":"Interpolation","title":"Wannier.KRVectors","text":"struct KRVectors\n\nContains both kpoints mapping and R vectors.\n\nFields\n\nlattice: each column is a lattice vector\nkgrid: number of kpoints along 3 directions\nkpoints: each column is a kpoint in fractional coordinates\nk_xyz: kpoints mappings from ik to [ikx, iky, ikz]\nxyz_k: kpoints mappings from [ikx, iky, ikz] to ik\nRvectors: R vectors, can be either RVectors or RVectorsMDRS\nrecip_lattice: each column is a reciprocal lattice vector\nn_kpts: number of kpoints\nn_rvecs: number of R vectors\nn_r̃vecs: number of R̃ vectors, only for MDRS\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T<:Real","page":"Interpolation","title":"Wannier.KRVectors","text":"KRVectors(lattice, kgrid, kpoints, Rvectors)\n\nA friendly constructor for KRVectors.\n\nThe kpoint mappings k_xyz and xyz_k are generated based on kpoints and kgrid. Remaining fields are generated automatically based on input arguments.\n\nArguments\n\nlattice: each column is a lattice vector\nkgrid: number of kpoints along 3 directions\nkpoints: each column is a kpoint in fractional coordinates\nRvectors: R vectors, can be either RVectors or RVectorsMDRS\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Vector{StaticArraysCore.SVector{3, Int64}}, Array{Int64, 3}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T<:Real","page":"Interpolation","title":"Wannier.KRVectors","text":"KRVectors(lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors)\n\nA friendly constructor for KRVectors.\n\nRemaining fields are generated automatically based on input arguments.\n\nArguments\n\nlattice: each column is a lattice vector\nkgrid: number of kpoints along 3 directions\nkpoints: each column is a kpoint in fractional coordinates\nk_xyz: kpoints mappings from ik to [ikx, iky, ikz]\nxyz_k: kpoints mappings from [ikx, iky, ikz] to ik\nRvectors: R vectors, can be either RVectors or RVectorsMDRS\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.KRVectors-Union{Tuple{Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}, Tuple{T}} where T<:Real","page":"Interpolation","title":"Wannier.KRVectors","text":"KRVectors(Rvectors)\n\nConstruct a KRVectors from RVectors or RVectorsMDRS.\n\nThe kpoints part are just empty.\n\nnote: Note\nIf we only need to Wannier interpolate operators, e.g., interpolate band structure from tb.dat file, then we don't need info on the kpoint grid of Wannierization, so we can just leave it empty.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Fourier-transforms","page":"Interpolation","title":"Fourier transforms","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Performs Fourier transform between k and R spaces defined by KRVectors.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nIn general, the user only need to call the fourier(kRvectors, Oᵏ) and invfourier(kRvectors, Oᴿ, kpoints) functions directly, irrespective of the type of kRVectors. Other functions are internally used based on the type of KRVectors, thanks to multiple dispatch.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/fourier.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.fourier-Tuple{Function, Any, Any}","page":"Interpolation","title":"Wannier.fourier","text":"fourier(f::Function, q_vectors, R_vectors)\n\nPerforms a fourier transform from the ab-initio kpoints to the wigner seitz unit cells. The function will be executed inside the fourier transform loop, being called like f(iR, ik, phase)\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.invfourier-Union{Tuple{T}, Tuple{Function, Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, StaticArraysCore.SVector{3}}} where T","page":"Interpolation","title":"Wannier.invfourier","text":"Fourier transforms the tight binding hamiltonian and calls the R_function with the current index and the phase.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#InterpModel","page":"Interpolation","title":"InterpModel","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"To separate the Wannier interpolation from Wannierization, we have another model, the InterpModel, which is solely for the purpose of interpolation, while Model works only for Wannierization.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/interp_model.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.InterpModel","page":"Interpolation","title":"Wannier.InterpModel","text":"struct InterpModel\n\nThe model for Wannier interpolation.\n\nStore the real space matrices, e.g., the Hamiltonian H(bmR).\n\nUsually after Wannierization of a Model, we construct this InterpModel for Wannier interpolation of operators.\n\nFields\n\nkRvectors: the kpoints and R vectors\nkpath: the kpoint path for band structure\nH: n_wann * n_wann * n_rvecs, the Hamiltonian in real space\nr: n_wann * n_wann * n_rvecs, the position operator in real space\nS: n_wann * n_wann * n_rvecs * 3, optional, the spin operator\n\nnote: Note\nFor MDRS interpolation, the n_rvecs in this docstring is actually the number of tildebmR vectors, i.e., KRVectors.Rvectors.n_r̃vecs. For WS interpolation, it is just KRVectors.Rvectors.n_rvecs.\n\n\n\n\n\n","category":"type"},{"location":"api/interpolation/#Wannier.InterpModel-Tuple{Wannier.Model}","page":"Interpolation","title":"Wannier.InterpModel","text":"InterpModel(model::Model; mdrs::Bool=true)\n\nConstruct a InterpModel from a Wannierization Model.\n\nArguments\n\nmodel: the Wannierization Model\n\nKeyword Arguments\n\nmdrs: whether to use MDRS interpolation\nkpath: if not given, use get_kpath to auto generate a kpath.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}, Array{T, 4}}} where T<:Complex","page":"Interpolation","title":"Wannier.InterpModel","text":"InterpModel(kRvectors, H, kpath, H, r)\n\nA InterpModel constructor ignoring spin operator matrices.\n\nArguments\n\nkRvectors: the kpoint and R vectors\nkpath: the kpoint path for band structure\nH: n_wann * n_wann * n_rvecs, the Hamiltonian in real space\nr: n_wann * n_wann * n_rvecs * 3, the position operator in real space\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}}} where T<:Complex","page":"Interpolation","title":"Wannier.InterpModel","text":"InterpModel(kRvectors, H, kpath, H)\n\nA InterpModel constructor ignoring position and spin operator matrices.\n\nArguments\n\nkRvectors: the kpoint and R vectors\nkpath: the kpoint path for band structure\nH: n_wann * n_wann * n_rvecs, the Hamiltonian in real space\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Band-structure","page":"Interpolation","title":"Band structure","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"warning: Warning\nNeed some care when comparing the band interpolation between Wannier.jl and Wannier90, after running the Wannier.jl disentanglement and writing an optimized amn file for Wannier90 to interpolate band structure.When Wannier90 read an amn file, it will (Wannier90 v3.1.0)Lowdin orthogonalize the amn matrices, in disentangle.F90:dis_project, line 1418  This should do no harm, since the optimized amn is already semi-unitary,  a SVD of it should not change the optimized amn (apart from numerical noise)\ngenerate a new amn according to the frozen window, in disentangle.F90:dis_proj_froz,  line 1830. This will DESTROY the optimized amn matrices, if we restart  Wannier90 from the optimized amn with dis_num_iter = 0, the spreads in wout file  is very different from the output of Wannier.jl, we must skip this step by commenting  out ALL the dis_froz_min/max in the win file, then  use Wannier90 to interpolate bands, remember also set num_iter and dis_num_ite = 0.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/hamiltonian.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.HamiltonianKGrid-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{<:StaticArraysCore.SVector{3}}}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{<:StaticArraysCore.SVector{3}}, Function}} where T","page":"Interpolation","title":"Wannier.HamiltonianKGrid","text":"HamiltonianKGrid(hami::TBHamiltonian{T}, nk, H_function_k::Function = x -> nothing) where T\nHamiltonianKGrid(hami::TBHamiltonian{T}, k_grid, H_function_k::Function = x -> nothing) where T\n\nTakes a k grid, calculates Hk for each of them and diagonalizes. Only the eigenvectors and eigenvalues of Hk are stored, the H_function_k function is called on the intermediate Hk.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.Hk-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, StaticArraysCore.SVector{3}}","page":"Interpolation","title":"Wannier.Hk","text":"Hk(hamiltonian::TBHamiltonian, kpoint::Vec3)\nHk!(hk::AbstractMatrix, hamiltonian::TBHamiltonian, kpoint::Vec3)\n\nConstructs the reciprocal Hamiltonian at a given k-point.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.cut_hamiltonian-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Complex{T}, 3}, T}} where T<:Real","page":"Interpolation","title":"Wannier.cut_hamiltonian","text":"cut_hamiltonian(Rvectors::RVectorsMDRS{T}, Hᴿ::Array{Complex{T},3}, Rcut::T) where {T<:Real}\n\nCut real space Hamiltonian Hᴿ by the given cutoff radius.\n\nArguments\n\nRvectors: RVectorsMDRS\nHᴿ: n_wann * n_wann * n_rvecs, Hamiltonian in real space.\nRcut: cutoff radius in angstrom, the Hamiltonian H(R) corresponds to the R vectors with norm larger than Rcut will be set to 0.\n\nReturn\n\nH: n_wann * n_wann * n_rvecs, cutted Hamiltonian in real space.\n\nExample\n\nR, H, pos = read_w90_tb(\"mos2\")\n# Expand the H(R) to R̃, I assume the H(R) is read from w90 tb.dat file\nH1 = Wannier.mdrs_v1tov2(R, H)\nH2 = cut_hamiltonian(R, H1, 7.0)\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.get_Hk-Tuple{Vector, Vector}","page":"Interpolation","title":"Wannier.get_Hk","text":"get_Hk(E, U)\n\nConstruct k space Hamiltonian Hᵏ.\n\nH_bmk = U_bmk^dagger epsilon_n bmk U_bmk\n\nwhere epsilon_n bmk is a diagonal matrix with epsilon_n bmk as the diagonal elements.\n\nArguments\n\nE: n_bands * n_kpts, energy eigenvalue\nU: n_bands * n_wann * n_kpts, gauge matrices\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Any}","page":"Interpolation","title":"Wannier.interpolate","text":"interpolate(model::TBHamiltonian{T}, kpoints::Matrix{T}) where {T<:Real}\n\nInterpolate energy eigenvalues at kpoints.\n\nArguments\n\nmodel: TBHamiltonian\nkpoints: 3 * n_kpts, kpoints to be interpolated, in fractional coordinates,   can be nonuniform.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Brillouin.KPaths.KPathInterpolant}","page":"Interpolation","title":"Wannier.interpolate","text":"interpolate(model::TBHamiltonian, kpi::KPathInterpolant)\n\nInterpolate band structure along the given kpath.\n\nArguments\n\nmodel: TBHamiltonian\nkpi: KPathInterpolant\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.sort_hamiltonian_by_norm-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}","page":"Interpolation","title":"Wannier.sort_hamiltonian_by_norm","text":"sort_hamiltonian_by_norm(Rvectors::RVectorsMDRS{T}, Hᴿ::Array{Complex{T},3}) where {T<:Real}\n\nSort the Hamiltonian H(mR) by its norm in descending order.\n\nArguments\n\nRvectors: RVectorsMDRS\nHᴿ: n_wann * n_wann * n_rvecs, Hamiltonian in real space.\n\nReturn\n\nidx: the index to sort the Hamiltonian, i.e. Hᴿ[:, :, idx] is the sorted Hamiltonian.\nnormR: the norm of R vectors, normR[idx] is the sorted R vectors in descending order.\nnormH: the norm of H, normH[idx] is the sorted Hᴿ in descending order.\n\nExample\n\nR, H, pos = read_w90_tb(\"mos2\")\n# Expand the H(R) to R̃, I assume the H(R) is read from w90 tb.dat file\nH1 = Wannier.mdrs_v1tov2(R, H)\nidx, normR, normH = sort_hamiltonian_by_norm(R, H1)\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Fermi-surface","page":"Interpolation","title":"Fermi surface","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nThe fermi_surface function will use WS or MDRS interpolation based on the type of Rvectors. However, Wannier90 only use WS interpolation when plotting Fermi surface (even if the use_ws_distance is set as true in the win file). So the fermi_surface function will output different result than Wannier90 if using MDRS.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/fermisurf.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier.fermi_surface-Union{Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}, Tuple{KT}} where KT<:Union{Integer, AbstractVector{Int64}}","page":"Interpolation","title":"Wannier.fermi_surface","text":"fermi_surface(Rvectors, H; n_k)\n\nInterpolate Fermi surface.\n\nArguments\n\nRvectors: RVectors or RVectorsMDRS\nH: n_wann * n_wann * n_r̃vecs, Hamiltonian in R space\nn_k: integer or 3-vector, number of interpolated kpoints along three directions\n\nReturn\n\nkpoints: 3 * n_kx * n_ky * n_kz, interpolated kpoints in fractional coordinates\nE: n_wann * n_kx * n_ky * n_kz, interpolated eigenvalues\n\nnote: Note\nThe output n_kx = n_k + 1, since the bxsf format requires general grid, i.e., the last kpoint is the periodic image of the first one. This also restores the behavior of Wannier90.\n\nnote: Note\nFor MDRS interpolation, the H should be defined on the bmR vectors instead of the MDRSv2 tildebmR vectors; the expansion of H(bmR) to H(tildebmR) is done internally. This means that if you read the seedname_tb.dat file, then you can directly pass the H to this function.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Derivatives","page":"Interpolation","title":"Derivatives","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/derivative.jl\"]","category":"page"},{"location":"api/interpolation/#Wannier._get_D-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier._get_D","text":"_get_D(Rvectors, Hᴿ, kpoints; use_degen_pert=false, degen=1e-4)\n\nCompute the matrix D in YWVS Eq. 25 (or Eq. 32 if use_degen_pert = true).\n\nArguments\n\nRvectors: RVectorsMDRS\nHᴿ: n_wann * n_wann * n_r̃vecs, the Hamiltonian matrix\nkpoints: 3 * n_kpts, each column is a fractional kpoints coordinates\n\nKeyword arguments\n\nuse_degen_pert: use perturbation treatment for degenerate eigenvalues\ndegen: degeneracy threshold in eV\n\nReturn\n\nE: n_wann * n_kpts, energy eigenvalues\nU: n_wann * n_wann * n_kpts, the unitary transformation matrix\nHaᴴ: n_wann * n_wann * n_kpts * 3, the covariant part of derivative of   Hamiltonian in Hamiltonian gauge,   the barH_alpha^(H) in YWVS Eq. 26\nD: n_wann * n_wann * n_kpts * 3, the matrix D in YWVS Eq. 25 or Eq. 32\n\nwarning: Warning\nIf use_degen_pert = true, the degenerate subspace is rotated such that barH_x^(H) is diagonal, note only the x direction. I cannot diagonalize simultaneously all the three directions.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.effmass_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.effmass_fd","text":"effmass_fd(Rvectors, Hᴿ, kpoints; Δk=1e-3)\n\nCompute the inverse of effective mass using finite differences of 2nd order.\n\nApply twice PRB 93, 205147 (2016)  Eq. 80.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.get_d2H_dadb-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.get_d2H_dadb","text":"get_d2H_dadb(Rvectors, Hᴿ, kpoints)\n\nCompute the second derivative of the Hamiltonian H with respect to three Cartesian directions.\n\nYWVS Eq. 28.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.get_dH_da-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.get_dH_da","text":"get_dH_da(Rvectors, Hᴿ, kpoints)\n\nCompute the derivative of the Hamiltonian H with respect to three Cartesian\n\ndirections. YWVS Eq. 26.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.velocity-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.velocity","text":"velocity(Rvectors, Hᴿ, kpoints; use_degen_pert=false, degen=1e-4)\n\nCompute velocity along three Cartesian directions.\n\nYWVS Eq. 27.\n\nArguments\n\nRvectors: RVectorsMDRS\nHᴿ: n_wann * n_wann * n_r̃vecs, the Hamiltonian matrix\nkpoints: 3 * n_kpts, each column is a fractional kpoints coordinates\n\nKeyword arguments\n\nuse_degen_pert: use perturbation treatment for degenerate eigenvalues\ndegen: degeneracy threshold in eV\n\nReturn\n\nE: n_wann * n_kpts, energy eigenvalues\nv: n_wann * n_kpts * 3, velocity along three Cartesian directions,   in unit hbar * m / s\n\nwarning: Warning\nWannier90 by default set use_degen_pert = false. In 3D, and for N degenerate states, the velocity is a tensor of size N * N * 3, where 3 is for three Cartesian directions. Thus I cannot simultaneously diagonalize the tensor for all 3 directions. This means I can only use perturbation treatment for one of the directions, and only in that direction the velocity matrix is diagonal. So for degenerate states, the velocity is not well defined, and the results are meaningless, instead one should use the full velocity matrix which also include non-diagonal part, see get_dH_da.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/#Wannier.velocity_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Interpolation","title":"Wannier.velocity_fd","text":"velocity_fd(Rvectors, Hᴿ, kpoints; Δk=1e-3)\n\nCompute the velocity using finite differences of 2nd order.\n\nPRB 93, 205147 (2016)  Eq. 80.\n\n\n\n\n\n","category":"method"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"[WAN20]: Pizzi, G.; Vitale, V.; Arita, R.; Blügel, S.; Freimuth, F.; Géranton, G.; Gibertini, M.; Gresch, D.; Johnson, C.; Koretsune, T.; Ibañez-Azpiroz, J.; Lee, H.; Lihm, J.-M.; Marchand, D.; Marrazzo, A.; Mokrousov, Y.; Mustafa, J. I.; Nohara, Y.; Nomura, Y.; Paulatto, L.; Poncé, S.; Ponweiser, T.; Qiao, J.; Thöle, F.; Tsirkin, S. S.; Wierzbowska, M.; Marzari, N.; Vanderbilt, D.; Souza, I.; Mostofi, A. A. & Yates, J. R., Wannier90 as a community code: new features and applications, Journal of Physics: Condensed Matter, 2020, 32, 165902","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"[WBERRI]: Tsirkin, S. S., High performance Wannier interpolation of Berry curvature and related quantities with WannierBerri code, npj Computational Materials, 2021, 7","category":"page"},{"location":"WannierPlots/#WannierPlots.jl","page":"WannierPlots.jl","title":"WannierPlots.jl","text":"","category":"section"},{"location":"WannierPlots/","page":"WannierPlots.jl","title":"WannierPlots.jl","text":"A plotting extension for Wannier.jl.","category":"page"},{"location":"WannierPlots/#Features","page":"WannierPlots.jl","title":"Features","text":"","category":"section"},{"location":"WannierPlots/","page":"WannierPlots.jl","title":"WannierPlots.jl","text":"Band structure\nReal space WFs\nB vectors\nFermi surface","category":"page"},{"location":"theory/algorithm/#Algorithms","page":"Algorithm","title":"Algorithms","text":"","category":"section"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"Here are some detailed explanations of the algorithms used in this package, however, it might still be too concise, please refer to the references for full discussion.","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"Moreover, a good starting point for the WF theory could be[RMP].","category":"page"},{"location":"theory/algorithm/#Wannierization","page":"Algorithm","title":"Wannierization","text":"","category":"section"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"maximal localization for isolated bands, e.g. insulators\ndifferent from[MV97], optimize on unitary matrix manifolds (adaptation of [DLL19] to isolated bands)\ndisentanglement for entangled bands, e.g. metal\ndifferent from[SMV01], optimize on Stiefel manifolds[DLL19]\nparallel transport gauge[GLS19]\nyou can further improve the spread by optimization w.r.t. a single rotation matrix[QMP21]\nsplit valence and conduction WFs from a valence + conduction calculation[QMP21]\nas a by-product, automated initial projection for valence or conduction WFs\nfor the initial projection of valence + conduction calculation, you can start with either conventional spdf projection, SCDM[DL18], or an automated projection and disentanglement from pseudopotential orbitals[QPM21]\ndifferent from SCDM, the valence+conduction manifold is chosen by the valence+conduction calculation, instead of SCDM μ and σ. Moreover, works in reciprocal space thus more memory-efficient\nconstrain WF center for max localization or disentanglement[QMP21]\nsimilar to[WLPMM14], add an Lagrange multiplier term to spread functional, but optimize on matrix manifolds, and applying to both max localization and disentanglement (whereas in [WLPMM14] the center is constrained only during max localization)","category":"page"},{"location":"theory/algorithm/#Interpolation","page":"Algorithm","title":"Interpolation","text":"","category":"section"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"Two algorithms:","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"Wigner-Seitz (WS) interpolation\nMinimal-distance replica selection (MDRS) method","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"for band structure along a kpath or on a grid.","category":"page"},{"location":"theory/algorithm/#References","page":"Algorithm","title":"References","text":"","category":"section"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[MV97]: Marzari, N. & Vanderbilt, D., Maximally localized generalized Wannier functions for composite energy bands, Physical Review B, 1997, 56, 12847","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[RMP]: Marzari, N.; Mostofi, A. A.; Yates, J. R.; Souza, I. & Vanderbilt, D., Maximally localized Wannier functions: Theory and applications, Reviews of Modern Physics, 2012, 84, 1419","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[SMV01]: Souza, I.; Marzari, N. & Vanderbilt, D., Maximally localized Wannier functions for entangled energy bands, Physical Review B, 2001, 65, 035109","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[DLL19]: Damle, A.; Levitt, A. & Lin, L., Variational Formulation for Wannier Functions with Entangled Band Structure, Multiscale Modeling & Simulation, 2019, 17, 167","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[GLS19]: Gontier, D.; Levitt, A. & Siraj-dine, S., Numerical construction of Wannier functions through homotopy, Journal of Mathematical Physics, 2019, 60, 031901","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[QPM21]: Qiao, J.; Pizzi, G. & Marzari, N., Projectability disentanglement for accurate high-throughput Wannierization, xxx","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[QMP21]: Qiao, J.; Marzari, N. & Pizzi, G., Automated separate Wannierization for valence and conduction manifolds, xxx","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[DL18]: Damle, A. & Lin, L., Disentanglement via Entanglement: A Unified Method for Wannier Localization Multiscale Modeling & Simulation, 2018, 16, 1392","category":"page"},{"location":"theory/algorithm/","page":"Algorithm","title":"Algorithm","text":"[WLPMM14]: Wang, R.; Lazar, E. A.; Park, H.; Millis, A. J. & Marianetti, C. A., Selectively localized Wannier functions, Physical Review B, 2014, 90, 165125","category":"page"},{"location":"api/wannierize/#Wannierize","page":"Wannierize","title":"Wannierize","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"These are some Wannierization algorithms.","category":"page"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"CurrentModule = Wannier","category":"page"},{"location":"api/wannierize/#Contents","page":"Wannierize","title":"Contents","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Pages = [\"wannierize.md\"]\nDepth = 2","category":"page"},{"location":"api/wannierize/#Index","page":"Wannierize","title":"Index","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Pages = [\"wannierize.md\"]","category":"page"},{"location":"api/wannierize/#Disentanglement","page":"Wannierize","title":"Disentanglement","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/disentangle.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.GU_to_GX_GY-Union{Tuple{T}, Tuple{Array{T, 3}, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector}} where T","page":"Wannierize","title":"Wannier.GU_to_GX_GY","text":"GU_to_GX_GY(G, X, Y, frozen)\n\nCompute dΩ/dX and dΩ/dY from dΩ/dU.\n\nAcutally they are the conjugate gradients, e.g., fracd Omegad U^*.\n\nArguments\n\nG: n_bands * n_wann * n_kpts array for gradient dΩ/dU\nX: n_wann * n_wann * n_kpts array for X\nY: n_bands * n_wann * n_kpts array for Y\nfrozen: n_bands * n_kpts BitMatrix for frozen bands\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.U_to_X_Y-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, Vector{BitVector}}} where T<:Complex","page":"Wannierize","title":"Wannier.U_to_X_Y","text":"U_to_X_Y(U::Array{T,3}, frozen::BitMatrix) where {T<:Complex}\n\nConvert the U layout to the (X, Y) layout.\n\nSee also X_Y_to_U.\n\nArguments\n\nU: n_bands * n_wann * n_kpts\nfrozen: n_bands * n_kpts\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.XY_to_X_Y-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T<:Complex","page":"Wannierize","title":"Wannier.XY_to_X_Y","text":"XY_to_X_Y(XY::Matrix{T}, n_bands::Int, n_wann::Int)\n\nConvert the XY layout to the (X, Y) layout.\n\nSee also X_Y_to_U.\n\nArguments\n\nXY: n_bands * n_wann * n_kpts contiguous array\nn_bands: number of bands, to be used to reshape XY\nn_wann: number of wannier functions, to be used to reshape XY\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:AbstractMatrix{T}}}} where T<:Complex","page":"Wannierize","title":"Wannier.X_Y_to_U","text":"X_Y_to_U(X::Array{T,3}, Y::Array{T,3})\n\nConvert the (X, Y) layout to the U layout.\n\nThere are three formats: U, (X, Y), and XY stored contiguously in memory. For each kpoint,\n\nU: size(U) = (n_bands, n_wann), the format used in the rest of the code\n(X, Y): size(X) = (n_wann, n_wann), size(Y) = (n_bands, n_wann), intermediate format\nXY: this is the format used in the optimizer\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.X_Y_to_XY-Union{Tuple{T}, Tuple{AbstractVector{<:AbstractMatrix{T}}, AbstractVector{<:AbstractMatrix{T}}}} where T<:Complex","page":"Wannierize","title":"Wannier.X_Y_to_XY","text":"X_Y_to_XY(X::Array{T,3}, Y::Array{T,3}) where {T<:Complex}\n\nConvert the (X, Y) layout to the XY layout.\n\nSee also X_Y_to_U.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.check_frozen_bands-Tuple{AbstractVector{AbstractVector{Bool}}, Int64}","page":"Wannierize","title":"Wannier.check_frozen_bands","text":"check_frozen_bands(frozen_bands, n_wann)\n\nSanity check that the number of frozen bands at each kpoint <= n_wann.\n\nArguments\n\nfrozen_bands: the BitMatrix of frozen bands\nn_wann: the number of wannier functions\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T<:Real","page":"Wannierize","title":"Wannier.disentangle","text":"disentangle(model; random_gauge=false, f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)\n\nRun disentangle on the Model.\n\nArguments\n\nmodel: model\n\nKeyword arguments\n\nrandom_gauge: use random U matrices as initial guess\nf_tol: tolerance for spread convergence\ng_tol: tolerance for gradient convergence\nmax_iter: maximum number of iterations\nhistory_size: history size of LBFGS\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.get_fg!_disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T","page":"Wannierize","title":"Wannier.get_fg!_disentangle","text":"get_fg!_disentangle(model::Model)\n\nReturn a tuple of two functions (f, g!) for spread and gradient, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.get_frozen_bands","page":"Wannierize","title":"Wannier.get_frozen_bands","text":"get_frozen_bands(E, dis_froz_max, dis_froz_min)\n\nGenerate a BitMatrix of frozen bands by checking the two frozen windows.\n\nArguments\n\nE: the energy eigenvalues of the Hamiltonian\ndis_froz_max: the upper bound of the frozen window\ndis_froz_min: the lower bound of the frozen window\n\nnote: Note\nThe dis_froz_max and dis_froz_min work similarly as Wannier90.\n\n\n\n\n\n","category":"function"},{"location":"api/wannierize/#Wannier.get_frozen_proj-Union{Tuple{T}, Tuple{AbstractArray{AbstractVector{T}, 1}, AbstractArray{AbstractArray{Complex{T}, 2}, 1}, T}} where T<:Real","page":"Wannierize","title":"Wannier.get_frozen_proj","text":"get_frozen_proj(E, U, dis_proj_max)\n\nGet frozen bands according to band projectability.\n\nArguments\n\nE: the energy eigenvalues of the Hamiltonian\nU: the gauge rotation matrices\ndis_proj_max: the upper bound projectability.   Bands with projectability >= dis_proj_max are frozen.\n\nnote: Note\nThe band projectability for band n at kpoint bmk is calculated by p_n bmk = sum_m=1^m=n_wann  U_nm bmk ^2, and usually each element p_n bmk in 00 10. In such cases, the dis_proj_max is usually set to sth. like 0.9 to freeze high-projectability bands.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.orthonorm_freeze-Union{Tuple{T}, Tuple{Matrix{T}, BitVector}} where T<:Complex","page":"Wannierize","title":"Wannier.orthonorm_freeze","text":"orthonorm_freeze(U, frozen)\n\nNormalize and freeze a block of a matrix.\n\nConditions:\n\nBlock form:  U = vcat(Uf, Ur)\nSemiunitary\nU' * U = I\nUf' * Uf + Ur' * Ur = I\nFrozen:      Uf * Uf' = I\nAlso:        Uf * Ur' = 0\n\nStrategy:\n\northogonalize Uf\nproject Uf out of Ur\northogonalize the range of Ur\n\nArguments\n\nU: the matrix to be orthonormalized and frozen\nfrozen: the BitVector specifying which bands are frozen\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.set_frozen_degen!-Union{Tuple{T}, Tuple{AbstractMatrix{Bool}, Vector}, Tuple{AbstractMatrix{Bool}, Vector, T}} where T<:Real","page":"Wannierize","title":"Wannier.set_frozen_degen!","text":"set_frozen_degen!(frozen_bands, E, atol=1e-4)\n\nFreeze bands which are degenerate with the frozen_bands.\n\nIn some cases, we might want to freeze the whole set of degenerated eigen vectors.\n\nArguments\n\nfrozen_bands: the BitMatrix of frozen bands\nE: the energy eigenvalues of the Hamiltonian\natol: the tolerance of degeneracy\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.set_frozen_proj!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}} where T<:Real","page":"Wannierize","title":"Wannier.set_frozen_proj!","text":"set_frozen_proj!(model, dis_proj_max; degen=false, degen_atol=1e-4)\n\nSet frozen bands of the Model according to projectability.\n\nArguments\n\nmodel: the Model to be set\ndis_proj_max: the upper bound projectability.   Bands with projectability >= dis_proj_max are frozen.\n\nKeyword Arguments\n\ndegen: whether to freeze the whole set of degenerated eigen vectors\ndegen_atol: the tolerance of degeneracy\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.set_frozen_win!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}, Tuple{Wannier.Model{T}, T, T}} where T<:Real","page":"Wannierize","title":"Wannier.set_frozen_win!","text":"set_frozen_win!(model, dis_froz_max, dis_froz_min=-Inf; degen=false, degen_atol=1e-4)\n\nSet frozen bands of the Model according to two energy windows.\n\nArguments\n\nmodel: the Model to be set\ndis_froz_max: the upper bound of the frozen window\ndis_froz_min: the lower bound of the frozen window\n\nKeyword Arguments\n\ndegen: whether to freeze the whole set of degenerated eigen vectors\ndegen_atol: the tolerance of degeneracy\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.zero_froz_grad!-Tuple{AbstractMatrix, Vector}","page":"Wannierize","title":"Wannier.zero_froz_grad!","text":"zero_froz_grad!(G, frozen)\n\nSet gradient of frozen bands to 0.\n\nThis is used in test.\n\nArguments\n\nG: gradient of the spread, in XY layout\nfrozen: BitMatrix for frozen bands, n_bands * n_kpts\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Maximal-localization","page":"Wannierize","title":"Maximal localization","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/max_localize.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.get_fg!_maxloc-Tuple{Wannier.AbstractPenalty, Wannier.Model}","page":"Wannierize","title":"Wannier.get_fg!_maxloc","text":"get_fg!_maxloc(model::Model)\n\nReturn a tuple of two functions (f, g!) for spread and gradient, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.max_localize-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T<:Real","page":"Wannierize","title":"Wannier.max_localize","text":"max_localize(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)\n\nMaximally localize spread functional w.r.t. all kpoints on a unitary matrix manifold.\n\nArguments\n\nmodel: model\n\nKeyword arguments\n\nf_tol: tolerance for spread convergence\ng_tol: tolerance for gradient convergence\nmax_iter: maximum number of iterations\nhistory_size: history size of LBFGS\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Parallel-transport","page":"Wannierize","title":"Parallel transport","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\n    \"wannierize/parallel_transport/parallel_transport.jl\",\n    \"wannierize/parallel_transport/contraction.jl\",\n]","category":"page"},{"location":"api/wannierize/#Wannier.compute_error-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}} where T<:Real","page":"Wannierize","title":"Wannier.compute_error","text":"compute_error(model, U::Array{Complex{T},3})\n\nCompute the smoothness error of the gauge.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.parallel_transport-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T<:Real","page":"Wannierize","title":"Wannier.parallel_transport","text":"parallel_transport(model::Model{T}; use_U=false, log_interp=false)\n\nParallel transport the gauge from the first kpoint to all other kpoints.\n\nAssumptions:\n\nthe kpoints are contained in a N1 * N2 * N3 cartesian grid\nthe neighbor list must contain the six cartesian neighbors along x, y, z directions\n\nArguments\n\nmodel: model\n\nKeyword arguments\n\nuse_U: use the gauge U instead of random matrix\nlog_interp: use logarithmic interpolation method\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.choose_pole-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{Int64}, Matrix{T}}} where T<:Complex","page":"Wannierize","title":"Wannier.choose_pole","text":"Choose the column and the target point to contract the vector path of the columns of matrix_path\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.interpolate_vec-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{FT}}} where {T<:Union{Real, Complex}, FT<:Real}","page":"Wannierize","title":"Wannier.interpolate_vec","text":"Create an interpolation path between x and y, unit vectors by normalizing the linear interpolation of parameter t[i].\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.matrix_parallel_transport-Union{Tuple{T}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}, Bool}} where T<:Complex","page":"Wannierize","title":"Wannier.matrix_parallel_transport","text":"Compute the parallel transport of the matrix path (matrixpath) along the homotopy of the frame (framepath) that starts with the columns (columns[]) of matrix_path.\n\nsize(framepath) = (ncol, ncol, nk, nt) size(matrixpath) = (ncol, ncol, n_k)\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.matrix_transport-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, Vector{T}}} where T<:Real","page":"Wannierize","title":"Wannier.matrix_transport","text":"Contract the matrix_path to a single matrix point in the space of unitaries using parallel transport.\n\ni.e., contract Obs(k) matrices to constant vectors.\n\nsize(matrixpath) = nwann x nwann x nk t: vector of kpoint indexes along a different k direction\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.propagate!-Union{Tuple{R}, Tuple{T}, Tuple{Array{Matrix{T}, 1}, Vector{Int64}, Vector{R}, Array{Array{Matrix{T}, 1}, 1}, Array{StaticArraysCore.SVector{3, R}, 1}, Vector{Vector{Int64}}, Vector{Vector{StaticArraysCore.SVector{3, Int64}}}}} where {T<:Complex, R<:Real}","page":"Wannierize","title":"Wannier.propagate!","text":"Propagate U, defined at the first kpt, to the given list of kpts. Those must be neighbors, and only the first kpoint is assumed to have been rotated.\n\nArguments\n\nU: n_wann * n_wann * n_kpts gauge matrices\nkpts: list of kpoints along which to propagate the gauge matrices\ndk: the distance between two consecutive kpoints, in fractional coordinates\nM: overlap matrices\nkpoints: BVectors.kpoints, kpoint coordinates of the grid\nkpb_k: BVectors.kpb_k\nkpb_G: BVectors.kpb_G\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Optimal-rotation","page":"Wannierize","title":"Optimal rotation","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/opt_rotate.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.get_fg!_rotate-Tuple{Wannier.Model}","page":"Wannierize","title":"Wannier.get_fg!_rotate","text":"get_fg!_rotate(model::Model)\n\nReturn a tuple of two functions (f, g!) for spread and gradient, respectively.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.opt_rotate-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T<:Real","page":"Wannierize","title":"Wannier.opt_rotate","text":"opt_rotate(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)\n\nMaximally localize spread functional w.r.t. single unitary matrix W.\n\nArguments\n\nmodel: model\n\nKeyword arguments\n\nf_tol: tolerance for spread convergence\ng_tol: tolerance for gradient convergence\nmax_iter: maximum number of iterations\nhistory_size: history size of LBFGS\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.rotate_U-Union{Tuple{T}, Tuple{Vector, Matrix{T}}} where T<:Complex","page":"Wannierize","title":"Wannier.rotate_U","text":"rotate_U(U::Array{T,3}, W::Matrix{T}) where {T<:Complex}\n\nRotate the U matrices at each kpoint by the same W matrix.\n\nforall bmk, U_bmk W\n\nUseful once we have the optimal rotation matrix W, then update the initial U matrices by rotating them by W.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Splitting-the-Model","page":"Wannierize","title":"Splitting the Model","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/split.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.split_eig-Union{Tuple{R}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, AbstractVector{R}}} where {T<:Real, R<:AbstractVector{Int64}}","page":"Wannierize","title":"Wannier.split_eig","text":"split_eig(E, U, eig_groups)\n\nSplit eigenvalues into several groups.\n\nThe separation is done by\n\nconstruct Wannier gauge Hamiltonian,  H_bmk = U_bmk^dagger epsilon_n bmk U_bmk\ndiagonalize the Hamiltonian, the eigenvalues are sorted in ascending order,  and they are split into several groups according to the indices in eig_groups.\n\nArguments\n\nE: eigenvalues\nU: (semi-)Unitary matrices gauge transformation\neig_groups: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.\n\ntip: Tip\nFor example, if one wants to split valence+conduction into two groups, valence and conduction, respectively, then eig_groups should be [[1:n_val], [n_val+1:n_wann]]. Usually, the U are the maximally localized gauge matrices from a valence+conduction band Wannierization, this function split the gauge matrices U into two groups by diagonalizing the Hamiltonian, so we have two set of eigenvalues and gauge matrices for valence and conduction bands, respectively. However, the diagonalization introduce random gauges, so the returned two gauge matrices for valence and conduction are bad, we new to run a parallel transport to smoothen the gauges.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_eig-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, Int64}} where T<:Real","page":"Wannierize","title":"Wannier.split_eig","text":"split_eig(E, U, n_val)\n\nSplit eigenvalues into two groups.\n\nThe separation is done by\n\nconstruct Wannier gauge Hamiltonian,  H_bmk = U_bmk^dagger epsilon_n bmk U_bmk\ndiagonalize the Hamiltonian, the eigenvalues are sorted in ascending order,  so that the first n_val eigenvalues are the occupied states,  and the rest are the unoccupied states.\n\nArguments\n\nE: eigenvalues\nU: (semi-)Unitary matrices gauge transformation\nn_val: number of valence states\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_model-Tuple{Wannier.Model, Int64}","page":"Wannierize","title":"Wannier.split_model","text":"split_model(model, n_val)\n\nSplit the Model into two Models.\n\nArguments\n\nmodel: the Model to be split\nn_val: number of valence WFs\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_model-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R<:AbstractVector{Int64}","page":"Wannierize","title":"Wannier.split_model","text":"split_model(model, eig_groups)\n\nSplit the Model into several Models.\n\nArguments\n\nmodel: the Model to be split\neig_groups: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.\n\nnote: Note\nRotation eigenvectors are also returned, useful for further rotation of UNK files or other operators.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_unk-Union{Tuple{R}, Tuple{T}, Tuple{AbstractString, AbstractArray{T}, AbstractVector{R}}} where {T<:(AbstractArray{<:Complex, 3}), R<:AbstractString}","page":"Wannierize","title":"Wannier.split_unk","text":"split_unk(dir, Us, outdirs)\n\nRotate UNK files.\n\nThese are large matrices, so we read/write to disk for each kpoint sequentially, inside the function.\n\nArguments\n\ndir: directory where UNK files are stored\nUs: a Vector of Wannier (semi-)unitary gauge matrices for rotating band groups\noutdirs: a Vector of output directories for each band group\n\nKeyword arguments\n\nbinary: whether to write in Fortran binary format\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_unk-Union{Tuple{T}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString, AbstractString}} where T<:Complex","page":"Wannierize","title":"Wannier.split_unk","text":"split_unk(dir, Uv, Uc, outdir_val=\"val\", outdir_cond=\"cond\")\n\nRotate UNK files.\n\nThese are large matrices, so we read/write to disk for each kpoint sequentially, inside the function.\n\nArguments\n\ndir: directory where UNK files are stored\nUv: the Wannier (semi-)unitary matrix for rotating valence bands\nUc: the Wannier (semi-)unitary matrix for rotating conduction bands\noutdir_val: output directory for valence bands\noutdir_cond: output directory for conduction bands\n\nKeyword arguments\n\nbinary: whether to write in Fortran binary format\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_wannierize-Tuple{Wannier.Model, Int64}","page":"Wannierize","title":"Wannier.split_wannierize","text":"split_wannierize(model::Model, n_val::Int)\n\nSplit the model and run parallel transport to smoothen the gauge.\n\nArguments\n\nmodel: the Model to be split\nn_val: number of valence WFs\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.split_wannierize-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R<:AbstractVector{Int64}","page":"Wannierize","title":"Wannier.split_wannierize","text":"split_wannierize(model::Model, eig_groups)\n\nSplit the model and run parallel transport to smoothen the gauge.\n\nArguments\n\nmodel: the Model to be split\neig_groups: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.\n\nnote: Note\nReturn two separated Models and rotation matrices which are useful for UNK files or other operators.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Co-optimization-of-spin-polarized-WFs","page":"Wannierize","title":"Co-optimization of spin-polarized WFs","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/coopt.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.MagModel","page":"Wannierize","title":"Wannier.MagModel","text":"Model for spin polarized system with constraint.\n\nTraditionally, we run two independent Wannierizations for spin up and spin down. Here we add a constraint to maximally overlap the spin-up and spin-down WFs, so that they map one-by-one to each other.\n\n\n\n\n\n","category":"type"},{"location":"api/wannierize/#Wannier.disentangle-Union{Tuple{Wannier.MagModel{T}}, Tuple{T}, Tuple{Wannier.MagModel{T}, T}} where T<:Real","page":"Wannierize","title":"Wannier.disentangle","text":"disentangle(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)\n\nRun disentangle on a MagModel.\n\nArguments\n\nmodel: MagModel\nλ: Lagrange multiplier of the ↑↓ overlap term\n\nKeyword arguments\n\nf_tol: tolerance for spread convergence\ng_tol: tolerance for gradient convergence\nmax_iter: maximum number of iterations\nhistory_size: history size of LBFGS\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.get_fg!_disentangle","page":"Wannierize","title":"Wannier.get_fg!_disentangle","text":"get_fg!_disentangle(model::MagModel)\n\nReturn a tuple of two functions (f, g!) for spread and gradient, respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/wannierize/#Wannier.omega_updn-Tuple{AbstractMatrix}","page":"Wannierize","title":"Wannier.omega_updn","text":"omega_updn(M)\n\nCompute QPPM Eq. 8.\n\nArguments\n\nM: the overlap matrix between up and down WFs, size: (nwann, nwann),   should be the matrix returned from overlap_updn.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}","page":"Wannierize","title":"Wannier.overlap_updn","text":"overlap_updn(up::Model{T}, dn::Model{T}, M::Array{Complex{T},3}) where {T<:Real}\n\nCompute the overlap between up and down WFs.\n\nActually N - Ω↑↓, according to QPPM Eq. 8, where N = n_wann.\n\nArguments\n\nM: the MagModel.M matrices, size (nbands, nbands, n_kpts)\nUup: the up gauge matrices, size: (nbands, nwann, n_kpts)\nUdn: the down gauge matrices, size: (nbands, nwann, n_kpts)\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.overlap_updn_grad-Tuple{Vector, Vector, Vector}","page":"Wannierize","title":"Wannier.overlap_updn_grad","text":"overlap_updn_grad(model::MagModel, Uup, Udn)\n\nCompute gradients of overlap_updn.\n\nfracd Omegad U^uparrow and fracd Omegad U^downarrow.\n\nTODO: this is actually the gradient of Tr[overlap_updn]\n\nArguments\n\nM: the MagModel.M matrices, size (nbands, nbands, n_kpts)\nUup: the up gauge matrices, size: (nbands, nwann, n_kpts)\nUdn: the down gauge matrices, size: (nbands, nwann, n_kpts)\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.overlap_updn_grad-Tuple{Wannier.MagModel, Vararg{Any, 4}}","page":"Wannierize","title":"Wannier.overlap_updn_grad","text":"overlap_updn_grad(model::MagModel, Xup, Yup, Xdn, Ydn)\n\nCompute gradient of overlap_updn.\n\nfracd Omegad X^uparrow, fracd Omegad Y^uparrow, fracd Omegad X^downarrow, fracd Omegad Y^downarrow.\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Constraining-WF-centers","page":"Wannierize","title":"Constraining WF centers","text":"","category":"section"},{"location":"api/wannierize/#Disentanglement-2","page":"Wannierize","title":"Disentanglement","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/disentangle.jl\"]","category":"page"},{"location":"api/wannierize/#Maximal-localization-2","page":"Wannierize","title":"Maximal localization","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/max_localize.jl\"]","category":"page"},{"location":"api/wannierize/#Co-optimization-of-spin-polarized-WFs-2","page":"Wannierize","title":"Co-optimization of spin-polarized WFs","text":"","category":"section"},{"location":"api/wannierize/","page":"Wannierize","title":"Wannierize","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/coopt.jl\"]","category":"page"},{"location":"api/wannierize/#Wannier.disentangle_center-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T<:Real","page":"Wannierize","title":"Wannier.disentangle_center","text":"disentangle(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)\n\nRun disentangle on a MagModel, with center constraints.\n\nArguments\n\nmodel: MagModel\nr₀: 3 * n_wann, WF centers in cartesian coordinates\nλc: Lagrange multiplier of the center term\nλs: Lagrange multiplier of the spin-up and spin-down overlap term\n\nKeyword arguments\n\nf_tol: tolerance for spread convergence\ng_tol: tolerance for gradient convergence\nmax_iter: maximum number of iterations\nhistory_size: history size of LBFGS\n\n\n\n\n\n","category":"method"},{"location":"api/wannierize/#Wannier.get_fg!_center_disentangle-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T<:Real","page":"Wannierize","title":"Wannier.get_fg!_center_disentangle","text":"get_fg!_center_disentangle(model::MagModel, r₀, λc, λs)\n\nReturn a tuple of two functions (f, g!) for spread and gradient, respectively.\n\n\n\n\n\n","category":"method"},{"location":"theory/initial_projection/#Initial-projection-for-plane-wave-DFT-codes","page":"Initial projection","title":"Initial projection for plane-wave DFT codes","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Here I write down the formulae for initial projection in plane-wave DFT codes, e.g., as implemented in DFTK.jl or Quantum ESPRESSO.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"In essence, the initial projection A_m n mathbfk is the inner product between the Bloch wavefunction psi_m mathbfk(mathbfr) and some initial guess phi_n mathbfk(mathbfr),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"A_m n mathbfk = langle psi_m mathbfk  phi_n mathbfk rangle","category":"page"},{"location":"theory/initial_projection/#Bloch-wavefunction","page":"Initial projection","title":"Bloch wavefunction","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The Bloch wavefunction is expanded in plane waves,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"psi_m mathbfk(mathbfr) = frac1sqrtV sum_mathbfG\n  c_m mathbfk(mathbfG) e^i (mathbfk + mathbfG) mathbfr","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where V is the volume of the unit cell, the sum is over the plane-wave expansions (integer multiples of reciprocal lattice vectors) mathbfG, which are limited by the energy cutoff E_mathrmcut,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"frachbar^22 m_e  mathbfk + mathbfG ^2 leq E_mathrmcut","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where m_e is the electron mass. The coefficients c_m mathbfk(mathbfG) are obtained from DFT calculations.","category":"page"},{"location":"theory/initial_projection/#Localized-atomic-orbitals","page":"Initial projection","title":"Localized atomic orbitals","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Usually we choose some atomic orbitals as the initial projections, given by a product of radial function R(r) times spherical harmonics Y_l m(theta phi),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"f(mathbfr) = R(r) Y_l m(theta phi)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where mathbfr is the vector and r = mathbfr is its norm; theta and phi are the polar and azimuthal angles or mathbfr, respectively; l and m are the angular momentum, and the Y_l m(theta phi) are the real spherical harmonics (as a comparison, we use the notation Y_l^m(theta phi) for the complex spherical harmonics, see [SphHarm]).","category":"page"},{"location":"theory/initial_projection/#Bloch-sum","page":"Initial projection","title":"Bloch sum","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The atomic orbitals do not have the periodicity of the lattice, so we need to sum over the lattice to obtain the Bloch sum of the localized atomic orbitals,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"phi_mathbfk(mathbfr) = frac1N sqrtV sum_mathbfR\n  e^i mathbfk mathbfR f(mathbfr - mathbfR)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where N is the number of unit cells in the supercell (determined by the k-point mesh), V is the volume of unit cell, and mathbfR labels the unit cell inside the supercell.","category":"page"},{"location":"theory/initial_projection/#Fourier-transform-to-plane-waves","page":"Initial projection","title":"Fourier transform to plane waves","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"To obtain the inner product between the Bloch wavefunction and the Bloch sum of the localized atomic orbitals, we need to Fourier transform the Bloch sum to plane waves, i.e., compute inner product in mathbfG-vector space.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"For a wavefunction having a form of radial functions times spherical harmonics, i.e., f(mathbfr) = R(r) Y_l m(theta phi), its Fourier transform hatf( mathbfq ) can be computed by","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nhatf(mathbfq)\n= int_mathbb R^3 e^-i mathbfq cdot mathbfr f(mathbfr) dmathbfr \n= 4 pi Y_l m(mathbfqq) (-i)^l\n  int_mathbb R^+ r^2 R(r)  j_l(q r) dr\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where q = mathbfq, and j_l(x) is the spherical Bessel function of the first kind [SphBess].","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Here we have used the plane wave expansion in spherical harmonics [PwExpand] (valid for both complex and real spherical harmonics),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\n  e^i mathbfq cdot mathbfr\n= 4 pi sum_l=0^infty sum_m=-l^l\n    i^l j_l(q r) Y_l^m(mathbfqq) Y_l^m*(mathbfrr) \n= 4 pi sum_l=0^infty sum_m=-l^l\n    i^l j_l(q r) Y_l m(mathbfqq) Y_l m(mathbfrr)\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"For e^-i mathbfq cdot mathbfr, due to the parity of spherical harmonics, Y_l^m(- mathbfr ) = (-1)^l Y_l^m( mathbfr ) (also hold true for real spherical harmonics Y_l m(- mathbfr ) = (-1)^l Y_l m( mathbfr )), the i^l in the expression of e^i mathbfq cdot mathbfr becomes (-i)^l in that of e^-i mathbfq cdot mathbfr.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"note: Note\nTo really convince you that there should be a minus sign, I created a notebook which includes some numerical tests, click here to download.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Now, using the orthogonality of spherical harmonics,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"int_theta = 0^pi int_phi=0^2pi\nY_l^m Y_l^prime^m^prime * dOmega\n= delta_l l^prime delta_m m^prime","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"we reach the expression of hatf(mathbfq). Note in the above equation dOmega = sin theta dtheta dphi is the solid angle element, and dV = r^2 dr dOmega is the volume element.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Note that alternatively, we can use Hankel transform to reach the same result, see Appendix: Hankel transform.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Thus, f(mathbfr) can be expanded as","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"f(mathbfr) = frac1(2pi)^3 int dmathbfq hatf(mathbfq)\nexp(i mathbfq cdot mathbfr)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Then the Fourier transform of the Bloch sum is","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nphi_mathbfk(mathbfq)\n= mathcalF_mathbfr rightarrow mathbfq\n   phi_mathbfk (mathbfr - mathbftau)  \n= mathcalF  frac1N sqrtV\n  sum_mathbfR exp(i mathbfk mathbfR)\n  f(mathbfr - mathbftau - mathbfR)  \n= frac1N sqrtV sum_mathbfR\n  exp(i mathbfk mathbfR)\n  mathcalF  f(mathbfr - mathbftau - mathbfR)  \n= frac1N sqrtV sum_mathbfR\n  exp(i mathbfk mathbfR)\n  hatf(mathbfq) exp(-i mathbfq (mathbftau + mathbfR) )\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where mathbftau = (tau_x tau_y tau_z) is the center of the orbital.","category":"page"},{"location":"theory/initial_projection/#Inner-product","page":"Initial projection","title":"Inner product","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Now we can compute the initial projection A_m n mathbfk. Note that the Bloch state psi_n mathbfk(mathbfr) are actually a sum over e^i (mathbfk + mathbfG) mathbfr, so we need to set the mathbfq in phi_mathbfk(mathbfq) to mathbfk + mathbfG so that the inner product is on the same basis functions.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"phi_mathbfk(mathbfk + G)\n= frac1sqrtV exp(-i (mathbfk + G) mathbftau )\n  hatf(mathbfk + G)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Since the localized orbitals f(mathbfr) might not be normalized, often we apply Löwdin orthonormalization on the mathbfq-space wavefunction phi_mathbfk(mathbfq) at each mathbfk-point.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Finally, the initial projection is","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nA_m n mathbfk\n= psi_m mathbfk^* phi_n mathbfk \n= sum_mathbfG c_m mathbfk(mathbfG)^* phi_n mathbfk(mathbfk + G)\nendaligned","category":"page"},{"location":"theory/initial_projection/#Appendix:-Hankel-transform","page":"Initial projection","title":"Appendix: Hankel transform","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The Fourier transform of f(mathbfr) can also be obtained using Hankel transform [Hankel],","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nF_nu (k) = int _0^infty  f(r) J_nu (kr) r  mathrmd r \nf(r) = int _0^infty  F_nu (k) J_nu (kr) k  mathrmd k\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where nu in mathbbC, J_nu (x) is the Bessel function; for integer n, the spherical Bessel function j_n(x) is related to the Bessel function by","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"j_n(x) = sqrt frac pi 2x J_n + frac12(x)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"By using the relation between Fourier transform and Hankel transform [Hankel], we can write the Fourier transform as","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"hatf(mathbfq) = (2pi)^frac32 (-i)^l R_l(q) Y_l m(mathbfqq)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nR_l(q)\n= frac1sqrtq int_mathbb R^+ sqrtr R(r) J_l+frac12(q r) r dr \n= sqrtfrac2pi int_mathbb R^+ r^2 R(r)  j_l(q r) dr\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"restoring the same equation.","category":"page"},{"location":"theory/initial_projection/#References","page":"Initial projection","title":"References","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[SphHarm]: https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[SphBess]: https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[PwExpand]: https://en.wikipedia.org/wiki/Plane-wave_expansion","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[Hankel]: https://en.wikipedia.org/wiki/Hankel_transform","category":"page"},{"location":"api/util/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"These are some simple convenience functions to smoothen developer experience.","category":"page"},{"location":"api/util/","page":"Utility","title":"Utility","text":"CurrentModule = Wannier","category":"page"},{"location":"api/util/#Contents","page":"Utility","title":"Contents","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Pages = [\"util.md\"]\nDepth = 2","category":"page"},{"location":"api/util/#Index","page":"Utility","title":"Index","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Pages = [\"util.md\"]","category":"page"},{"location":"api/util/#Structure","page":"Utility","title":"Structure","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/structure.jl\"]","category":"page"},{"location":"api/util/#Wannier.get_atom_number-Tuple{AbstractString}","page":"Utility","title":"Wannier.get_atom_number","text":"get_atom_number(symbol::AbstractString)\n\nGet atom number from symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_atom_number-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T<:AbstractString","page":"Utility","title":"Wannier.get_atom_number","text":"get_atom_number(symbol::Vector{String})\n\nGet atom number from symbol.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utility","title":"Wannier.get_lattice","text":"get_lattice(recip_lattice::Mat3)\n\nReturn lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_recip_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}","page":"Utility","title":"Wannier.get_recip_lattice","text":"get_recip_lattice(lattice::Mat3)\n\nReturn reciprocal lattice.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Matrices","page":"Utility","title":"Matrices","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/linalg.jl\"]","category":"page"},{"location":"api/util/#Wannier.compute_imre_ratio-Tuple{AbstractArray}","page":"Utility","title":"Wannier.compute_imre_ratio","text":"compute_imre_ratio(W::AbstractArray)\n\nCompute Im/Re ratio of the wavefunction.\n\nnote: Note\nThis follows the same logic as Wannier90 when computing the ratio for real space WFs.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.eyes_U-Tuple{Type, Int64, Int64, Int64}","page":"Utility","title":"Wannier.eyes_U","text":"eyes_U(T::Type, n_bands::Int, n_wann::Int, n_kpts::Int)\n\nReturn a series of indentity matrices of type T and size n_bands * n_wann * n_kpts.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.eyes_U-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T","page":"Utility","title":"Wannier.eyes_U","text":"eyes_U(T::Type, n_wann::Int, n_kpts::Int)\n\nReturn a series of indentity matrices of type T and size n_wann * n_wann * n_kpts.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.findvector-Tuple{Function, AbstractVector, AbstractMatrix}","page":"Utility","title":"Wannier.findvector","text":"findvector(predicate::Function, v::AbstractVector, M::AbstractMatrix)\n\nFind index of vector in the columns of a matrix.\n\nArguments\n\npredicate: comparison function\nv: the vector to be found\nM: the matrix to be searched, its column will be compared to v by predicate function\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.fix_global_phase-Tuple{AbstractArray}","page":"Utility","title":"Wannier.fix_global_phase","text":"fix_global_phase(W::AbstractArray)\n\nReturn a factor to fix the global phase of wavefunction, such that the point having max norm is real.\n\nArguments\n\nW: usually size(W) = nx * ny * nz\n\nnote: Note\nThis follows the same logic as Wannier90 when computing the ratio for real space WFs.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_projectability-Tuple{AbstractVector}","page":"Utility","title":"Wannier.get_projectability","text":"get_projectability(U)\n\nReturn projectability of each kpoint.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.imaglog-Tuple{T} where T<:Complex","page":"Utility","title":"Wannier.imaglog","text":"imaglog(z)\n\nReturn the imaginary part of the logarithm of z.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.isunitary-Tuple{AbstractVector{AbstractMatrix}}","page":"Utility","title":"Wannier.isunitary","text":"isunitary(U; atol=1e-10)\n\nCheck if matrix is unitary or semi-unitary for all the kpoints?\n\nI.e. does it have orthogonal columns?\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.orthonorm_lowdin-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T<:Union{Real, Complex}","page":"Utility","title":"Wannier.orthonorm_lowdin","text":"orthonorm_lowdin(U::Array{T,3})\n\nLowdin orthonormalize a series of matrices U.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.orthonorm_lowdin-Union{Tuple{Matrix{T}}, Tuple{T}} where T<:Union{Real, Complex}","page":"Utility","title":"Wannier.orthonorm_lowdin","text":"orthonorm_lowdin(U::Matrix{T})\n\nLowdin orthonormalize a matrix U to be (semi-)unitary.\n\nIf U is a matrix with orthogonal columns and V a non-singular matrix, then Lowdin-orthogonalizing U*V is equivalent to computing U*orthonorm_lowdin(V).\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rand_unitary-Tuple{Type, Int64, Int64}","page":"Utility","title":"Wannier.rand_unitary","text":"rand_unitary(T::Type, m::Int, n::Int)\n\nGenerate a random (semi-)unitary matrix using Lowdin orthonormalization.\n\nArguments\n\nT: the type of the matrix, e.g., ComplexF64, Float64\nm: number of rows\nn: number of columns\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rand_unitary-Tuple{Type, Int64}","page":"Utility","title":"Wannier.rand_unitary","text":"rand_unitary(T::Type, m::Int)\n\nGenerate a random unitary matrix using Lowdin orthonormalization.\n\nArguments\n\nT: the type of the matrix\nm: number of rows (= number of columns)\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rand_unitary-Tuple{Type, Integer, Integer, Integer}","page":"Utility","title":"Wannier.rand_unitary","text":"rand_unitary(T::Type, m, n, k)\n\nGenerate a series of random (semi-)unitary matrix using Lowdin orthonormalization.\n\nThe returned M[:, :, ik] is (semi-)unitary for all ik = 1:k.\n\nArguments\n\nT: the type of the matrix\nm: number of rows\nn: number of columns\nk: number of matrices\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rotate_M-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"Utility","title":"Wannier.rotate_M","text":"rotate_M(M, kpb_k, U)\n\nRotate mmn matrices according to gauge U.\n\ni.e., for each kpoint bmk, U_bmk+bmb^dagger M_bmkbmb U_bmk.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rotate_U-Tuple{AbstractVector, AbstractVector}","page":"Utility","title":"Wannier.rotate_U","text":"rotate_U(U, V)\n\nRotate the gauge matrices U by V.\n\nFor each kpoint bmk, return U_bmk V_bmk.\n\nArguments\n\nU: a series of gauge matrices, usually size(U) = n_bands * n_wann * n_kpts\nV: a series of gauge matrices, usually size(V) = n_wann * n_wann * n_kpts\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.rotate_gauge-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}} where T<:Number","page":"Utility","title":"Wannier.rotate_gauge","text":"rotate_gauge(O::Array{T,3}, U::Array{T,3})\n\nRotate the gauge of the operator O.\n\nI.e., U^dagger O U.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Kpoint","page":"Utility","title":"Kpoint","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/kpoint.jl\"]","category":"page"},{"location":"api/util/#Wannier.get_kgrid-Union{Tuple{Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{T}} where T<:Real","page":"Utility","title":"Wannier.get_kgrid","text":"get_kgrid(kpoints)\n\nGuess kgrid from list of kpoint coordinates.\n\nInput kpoints has size 3 * n_kpts, where n_kpts = nkx * nky *  nkz, output [nkx, nky, nkz].\n\nArguments\n\nkpoints: 3 * n_kpts, fractional coordiantes\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_kpoint_mappings-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}}} where T<:Real","page":"Utility","title":"Wannier.get_kpoint_mappings","text":"get_kpoint_mappings(kpoints, kgrid)\n\nGet the mappings between kpoint indexes and kpoint coordiantes.\n\nReturn a tuple of (k_xyz, xyz_k):\n\nk_xyz[ik] maps kpoint kpoints[:, ik] to kpoint coordinates [ikx, iky, ikz]\nxyz_k[ikx, iky, ikz] maps kpoint coordinates [ikx, iky, ikz] to kpoint index ik\nthe kpoint fractional coordinates is [(ikx - 1)/nkx, (iky - 1)/nky, (ikz - 1)/nkz]\n\nArguments\n\nkpoints: 3 * n_kpts, in fractional coordinates\nkgrid: 3, number of kpoints along each reciprocal lattice vector\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_kpoints-Tuple{AbstractVector{<:Integer}}","page":"Utility","title":"Wannier.get_kpoints","text":"get_kpoints(kgrid; fractional=true, endpoint=false)\n\nGenerate list of kpoint coordinates from kpoint grid.\n\nArguments\n\nkgrid: vector of 3 integers specifying a nkx * nky * nkz mesh\n\nKeyword Arguments\n\nfractional: return an explicit list of kpoints in fractional coordinates, else integers\nendpoint: include the endpoint of the grid, only for fractional case. E.g., if true, 1.0 is included\n\nnote: Note\nIf the default keyword arguments are used, this function works just like kmesh.pl of Wannier90.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.make_supercell","page":"Utility","title":"Wannier.make_supercell","text":"make_supercell(kpoints, replica=5)\n\nMake a supercell of kpoints by translating it along 3 directions.\n\nArguments\n\nreplica: integer, number of repetitions along ±x, ±y, ±z directions\n\n\n\n\n\n","category":"function"},{"location":"api/util/#Wannier.make_supercell-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{<:AbstractRange}}} where T","page":"Utility","title":"Wannier.make_supercell","text":"make_supercell(kpoints, replica)\n\nMake a supercell of kpoints by translating it along 3 directions.\n\nOn output there are (2*replica + 1)^3 cells, in fractional coordinates.\n\nArguments\n\nkpoints: 3 * n_kpts, in fractional coordinates\nreplica: 3, number of repetitions along ±x, ±y, ±z directions\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.sort_kpoints-Tuple{Vector}","page":"Utility","title":"Wannier.sort_kpoints","text":"sort_kpoints(kpoints)\n\nSort kpoints such that z increases the fastest, then y, then x.\n\nArguments\n\nkpoints: 3 * n_kpts\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Kpath","page":"Utility","title":"Kpath","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"The KPath and KPathInterpolant are defined in Brillouin.jl, they are used to store the high-symmetry kpoints and their labels.","category":"page"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/kpath.jl\"]","category":"page"},{"location":"api/util/#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T<:Real, R<:AbstractString}","page":"Utility","title":"Wannier.get_kpath","text":"get_kpath(lattice, atom_positions, atom_labels)\n\nGet a Brillouin.KPath for arbitrary cell (can be non-standard).\n\nInternally use Brillouin.jl.\n\nArguments\n\nlattice: 3 * 3, each column is a lattice vector\natom_positions: 3 * n_atoms, fractional coordinates\natom_labels: n_atoms of string, atomic labels\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T<:Real, R<:Integer}","page":"Utility","title":"Wannier.get_kpath","text":"get_kpath(lattice, atom_positions, atom_numbers)\n\nGet a Brillouin.KPath for arbitrary cell (can be non-standard).\n\nInternally use Brillouin.jl.\n\nArguments\n\nlattice: 3 * 3, each column is a lattice vector\natom_positions: 3 * n_atoms, fractional coordinates\natom_numbers: n_atoms of integer, atomic numbers\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_kpath-Union{Tuple{SV}, Tuple{AbstractMatrix, Array{Vector{SV}, 1}}} where SV<:(Pair{Symbol, StaticArraysCore.SVector{3, T}} where T)","page":"Utility","title":"Wannier.get_kpath","text":"get_kpath(lattice, kpoint_path)\n\nConstruct a Brillouin.KPath from the returned kpoint_path of WannierIO.read_win.\n\nArguments\n\nlattice: each column is a lattice vector\nkpoint_path: the returned kpoint_path of WannierIO.read_win, e.g.,\n\nkpoint_path = [\n    [:Γ => [0.0, 0.0, 0.0], :M => [0.5, 0.5, 0.0]],\n    [:M => [0.5, 0.5, 0.0], :R => [0.5, 0.5, 0.5]],\n]\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_kpoints-Tuple{Brillouin.KPaths.KPathInterpolant}","page":"Utility","title":"Wannier.get_kpoints","text":"get_kpoints(kpi::KPathInterpolant)\n\nGet the kpoints coordinates from a KPathInterpolant.\n\nArguments\n\nkpi: KPathInterpolant\n\nReturn\n\nkpoints: 3 * n_kpts, kpath points coordinates in fractional coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.get_x-Tuple{Brillouin.KPaths.KPathInterpolant}","page":"Utility","title":"Wannier.get_x","text":"get_x(kpi::KPathInterpolant)\n\nGet x axis value for plotting, in cartesian length.\n\nArguments\n\nkpi: a KPathInterpolant\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.interpolate_w90-Tuple{Brillouin.KPaths.KPath, Int64}","page":"Utility","title":"Wannier.interpolate_w90","text":"interpolate_w90(kpath::KPath, n_points::Int)\n\nGet kpoint coordinates from a Brillouin.KPath.\n\nUse the kpath density of first segment to generate the following kpaths, also need to take care of high symmetry kpoints at the start and end of each segment.\n\nReturn a KPathInterpolant.\n\nArguments\n\nkpath: a Brillouin.KPath\nn_points: number of kpoints in the first segment, remaining segments   have the same density as the 1st segment.\n\nnote: Note\nThis reproduce exactly the Wannier90 input parameter kpoint_path block and the input parameter bands_num_points.\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Centers","page":"Utility","title":"Centers","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/center.jl\"]","category":"page"},{"location":"api/util/#Wannier.find_nearest_atom-Union{Tuple{T}, Tuple{Vector, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T<:Real","page":"Utility","title":"Wannier.find_nearest_atom","text":"find_nearest_atom(centers, lattice, atom_positions)\n\nFind nearest atom for each WF center.\n\nArguments\n\ncenters: 3 * n_wann, in fractional coordinates\nlattice: 3 * 3, each column is a lattice vector\natom_positions: 3 * n_atoms, each column is fractional coordinate ∈ [0, 1)\n\nExample\n\nwout = read_wout(\"silicon.wout\")\npoints = inv(wout.lattice) * wout.centers  # to fractional\nfind_nearest_atom(points, wout.lattice, wout.atom_positions)\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.find_nearests-Union{Tuple{R}, Tuple{T}, Tuple{AbstractVector{T}, R, AbstractMatrix{T}, Vector}} where {T<:Real, R<:Integer}","page":"Utility","title":"Wannier.find_nearests","text":"find_nearests(point, search_neighbors, lattice, atom_positions)\n\nFind nearest-atom (including its periodic images) to a point.\n\nUsually point is the WF center, so the function returns nearest atom to WF center.\n\nArguments\n\npoint: vector of 3 floats, fractional coordinates w.r.t. lattice\nsearch_neighbors: number of nearest-neighbors to be returned\nlattice: 3 * 3, each column is a lattice vector\natom_positions: 3 * n_atoms, each column is fractional coordinate ∈ [0, 1)\n\n\n\n\n\n","category":"method"},{"location":"api/util/#Wannier.wrap_centers-Tuple{Vector, AbstractMatrix}","page":"Utility","title":"Wannier.wrap_centers","text":"wrap_centers(centers, lattice)\n\nWrap around centers back to unit cell at origin.\n\nArguments\n\ncenters:: 3 * n_wann, in Cartesian coordiantes\nlattice:: 3 * 3, each column is a lattice vector\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Input/Output","page":"Input/Output","title":"Input/Output","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"CurrentModule = Wannier","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"The reading and writing functions are implemented in the WannierIO.jl package. However, here are also some convenience functions which wrap the corresponding functions in WannierIO.jl, to utilize the structs defined in Wannier90.jl, e.g. BVectors, RGrid, etc.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nIn most cases, the units of the function arguments and returns are in angstrom unit for lattice, and fractional w.r.t lattice for atomic positions, etc.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nThe following abbreviations are used throughout the code and documentation:n_bands for number of bands\nn_wann for number of WFs\nn_kpts for number of kpoints\nn_bvecs for number of b-vectors\nn_atoms for number of atoms\nU for amn or the gauge matrices\nM for mmn matrices\nE for eig matrices\nS for spn matrices","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"note: Note\nIn most cases, for arrays we adopt the convention that n_bands is the first index, n_wann is the second index, and n_kpts is the third index. For example, U for the gauge matrices is a 3D array of size (n_bands, n_wann, n_kpts).","category":"page"},{"location":"api/io/#Contents","page":"Input/Output","title":"Contents","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Pages = [\"io.md\"]\nDepth = 2","category":"page"},{"location":"api/io/#Index","page":"Input/Output","title":"Index","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Pages = [\"io.md\"]","category":"page"},{"location":"api/io/#Wannier90-files","page":"Input/Output","title":"Wannier90 files","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/w90/amn.jl\",\n    \"io/w90/band.jl\",\n    \"io/w90/chk.jl\",\n    \"io/w90/model.jl\",\n    \"io/w90/nnkp.jl\",\n    \"io/w90/tb.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.read_orthonorm_amn-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_orthonorm_amn","text":"read_orthonorm_amn(filename::AbstractString)\n\nRead and orthonormalize the amn file.\n\nWrapper function to read amn and Lowdin orthonormalize it. The U matrix needs to be unitary or semi-unitary, so in most cases this function should be used instead of WannierIO.read_amn.\n\nSee also WannierIO.read_amn.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Brillouin.KPaths.KPathInterpolant-Union{Tuple{R}, Tuple{T}, Tuple{AbstractVector, AbstractVector{T}, AbstractVector{R}, AbstractMatrix}} where {T<:Integer, R<:AbstractString}","page":"Input/Output","title":"Brillouin.KPaths.KPathInterpolant","text":"KPathInterpolant(kpoints, symm_point_indices, symm_point_labels, recip_lattice)\n\nGenerate a KPathInterpolant from kpoints in prefix_band.dat/kpt/labelinfo.\n\nArguments\n\nkpoints: fractional coordinate, each column is a kpoint.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.get_symm_point_indices_labels-Tuple{Brillouin.KPaths.KPathInterpolant}","page":"Input/Output","title":"Wannier.get_symm_point_indices_labels","text":"get_symm_point_indices_labels(kpi::KPathInterpolant)\n\nReturn the symmetry indexes and labels.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_w90_band-Tuple{AbstractString, AbstractMatrix}","page":"Input/Output","title":"Wannier.read_w90_band","text":"read_w90_band(prefix::AbstractString, recip_lattice::AbstractMatrix)\n\nArguments\n\nrecip_lattice: each column is a reciprocal lattice vector in Cartesian coordinates.   If given, return a tuple of (KPathInterpolant, E).   This is a more user-friendly version of   read_w90_band(prefix::AbstractString).\n\nSee also read_w90_band(prefix::AbstractString).\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_w90_band-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant, Vector}","page":"Input/Output","title":"Wannier.write_w90_band","text":"write_w90_band(prefix, kpi::KPathInterpolant, eigenvalues)\n\nWrite prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat.\n\nThis is a more user-friendly version.\n\nSee also write_w90_band(prefix, kpoints, E, x, symm_point_indices, symm_point_labels).\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_w90_kpt_label-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant}","page":"Input/Output","title":"Wannier.write_w90_kpt_label","text":"write_w90_kpt_label(prefix, kpi::KPathInterpolant)\n\nWrite prefix_band.kpt and prefix_band.labelinfo.dat.\n\nThis allows generating the high-symmetry kpoints and labels from crystal structure, and use the generated kpoints in pw.x bands calculation or in the win input file for Wannier90.\n\nExample\n\nwin = read_win(\"si2.win\")\nkp = get_kpath(win.unit_cell_cart, win.atoms_frac, win.atom_labels)\nkpi = Wannier.interpolate_w90(kp, 100)\nWannier.write_w90_kpt_label(\"si2\", kpi)\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.Model-Tuple{WannierIO.Chk}","page":"Input/Output","title":"Wannier.Model","text":"Model(chk::Chk)\n\nConstruct a model from a WannierIO.Chk struct.\n\nArguments\n\nchk: a WannierIO.Chk struct\n\nKeyword Arguments\n\nE: a n_wann * n_kpts array for the eigenvalues of the Hamiltonian.   If not provided, it will be set to zero.\nU: a n_wann * n_wann * n_kpts array for the gauge transformation.\n\nwarning: Warning\nThe Chk struct does not contain eigenvalues, thus if E is not provided, it will be set to zero.Moreover, the M matrix in Chk is already rotated by the gauge transformation, thus by default, the U matrix is set to identity. Note that although maximal localization, or disentanglement (after frozen states are chosen), do not require eigenvalues (so the user can still Wannierize the Model), it is required when writing the Model to a .chk file, in write_chk.Additionally, be careful that the M matrix is rotated, and this rotation needs to make sure that the rotated Hamiltonian is diagonal so that E stores the diagonal eigenvalues of the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_chk-Tuple{AbstractString, Wannier.Model, Vector}","page":"Input/Output","title":"Wannier.write_chk","text":"write_chk(filename, model, U; exclude_bands=nothing, binary=false)\n\nWrite the model to a Wannier90 .chk file, using the gauge U.\n\nArguments\n\nfilename: filename of the .chk file\nmodel: a Model struct\nU: n_bands * n_wann * n_kpts array for the gauge transformation\n\nKeyword Arguments\n\nexclude_bands: a list of band indices to exclude.   This is irrelevant to the model, but chk file has this entry.\nbinary: whether to write the .chk file in binary format.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_chk-Tuple{AbstractString, Wannier.Model}","page":"Input/Output","title":"Wannier.write_chk","text":"write_chk(filename, model; exclude_bands=nothing, binary=false)\n\nWrite the model to a Wannier90 .chk file.\n\nArguments\n\nfilename: filename of the .chk file\nmodel: a Model struct\n\nKeyword Arguments\n\nexclude_bands: a list of band indices to exclude.   This is irrelevant to the model, but chk file has this entry.\nbinary: whether to write the .chk file in binary format.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_w90-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_w90","text":"read_w90(prefix; amn=true, orthonorm_amn=true, mmn=true, eig=true)\n\nRead win, and optionally amn, mmn, eig.\n\nKeyword arguments\n\namn: if true, read amn file\northonorm_amn: Lowdin orthonormalization after reading amn matrices.   Should be true for most cases, since usually the input amn matrices are   projections onto atomic orbitals, and are not unitary or semi-unitary.\nmmn: if true, read mmn file\neig: if true, read eig file\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_w90_with_chk","page":"Input/Output","title":"Wannier.read_w90_with_chk","text":"read_w90_with_chk(prefix, chk=\"$prefix.chk\")\n\nReturn a Model with U matrix filled by that from a chk file.\n\nArguments\n\nchk: path of chk file to get the unitary matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.write_w90-Tuple{AbstractString, Wannier.Model}","page":"Input/Output","title":"Wannier.write_w90","text":"write_w90(seedname::AbstractString, model::Model)\n\nWrite Model into eig, mmn, amn files.\n\nKeyword arguments\n\nbinary: write eig, mmn, and amn in Fortran binary format\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_nnkp-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_nnkp","text":"read_nnkp(filename::AbstractString)\n\nRead the nnkp file.\n\nnote: Note\nThis is a wrapper of WannierIO.read_nnkp. It returns a BVectors instead of NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_nnkp","page":"Input/Output","title":"Wannier.write_nnkp","text":"write_nnkp(filename::AbstractString, bvectors::BVectors, n_wann::Integer)\n\nWrite nnkp that can be used by pw2wannier90.\n\nnote: Note\nThis is a wrapper of WannierIO.write_nnkp.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.read_w90_tb-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_w90_tb","text":"read_w90_tb(seedname; force_mdrs=false)\n\nRead seedname_tb.dat and seedname_wsvec.dat, return TBHamiltonian and TBPosition operators.\n\nArguments\n\nseedname: the seedname of seedname_tb.dat and seedname_wsvec.dat\n\nReturn\n\nA RVectors.\nA TBHamiltonian.\nA rx TBPosition.\nA ry TBPosition.\nA rz TBPosition.\n\nnote: Note\nUsually, if you only need to interpolate operators (e.g., the band structure), that is only inverse Fourier transform invfourier is needed, then you don't need to provide kpoints. If in some cases, you want to generate Wannier gauge operators, then passing the kpoints allows you to construct a complete KRVectors, and you can subsequently call fourier on Bloch gauge operators to get Wannier gauge operators.\n\nwarning: Warning\nSince no atomic positions and labels are provided, the auto-generated Brillouin.KPath is probably wrong. It is recommended that you pass the atom_positions and atom_labels arguments so that this function can auto generate the correct Brillouin.KPath.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#File-manipulation","page":"Input/Output","title":"File manipulation","text":"","category":"section"},{"location":"api/io/#Truncate-Wannier90-matrices","page":"Input/Output","title":"Truncate Wannier90 matrices","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nHere are some functions to remove some bands from mmn, eig, or UNK files, so as to skip rerunning NSCF calculations and pw2wannier90.x.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\"io/truncate.jl\"]","category":"page"},{"location":"api/io/#Wannier.truncate-Union{Tuple{T}, Tuple{Wannier.Model, T}, Tuple{Wannier.Model, T, Union{Nothing, AbstractVector{Int64}, T}}} where T<:AbstractVector{Int64}","page":"Input/Output","title":"Wannier.truncate","text":"truncate(model::Model, keep_bands::Vector{Int}, keep_wfs::Vector{Int}=nothing;\n    orthonorm_U::Bool=true)\n\nTruncate U, M, E matrices in model.\n\nArguments\n\nmodel: the Model to be truncated.\nkeep_bands: Band indexes to be kept, start from 1.\nkeep_wfs: WF indexes to be kept, start from 1. If nothing, keep all.\n\nKeyword arguments\n\northonorm_U: If true, Lowdin orthonormalize U after truncation.   The U needs to be (semi-)unitary, so it should always be true.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.truncate_mmn_eig","page":"Input/Output","title":"Wannier.truncate_mmn_eig","text":"truncate_mmn_eig(seedname, keep_bands::Vector{Int}, outdir=\"truncate\")\n\nTruncate number of bands of mmn and eig files.\n\nArguments\n\nkeep_bands: a vector of band indices to keep, starting from 1.\noutdir: the folder for writing mmn and eig files.\n\ntip: Tip\nThis is useful for generating valence only mmn, eig files from a valence+conduction NSCF calculation, so that no need to recompute NSCF with lower number of bands again.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.truncate_unk","page":"Input/Output","title":"Wannier.truncate_unk","text":"truncate_unk(dir, keep_bands::Vector{Int}, outdir=\"truncate\"; binary=true)\n\nTruncate UNK files for specified bands.\n\nArguments\n\ndir: folder of UNK files.\nkeep_bands: the band indexes to keep. Start from 1.\noutdir: folder to write output UNK files.\nbinary: whether to write binary UNK files.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.truncate_w90","page":"Input/Output","title":"Wannier.truncate_w90","text":"truncate_w90(seedname, keep_bands::Vector{Int}, outdir=\"truncate\", unk=false)\n\nTruncate mmn, eig, and optionally UNK files.\n\nArguments\n\nseedname: seedname for input mmn and eig files.\nkeep_bands: Band indexes to be kept, start from 1.\nunk: If true also truncate UNK files.\noutdir: folder for output files.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#D-visualization-files","page":"Input/Output","title":"3D visualization files","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/volume/xsf.jl\",\n    \"io/volume/bxsf.jl\",\n    \"io/volume/cube.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.read_xsf-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_xsf","text":"read_xsf(filename::AbstractString)\n\nRead xsf file.\n\nReturn\n\nprimvec: 3 * 3, Å, each column is a primitive lattice vector\nconvvec: 3 * 3, Å, each column is a conventional lattice vector\natoms: n_atoms String, atomic symbols or numbers\natom_positions: 3 * n_atoms, Å, cartesian coordinates\nrgrid: RGrid, grid on which W is defined\nW: nx * ny * nz, volumetric data\n\nnote: Note\nOnly support reading 1 datagrid in BLOCK_DATAGRID_3D.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, Wannier.RGrid, AbstractArray{T, 3}}} where T<:Real","page":"Input/Output","title":"Wannier.write_xsf","text":"write_xsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)\n\nWrite xsf file.\n\nArguments\n\nlattice: 3 * 3, Å, each column is a lattice vector\natom_positions: 3 * n_atoms, fractional coordinates\natom_numbers: n_atoms, atomic numbers\nrgrid: RGrid\nW: nx * ny * nz, volumetric data\n\nThis is a more user-friendly version. The rgrid contains the information of the grid origin and spanning vectors.\n\nSee also WannierIO.write_xsf\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_bxsf-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_bxsf","text":"read_bxsf(filename::AbstractString)\n\nRead bxsf file.\n\nReturn\n\nrgrid: RGrid, grid on which E is defined\nfermi_energy: in eV\nE: n_bands * n_kx * n_ky * n_kz, energy eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, Wannier.RGrid, T, AbstractArray{T, 4}}} where T<:Real","page":"Input/Output","title":"Wannier.write_bxsf","text":"write_bxsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)\n\nWrite bxsf file.\n\nArguments\n\nrgrid: RGrid\nfermi_energy: in eV\nE: n_bands * n_kx * n_ky * n_kz, energy eigenvalues\n\nThis is a more user-friendly version. The rgrid contains the information of the grid origin and spanning vectors.\n\nSee also WannierIO.write_bxsf\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_cube-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_cube","text":"read_cube(filename::AbstractString)\n\nRead cube file.\n\nnote: Note\nBy default, cube use Bohr unit, here all returns are in Cartesian coordinates, Å unit.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T<:Real","page":"Input/Output","title":"Wannier.write_cube","text":"write_cube(filename, lattice, atom_positions, atom_numbers, wf_center, rgrid, W; radius=4.0)\n\nWrite cube file for WF.\n\nArguments\n\nlattice: each column is a lattice vector, Å\natom_positions: 3 * n_atoms, fractional coordinates\natom_numbers: n_atoms, atomic numbers\nwf_centers: 3, fractional coordinates w.r.t. lattice\nrgrid: RGrid\nW: nx * ny * nz, volumetric data\n\nKeyword arguments\n\nradius: Å. Periodic replica of atoms are written only for the region   within radius Å from wf_center.\n\nSee also write_cube(filename, filename, atom_positions, atom_numbers, origin, span_vectors, W)\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Interface-to-DFT-codes","page":"Input/Output","title":"Interface to DFT codes","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/interface/mud.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.compute_mud-Tuple{AbstractString, AbstractString}","page":"Input/Output","title":"Wannier.compute_mud","text":"compute_mud(dir_up, dir_dn)\n\nCompute the overlap matrix between spin up and down from UNK files.\n\nM^uparrowdownarrow_m n bmk =\nlangle u^uparrow_m bmk  u^downarrow_n bmk rangle\n\nThis function compute mud matrix in real space (thus much slower), checked with QE pw2wannier90.x function which computes mud in reciprocal space, the difference is on the order of 1e-13.\n\nwarning: Warning\nThis only works for norm-conserving pseudopotentials since in that case the overlap operator is just identity; for ultrasoft or PAW, a simple dot product is not enough. Also I assume the UNK files are written with a normalization factor of N (total points of the FFT grid) over the unit cell, i.e., the UNK generated by QE pw2wannier90.x. If the UNK files are normalized to 1, the result should be multiplied by N.\n\nArguments\n\ndir_up: directory of spin up UNK files\ndir_dn: directory of spin down UNK files\n\n\n\n\n\n","category":"method"},{"location":"WannierPlots/api/realspace/#Real-space-WFs","page":"Real space WFs","title":"Real space WFs","text":"","category":"section"},{"location":"WannierPlots/api/realspace/","page":"Real space WFs","title":"Real space WFs","text":"There are some functions for quick peeks of real space WFs.","category":"page"},{"location":"WannierPlots/api/realspace/","page":"Real space WFs","title":"Real space WFs","text":"CurrentModule = WannierPlots","category":"page"},{"location":"WannierPlots/api/realspace/#Contents","page":"Real space WFs","title":"Contents","text":"","category":"section"},{"location":"WannierPlots/api/realspace/","page":"Real space WFs","title":"Real space WFs","text":"Pages = [\"realspace.md\"]\nDepth = 2","category":"page"},{"location":"WannierPlots/api/realspace/#Index","page":"Real space WFs","title":"Index","text":"","category":"section"},{"location":"WannierPlots/api/realspace/","page":"Real space WFs","title":"Real space WFs","text":"Pages = [\"realspace.md\"]","category":"page"},{"location":"WannierPlots/api/realspace/#API","page":"Real space WFs","title":"API","text":"","category":"section"},{"location":"WannierPlots/api/realspace/","page":"Real space WFs","title":"Real space WFs","text":"Modules = [WannierPlots]\nPages   = [\n    \"realspace/wf_makie.jl\",\n    \"realspace/wf_plotlyjs.jl\",\n]","category":"page"},{"location":"theory/normalization/#Normalization-convention-of-WFs","page":"Normalization","title":"Normalization convention of WFs","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"There are several different conventions for Fourier transform, this page describes the normalization convention used in Wannier.jl. In short, we adopt the same convention as the Section II 3 of [RMP].","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"For a unit cell having volume V, the Bloch functions  psi rangle are periodic in a super cell which is N times the unit cell (thus having volume NV), where N is determined by the discretization of the reciprocal space, i.e. the total number of kpoints.","category":"page"},{"location":"theory/normalization/#Continuous-case","page":"Normalization","title":"Continuous case","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"If the super cell is large enough (N to infty), then the kpoint bmk is a continuous variable in the reciprocal cell having volume frac(2pi)^3V. The inner product between bra and ket langle f  g rangle are integrated over the the NV super cell that is (-infty infty) in the continuous case. If we normalize the Bloch functions over one unit cell, that is,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"langle psi_n bmk  psi_n bmk rangle_V\n= int_V  u_n bmk(bmr) ^2 bmr = 1","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"where psi_n bmk = exp(i bmk bmr) u_n bmk(bmr), then the inner product between bra and ket is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"langle psi_n bmk  psi_m bmk^prime rangle\n= frac(2pi)^3V delta_n m delta(bmk - bmk^prime)","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"This can be proven, e.g. in 1D with periodicity bmR, by","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle psi_n bmk  psi_m bmk^prime rangle\n= int_-infty^+infty psi_n bmk^* psi_m bmk^prime dbmr \n=  int_-infty^+infty exp(i (bmk^prime - bmk) bmr)\n    u_n bmk^*(bmr) u_m bmk^prime(bmr) dbmr \n=  sum_l = -infty^+infty int_l bmR^(l+1) bmR d(bmr + l bmR)\n    exp(i (bmk^prime - bmk) (bmr + l bmR))\n    u_n bmk^*(bmr + l bmR) u_m bmk^prime(bmr + l bmR) \n=  sum_l = -infty^+infty exp(i (bmk^prime - bmk) l bmR)\n    int_0^bmR dbmr exp(i (bmk^prime - bmk) bmr)\n    u_n bmk^*(bmr) u_m bmk^prime(bmr) dbmr \n=  frac2pibmR operatornametextШ_frac2pibmR(bmk^prime - bmk)\n    int_0^bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  frac2pibmR delta(bmk - bmk^prime) delta_n m\nendaligned","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the third line of the above equation, we replace the real space coordinate bmr by bmr + l bmR, such that bmr in 0 bmR). In the fourth line, we utilize the real space periodicity of u_n bmk. In the second last line, the Dirac comb operatornametextШ_T(t) having periodicity T can be expanded as a Fourier series","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"operatorname textШ _T(t) =\nfrac 1T sum _n=-infty ^infty e^i2pi nfrac tT","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the last line, the Bloch function  psi rangle is periodic in bmk thus the Dirac comb is reduced to a Dirac delta function delta(bmk - bmk^prime), and of course the normalization of  psi rangle over one unit cell is used in the last line.","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Thus, the Bloch functions are orthogonal w.r.t. bmk only in the super cell, they are not orthogonal when only integrating over one unit cell.","category":"page"},{"location":"theory/normalization/#Discretized-case","page":"Normalization","title":"Discretized case","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"For finite sampling of reciprocal space, e.g. a 1D cell of periodicity bmR, sampled by N kpoints, then bmk = frac2pibmRfracnN n = 0 1  N-1. The inner product between bra and ket is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle psi_n bmk  psi_m bmk^prime rangle\n= int_0^N bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  sum_l = 0^N-1 exp(i (bmk^prime - bmk) l bmR)\n    int_0^bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  N delta_bmkbmk^prime delta_n m\nendaligned","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"The second last line uses the fact that the discrete Fourier transform of Dirac delta function is 1,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"mathcal F(delta_n)_k =\n    sum_n=0^N-1 delta_n cdot e^-fraci2pi N kn\n    = 1 k = 0 1  N-1","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"so that the delta function can be represented by","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"delta_n = frac1N sum_k=0^N-1 e^fraci2pi N kn","category":"page"},{"location":"theory/normalization/#Real-space-representation","page":"Normalization","title":"Real space representation","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the discrete case, the WFs are the discrete Fourier transform of the Bloch function,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":" bmR n rangle = frac1N sum_bmk\n    e^-i bmk bmR  psi_n bmk rangle","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Note the factor frac1N is multiplied in the forward transform, while the inverse transform is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":" psi_n bmk rangle = sum_bmk e^i bmk bmR  bmR n rangle","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Then the orthonormalization relation of WFs are (note the inner product is integrated over the super cell NV)","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle bmR n  bmR^prime m rangle \n=  frac1N^2 sum_bmkbmk^prime e^i bmk bmR - i bmk^prime bmR^prime\n    langle psi_n bmk  psi_m bmk^prime rangle \n=  frac1N^2 sum_bmkbmk^prime e^i bmk bmR - i bmk^prime bmR^prime\n    N delta_bmkbmk^prime delta_n m \n=  frac1N delta_n m sum_bmk e^i bmk (bmR - bmR^prime) \n=  frac1N delta_n m N delta_bmR bmR^prime\n= delta_n m delta_bmR bmR^prime\nendaligned","category":"page"},{"location":"theory/normalization/#Implementation-details","page":"Normalization","title":"Implementation details","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"The UNK files (generated by QE pw2wannier90.x) are not normalized to 1 in the unit cell (instead to N = N_x times N_y times N_z, where N_x N_y N_z are the number of points of the real space grid), so we need to multiply a factor of frac1sqrtN. This is done in the read_realspace_wf function.\nwarning: Warning\nThis means for other DFT codes to interface with Wannier.jl, the output UNKs need to be normalized to N in the unit cell, otherwise the real space computations, e.g., center(rgrid::RGrid, W::AbstractArray), are wrong!\nThen calculating the WF center in real space can be easily achieved in center(rgrid::RGrid, W::AbstractArray).\nnote: Note\nThis is not as accurate as computing WF center in reciprocal space, unless you have a dense real space sampling (usually determined by the energy cutoff in plane-wave code), and generate the real space WF in the NV-sized super cell (the WF lives in the super cell!).\nHowever, Wannier90 does not consider this factor when writing xsf or cube files, so we remove the factor in write_realspace_wf function, such that\nthe output file is consistent with Wannier90 output.\nanother advantage is that WF is normalized in one unit cell, so the numbers in the xsf are not too small.\nnote: Note\nSomehow the Wannier90 output xsf or cube is on a slightly shifted grid, in write_realspace_wf we just output the WF on the unshifted grid so that the origin of the WF 3D mesh is the same as the lattice origin (or its periodic replicas translated by lattice vectors).","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"[RMP]: Marzari, N.; Mostofi, A. A.; Yates, J. R.; Souza, I. & Vanderbilt, D., Maximally localized Wannier functions: Theory and applications, Reviews of Modern Physics, 2012, 84, 1419","category":"page"},{"location":"#Wannier.jl","page":"Home","title":"Wannier.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for playing with Wannier functions (WFs), including","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generation of WFs from density functional theory (DFT) calculations\nWannier interpolation of operators, e.g. band structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to write clean and modularized functions for Wannierization and Wannier interpolation, together with the expressive and interactive Julia language, to enable fast prototyping and development of new ideas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared with Wannier90, the package provides different Wannierization algorithms using matrix manifold optimization. Currently, MPI is not supported, so probably not suitable for large systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is still under development, and the API is subject to change.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wannierization\nmaximal localization for isolated bands, e.g. insulators\ndisentanglement for entangled bands, e.g. metal\nparallel transport gauge\nsplit valence and conduction WFs\nautomated initial projection for valence or conduction WFs\nconstrain WF center\nInterpolation of operators, e.g. band structure\nReal space WFs\noutput xsf or cube file\nevaluate operators in real space","category":"page"},{"location":"WannierPlots/api/fermisurf/#B-vectors","page":"B vectors","title":"B vectors","text":"","category":"section"},{"location":"WannierPlots/api/fermisurf/","page":"B vectors","title":"B vectors","text":"CurrentModule = WannierPlots","category":"page"},{"location":"WannierPlots/api/fermisurf/#Contents","page":"B vectors","title":"Contents","text":"","category":"section"},{"location":"WannierPlots/api/fermisurf/","page":"B vectors","title":"B vectors","text":"Pages = [\"fermisurf.md\"]\nDepth = 2","category":"page"},{"location":"WannierPlots/api/fermisurf/#Index","page":"B vectors","title":"Index","text":"","category":"section"},{"location":"WannierPlots/api/fermisurf/","page":"B vectors","title":"B vectors","text":"Pages = [\"fermisurf.md\"]","category":"page"},{"location":"WannierPlots/api/fermisurf/#API","page":"B vectors","title":"API","text":"","category":"section"},{"location":"WannierPlots/api/fermisurf/","page":"B vectors","title":"B vectors","text":"Modules = [WannierPlots]\nPages   = [\n    \"fermisurf_plotlyjs.jl\",\n]","category":"page"},{"location":"WannierPlots/api/band/#Band-structure","page":"Band structure","title":"Band structure","text":"","category":"section"},{"location":"WannierPlots/api/band/","page":"Band structure","title":"Band structure","text":"There are some functions for quick peeks of band structures.","category":"page"},{"location":"WannierPlots/api/band/","page":"Band structure","title":"Band structure","text":"CurrentModule = WannierPlots","category":"page"},{"location":"WannierPlots/api/band/#Contents","page":"Band structure","title":"Contents","text":"","category":"section"},{"location":"WannierPlots/api/band/","page":"Band structure","title":"Band structure","text":"Pages = [\"band.md\"]\nDepth = 2","category":"page"},{"location":"WannierPlots/api/band/#Index","page":"Band structure","title":"Index","text":"","category":"section"},{"location":"WannierPlots/api/band/","page":"Band structure","title":"Band structure","text":"Pages = [\"band.md\"]","category":"page"},{"location":"WannierPlots/api/band/#API","page":"Band structure","title":"API","text":"","category":"section"},{"location":"WannierPlots/api/band/","page":"Band structure","title":"Band structure","text":"Modules = [WannierPlots]\nPages   = [\n    \"band/band.jl\",\n    \"band/diff.jl\",\n]","category":"page"}]
}
