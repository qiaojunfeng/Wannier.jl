var documenterSearchIndex = {"docs":
[{"location":"api/bvector/#B-vector","page":"b-vector","title":"B vector","text":"","category":"section"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"The bmb-vectors connect kpoint bmk to its neighboring kpoints bmk+bmb, for calculating WF centers, spreads in reciprocal space.","category":"page"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"The bvectors are first arranged in layers of shells, which contain bvectors having same norm. Then parallel shells are deleted, and the shells satisfying B1 condition are the final bvectors. At last, the bvectors are sorted at each kpoint, to reproduce exactly the same order as Wannier90. This ensures that we have the same order as mmn file.","category":"page"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"note: Note\nTo reproduce the same order as Wannier90, we need to be careful with some floating point comparison, i.e., the atol keyword arguments in the following functions. Their default value reproduce the Wannier90 order. Note the kmesh_tol in the win file also influence the search of bvectors.","category":"page"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"tip: Tip\nIn most cases, the user only need to call generate_bvectors to generate bvectors having the same order as Wannier90. Other functions are intermediate steps that are called inside generate_bvectors.","category":"page"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"CurrentModule = Wannier","category":"page"},{"location":"api/bvector/#Contents","page":"b-vector","title":"Contents","text":"","category":"section"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"Pages = [\"bvector.md\"]\nDepth = 2","category":"page"},{"location":"api/bvector/#Index","page":"b-vector","title":"Index","text":"","category":"section"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"Pages = [\"bvector.md\"]","category":"page"},{"location":"api/bvector/#B-vector-shells-and-B-vectors","page":"b-vector","title":"B vector shells and B vectors","text":"","category":"section"},{"location":"api/bvector/","page":"b-vector","title":"b-vector","text":"Modules = [Wannier]\nPages   = [\"bvector.jl\"]","category":"page"},{"location":"api/realspace/#Real-space-WFs","page":"Real space","title":"Real space WFs","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"This page lists functions for processing WFs in real space.","category":"page"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Normally operators are computed in reciprocal space, but sometimes it might be useful to evaluate them in real space. For example, computing higher moment of WFs.","category":"page"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"CurrentModule = Wannier","category":"page"},{"location":"api/realspace/#Contents","page":"Real space","title":"Contents","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Pages = [\"realspace.md\"]\nDepth = 2","category":"page"},{"location":"api/realspace/#Index","page":"Real space","title":"Index","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Pages = [\"realspace.md\"]","category":"page"},{"location":"api/realspace/#Real-space-grid-struct","page":"Real space","title":"Real-space grid struct","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"common/rgrid.jl\"]","category":"page"},{"location":"api/realspace/#Wannier.RGrid","page":"Real space","title":"Wannier.RGrid","text":"struct RGrid(basis, X, Y, Z)\n\nRepresents a regular grid of points.\n\nFields\n\nbasis: each column is a basis vector of the grid,   usually just the lattice vectors.\nX: nx * ny * nz array of fractional coordinate w.r.t basis,   the x coordinate of each point in the grid.\nY: nx * ny * nz array of fractional coordinate w.r.t basis,   the y coordinate of each point in the grid.\nZ: nx * ny * nz array of fractional coordinate w.r.t basis,   the z coordinate of each point in the grid.\n\ntip: Tip\nThe X, Y, and Z are usually generated by LazyGrids.ndgrid. They are fractional and can be outside of [0, 1), so the basis are not necessarily the spanning vectors of the grid. See also origin and span_vectors.Usually the grid does not contain the periodically repeated points, e.g., the x coordinate can be [0.0, 0.25, 0.5, 0.75] without 1.0 which is repeatition of 0.0.\n\n\n\n\n\n","category":"type"},{"location":"api/realspace/#Wannier.RGrid-Tuple{AbstractMatrix, Vararg{AbstractVector, 4}}","page":"Real space","title":"Wannier.RGrid","text":"RGrid(basis, origin, X, Y, Z)\n\nConstruct a regular grid of points.\n\nArguments\n\nbasis: each column is a basis vector of the grid,   usually just the lattice vectors.\norigin: 3, origin of the grid in cartesian coordinates\nX: nx vector of fractional coordinate w.r.t basis,   the x coordinate of each point in the grid.\nY: ny vector of fractional coordinate w.r.t basis,   the y coordinate of each point in the grid.\nZ: nz vector of fractional coordinate w.r.t basis,   the z coordinate of each point in the grid.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.cartesianize_xyz-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.cartesianize_xyz","text":"cartesianize_xyz(rgrid::RGrid)\n\nReturn X, Y, Z in cartesian coordinates.\n\nThe size of the returned X, Y, and Z are nx * ny * nz.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.origin-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.origin","text":"origin(rgrid::RGrid)\n\nGet the origin in cartesian coordinates, i.e. the 1st point, of the RGrid.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.span_vectors-Tuple{Wannier.RGrid}","page":"Real space","title":"Wannier.span_vectors","text":"span_vectors(rgrid::RGrid)\n\nGet the spanning vectors of the RGrid.\n\nEach column in the returned matrix is a spanning vector.\n\nnote: Note\nThere is no limit constraint on the fractional coordinates X, Y, and Z, so the spanning vectors are not necessarily the basis vectors, they can be fractional of the basis vectors, or multiple times of that.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Read/write-real-space-WFs","page":"Real space","title":"Read/write real-space WFs","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"realspace/wavefunction.jl\"]","category":"page"},{"location":"api/realspace/#Wannier.WannierFunction","page":"Real space","title":"Wannier.WannierFunction","text":"Real space WannierFunction defined on a uniformly (in crystal coordinates) spaced r-grid.\n\n\n\n\n\n","category":"type"},{"location":"api/realspace/#Wannier._get_unk_ext-Tuple{AbstractString}","page":"Real space","title":"Wannier._get_unk_ext","text":"_get_unk_ext(unkdir::AbstractString)\n\nGet the extension name of UNK files.\n\nFor example:\n\n1 of UNK00001.1, for no-spin calcluation\nNC of UNK00001.NC, for non-collinear calculation\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.calc_angmom-Union{Tuple{T}, Tuple{N}, Tuple{Wannier.WannierFunction{N, T}, Wannier.WannierFunction{N, T}, StaticArraysCore.SVector{3, T}}, Tuple{Wannier.WannierFunction{N, T}, Wannier.WannierFunction{N, T}, StaticArraysCore.SVector{3, T}, Any}} where {N, T<:AbstractFloat}","page":"Real space","title":"Wannier.calc_angmom","text":"Calculates the angular momentum between two wavefunctions and around the center.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.calc_dipole-Union{Tuple{T}, Tuple{N}, Tuple{Wannier.WannierFunction{N, T}, Wannier.WannierFunction{N, T}}} where {N, T<:AbstractFloat}","page":"Real space","title":"Wannier.calc_dipole","text":"Calculates the dipole term between two wavefunctions. Make sure the wavefunctions are normalized!\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, Union{Int64, AbstractArray{Int64}}}, Tuple{AbstractMatrix{T}, Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(lattice, U, kpoints, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a more user-friendly version, which returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nlattice: each column is a lattice vector\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{Array{Array{Complex{T}, 2}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}, Any, AbstractVector{Int64}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(U, kpoints, n_supercells, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nArguments\n\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\nkpoints: 3 * n_kpts, each column is a vector for fractional coordinates\nn_supercells: an integer or a vector of 3 integers for 3 directions along lattice vectors,   defines the number of super cells where the real space WF lives\nunkdir: folder containing UNK files\n\nKeyword arguments\n\nR: fractional coordinates w.r.t lattice (actually integers), the cell for WF   n bmR rangle, default is generating WF at home unit cell n bm0 rangle\n\ntip: Tip\nSee also the section Normalization convention of WFs for further explanation.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}, Union{Int64, AbstractArray{Int64}}}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(model, U, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a most user-friendly version, use lattice, U and kpoints from model and returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nmodel: a Model\nU: n_bands * n_wann * n_kpts, gauge rotation matrix\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.read_realspace_wf-Union{Tuple{Wannier.Model{T}}, Tuple{T}, Tuple{Wannier.Model{T}, Union{Int64, AbstractArray{Int64}}}, Tuple{Wannier.Model{T}, Union{Int64, AbstractArray{Int64}}, AbstractString}} where T<:Real","page":"Real space","title":"Wannier.read_realspace_wf","text":"read_realspace_wf(model, n_supercells=2, unkdir=\".\"; R=[0, 0, 0])\n\nRead UNK files, rotate gauge, and generate real space WFs.\n\nThis is a most user-friendly version, use lattice, U and kpoints from model and returns a tuple of (RGrid, W), where RGrid is the grid on which W is defined, and W is volumetric data for WFs.\n\nArguments\n\nmodel: a Model\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.write_realspace_wf-Tuple{AbstractString, AbstractArray, Vector, AbstractMatrix, AbstractVector, AbstractVector{String}}","page":"Real space","title":"Wannier.write_realspace_wf","text":"write_realspace_wf(seedname, U, kpoints, lattice, atom_positions, atom_labels;\n    n_supercells=2, unkdir=\".\", part=real, format=:xsf, wf_center=nothing)\n\nWrite real space WFs to xsf or cube files.\n\nArguments\n\nseedname: the name prefix for cube files, e.g., seedname_00001.cube\nU: gauge rotation matrix\nkpoints: each column is a kpoint, fractional coordinates\nlattice: each column is a lattice vector\natom_positions: each column is an atom position, fractional coordinates w.r.t. lattice\natom_labels: each element is an atom label\n\nKeyword arguments\n\nn_supercells: number of supercells in each direction,   equivalent to wannier_plot_supercell of Wannier90\nunkdir: directory of UNK files\npart: which part to plot? pass a Function, e.g. real, imag, abs2\nformat: :xsf or :cube\nwf_center: WF centers in fractional coordinates w.r.t. lattice.   Only used for cube format, add additional atoms around WF centers.\n\nnote: Note\nWannier90 only plot the real part of WFs, so part=real is the default.\n\ntip: Tip\nSee also the section Normalization convention of WFs for further explanation.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.write_realspace_wf-Tuple{String, Wannier.Model}","page":"Real space","title":"Wannier.write_realspace_wf","text":"write_realspace_wf(seedname, model; n_supercells=2, unkdir=\".\", part=real, format=:xsf)\n\nWrite real space WFs to xsf or cube files.\n\nThis is a user-friendly version that use model to fill the arguments of write_realspace_wf.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Evaluate-operators-in-real-space","page":"Real space","title":"Evaluate operators in real space","text":"","category":"section"},{"location":"api/realspace/","page":"Real space","title":"Real space","text":"Modules = [Wannier]\nPages   = [\"realspace/moment.jl\"]","category":"page"},{"location":"api/realspace/#Wannier.center-Tuple{Wannier.RGrid, AbstractArray}","page":"Real space","title":"Wannier.center","text":"center(rgrid::RGrid, W::AbstractArray)\n\nCompute WF center in real space.\n\nReturned value in Cartesian coordinates.\n\nSee also moment.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.moment-Union{Tuple{U}, Tuple{T}, Tuple{Wannier.RGrid, AbstractArray{T, 3}, U}} where {T<:Complex, U<:Integer}","page":"Real space","title":"Wannier.moment","text":"moment(rgrid::RGrid, W::AbstractArray, n)\n\nCompute WF moment to arbitrary order in real space.\n\nArguments\n\nrgrid: real space grid on which W is defined\nW: WFs, nx * ny * nz * n_wann, or nx * ny * nz for single WF\nn: order of moment, e.g., 1 for WF center, 2 for variance, etc.\n\nReturned value in Cartesian coordinates.\n\nnote: Note\nThe WFs are defined in a supercell that is n_kpts times unit cell, however, usually we only calculate realspace WFs in a smaller supercell that is 2^3 or 3^3 times unit cell (as defined by the n_supercells argument of read_realspace_wf). Some times this is not sufficient if the WFs are truncated by the boundries of the smaller supercell, thus the center calculated by this function is inexact. In principle, we should calculate centers in the n_kpts supercell, however, this is memory-consuming.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.omega-Tuple{Wannier.RGrid, AbstractArray}","page":"Real space","title":"Wannier.omega","text":"omega(rgrid::RGrid, W::AbstractArray)\n\nCompute WF spread in real space.\n\nReturned value in Å^2 unit.\n\nSee also moment.\n\n\n\n\n\n","category":"method"},{"location":"api/realspace/#Wannier.position_op-Union{Tuple{T}, Tuple{Wannier.RGrid, AbstractArray{T, 4}}} where T<:Complex","page":"Real space","title":"Wannier.position_op","text":"position_op(rgrid::RGrid, W::AbstractArray{T,4})\n\nCompute position operator matrices in real space.\n\nReturned value in Cartesian coordinates.\n\nSee also center.\n\n\n\n\n\n","category":"method"},{"location":"examples_foreword/#Foreword-to-the-examples","page":"Foreword to the examples","title":"Foreword to the examples","text":"","category":"section"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"CurrentModule = Wannier","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"If you have already been familiar with the Wannierization workflow using Wannierization workflow using Quantum ESPRESSO and wannier90, the following examples should be easy to follow. As a side note, some good wannier90 tutorials can be found at","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"examples and tutorials.pdf of Wannier90\nhttps://github.com/wannier-developers/wannier-tutorials","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"warning: Warning\nIn this repo, the convergence parameters (kpoint sampling, ...) when generating the input files (e.g., amn/mmn/eig/...) are quite loose! This is on purpose to reduce storage size and save computational time. Thus, it is expected that the band interpolation might have some defects.In real applications, one should always run calculations with production-quality convergence parameters for high-quality band interpolations.","category":"page"},{"location":"examples_foreword/#WannierDatasets","page":"Foreword to the examples","title":"WannierDatasets","text":"","category":"section"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Throughout the examples, we need to load input files to construct Models for Wannierizations. Often, preparing these input files requires density-functional-theory calculations which can be time-consuming, and distracting ourselves from the main purpose of Wannierizations and Wannier interpolations.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Julia has a convenient artifact system allowing us to load binaries or data files easily in Julia script or REPL, without the need of manually downloading and placing them in the right folder.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"In Wannier.jl, we use such system to load our pre-computed WannierDatasets, which contains some typical materials, e.g., silicon, copper, graphene, etc. This allows easy loading of input files and construct Wannier functions hassle-free.","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"The Wannier.Datasets submodule provides several functions to help inspect and load the datasets. First, we need to using the submodule to bring the functions into scope","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"using Wannier.Datasets","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"List all available datasets by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"list_datasets()","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Load a dataset into a Wannier.jl Model by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"model = load_dataset(\"Si2\")","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"The dataset is just a folder containing input files, you can inspect the folder by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"show_dataset(\"Si2\")","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"Finally, you can directly access the individual files by dataset string which just returns a string of the path to the file","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"dataset\"Si2/Si2.win\"","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"For example, you can read the content of a file by","category":"page"},{"location":"examples_foreword/","page":"Foreword to the examples","title":"Foreword to the examples","text":"readlines(dataset\"Si2/Si2.win\")","category":"page"},{"location":"api/model/#Model","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"The Model is a Julia struct that abstracts a single Wannierization, it contains all the necessary information for maximally localization of the crystal structure.","category":"page"},{"location":"api/model/","page":"Model","title":"Model","text":"CurrentModule = Wannier","category":"page"},{"location":"api/model/#Contents","page":"Model","title":"Contents","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Pages = [\"model.md\"]\nDepth = 2","category":"page"},{"location":"api/model/#Index","page":"Model","title":"Index","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Pages = [\"model.md\"]","category":"page"},{"location":"api/model/#Model-2","page":"Model","title":"Model","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Modules = [Wannier]\nPages   = [\"src/model.jl\"]  # explicitly add \"src/\" to avoid matching InterpModel","category":"page"},{"location":"api/model/#Wannier.Model","page":"Model","title":"Wannier.Model","text":"struct Model{T<:Real}\n\nA high-level data structure containing necessary parameters and matrices for constructing Wannier functions (WFs), or called, Wannierization.\n\nIn general, the problem of Wannierization is to find a set of unitary matrices U_bmk that gives a localized representation of the Bloch states psi_n bmk. Depending on the inputs, the Wannierization problem can be categorized into two classes:\n\nisolated manifold: when number of bands = number of Wannier functions\nentangled manifold: when number of bands > number of Wannier functions\n\nFields\n\nUsing these accronyms,     - n_atoms: number of atoms     - n_kpoints: number of kpoints     - n_bvectors: number of b-vectors     - n_bands: number of bands     - n_wannier: number of Wannier functions the fields are defined as follows:\n\nlattice: unit cell, 3 * 3, each column is a lattice vector in Å unit\natom_positions: atomic positions, length-n_atoms vector, each element is a Vec3 of fractional coordinates\natom_labels: atomic labels, length-n_atoms vector of string\nkstencil: stencil for finite differences on the kpoint grid, also called mathbfb-vectors. Should satisfy completeness condition, see KspaceStencil\noverlaps: overlap matrices between neighboring wavefunctions, M_bmkbmb. Length-n_kpoints vector, each element is a length-n_bvectors vector, then each element is a n_bands * n_bands matrix. Also called mmn matrices in wannier90\ngauges: unitary or semi-unitary gauge transformation matrices, U_bmk, or called the gauge matrices. Length-n_kpoints vector, each element is a n_bands * n_wannier matrix\neigenvalues: energy eigenvalues, varepsilon_n bmk, length-n_kpoints vector, each element is a length-n_bands vector, in eV unit\nfrozen_bands: mask for frozen bands. Length-n_kpoints vector, each element is a length-n_bands BitVector. If true the the state at that kpoint and band index is kept unchanged during the disentanglement procedure.\nentangled_bands: mask for bands taking part in disentanglement. Length-n_kpoints vector, each element is a length-n_bands BitVector. If true the the state at that kpoint and band index participates the disentanglement procedure.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.isentangled-Tuple{Wannier.Model}","page":"Model","title":"Wannier.isentangled","text":"isentangled(model)\n\n\nIs entangled manifold?\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.isisolated-Tuple{Wannier.Model}","page":"Model","title":"Wannier.isisolated","text":"isisolated(model)\n\n\nIs isolated manifold?\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Spread","page":"Model","title":"Spread","text":"","category":"section"},{"location":"api/model/","page":"Model","title":"Model","text":"Modules = [Wannier]\nPages   = [\"spread.jl\"]","category":"page"},{"location":"api/model/#Wannier.CenterSpreadPenalty","page":"Model","title":"Wannier.CenterSpreadPenalty","text":"Penalty for minimizing the spread as well as maximizing the \"closeness\" to the atoms.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.Spread","page":"Model","title":"Wannier.Spread","text":"struct Spread\n\nThe Marzari-Vanderbilt (MV) spread functional.\n\nFrom MV:\n\nOmega = sum_n langle r^2 rangle_n -  langle r rangle_n ^2\nlangle r rangle_n = -frac1N sum_bmkbmb w_bmb bmb   Im log M_nn^bmkbmb\nlangle r^2 rangle_n = frac1N sum_bmkbmb w_bmb bmb   left left( 1 -  M_nn^bmkbmb ^2 right) +   left( Im log M_nn^bmkbmb right)^2 right\n\nFields\n\nΩ: total spread, unit Å²\nΩI: gauge-invarient part, unit Å²\nΩOD: off-diagonal part, unit Å²\nΩD: diagonal part, unit Å²\nΩ̃: Ω̃ = ΩOD + ΩD, unit Å²\nω: Ω of each WF, unit Å², length(ω) = n_wann\nr: WF center, Cartesian coordinates, unit Å, 3 * n_wann\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.SpreadCenter","page":"Model","title":"Wannier.SpreadCenter","text":"struct SpreadCenter\n\nA struct containing both Spread and WF center penalty.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.SpreadPenalty","page":"Model","title":"Wannier.SpreadPenalty","text":"Standard penalty for minimizing the total spread.\n\n\n\n\n\n","category":"type"},{"location":"api/model/#Wannier.center-Tuple{Wannier.KspaceStencil, Any, Any}","page":"Model","title":"Wannier.center","text":"center(bvectors, M, U)\n\nCompute WF center in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Tuple{Wannier.Model}","page":"Model","title":"Wannier.center","text":"center(model)\n\nCompute WF center in reciprocal space for Model.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Union{Tuple{FT}, Tuple{Wannier.KspaceStencil{FT}, Vector, Array{Complex{FT}, 3}}} where FT<:Real","page":"Model","title":"Wannier.center","text":"center(bvectors, M, U)\n\nCompute WF center in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.center-Union{Tuple{T}, Tuple{Wannier.Model, Array{Matrix{T}, 1}}} where T<:Number","page":"Model","title":"Wannier.center","text":"center(model, U)\n\nCompute WF center in reciprocal space for Model with given U gauge.\n\nArguments\n\nmodel: the Model\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.compute_berry_connection_kspace-Tuple{Wannier.KspaceStencil, AbstractVector, AbstractVector}","page":"Model","title":"Wannier.compute_berry_connection_kspace","text":"compute_berry_connection_kspace(\n    kstencil,\n    overlaps,\n    gauges;\n    imlog_diag,\n    force_hermiticity\n)\n\n\nWannier-gauge Berry connection in kspace, WYSV Eq. 44 or MV Eq. C14\n\nKeyword arguments\n\nimlog_diag: use imaginary part of logrithm for diagonal elements,   MV1997 Eq. 31. wannier90 default is true.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega-Tuple{Wannier.Model}","page":"Model","title":"Wannier.omega","text":"omega(model, [U])\nomega(bvectors, M, U)\n\nCompute WF spread for a Model, potentially for a given gauge U, or by explicitely giving bvectors and M. In case of the first bvectors = model.bvectors and M = model.M.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_center-Tuple","page":"Model","title":"Wannier.omega_center","text":"omega_center(bvectors, M, U, r₀, λ)\n\nCompute WF spread with center penalty, for maximal localization.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\nr₀: 3 * n_wann, WF centers in cartesian coordinates\nλ: penalty strength\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_grad-Tuple{Function, Wannier.KspaceStencil, Any, Any}","page":"Model","title":"Wannier.omega_grad","text":"omega_grad(bvectors, M, U, r)\n\nCompute gradient of WF spread.\n\nSize of output dΩ/dU = n_bands * n_wann * n_kpts.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\nr: 3 * n_wann, the current WF centers in cartesian coordinates\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.omega_local-Union{Tuple{FT}, Tuple{Wannier.KspaceStencil{FT}, Vector, Array{Array{Complex{FT}, 2}, 1}}} where FT<:Real","page":"Model","title":"Wannier.omega_local","text":"omega_local(bvectors, M, U)\n\nLocal part of the contribution to r^2.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Tuple{Wannier.Model}","page":"Model","title":"Wannier.position_op","text":"position_op(model)\n\nCompute WF postion operator matrix in reciprocal space for Model.\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Union{Tuple{FT}, Tuple{Wannier.KspaceStencil{FT}, Vector, Array{Array{Complex{FT}, 2}, 1}}} where FT<:Real","page":"Model","title":"Wannier.position_op","text":"position_op(bvectors, M, U)\n\nCompute WF postion operator matrix in reciprocal space.\n\nArguments\n\nbvectors: bvecoters\nM: n_bands * n_bands * * n_bvecs * n_kpts overlap array\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"api/model/#Wannier.position_op-Union{Tuple{T}, Tuple{Wannier.Model, Array{Matrix{T}, 1}}} where T<:Number","page":"Model","title":"Wannier.position_op","text":"position_op(model, U)\n\nCompute WF postion operator matrix in reciprocal space for Model with given U gauge.\n\nArguments\n\nmodel: the Model\nU: n_wann * n_wann * n_kpts array\n\n\n\n\n\n","category":"method"},{"location":"start/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"start/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"start/#Julia","page":"Getting Started","title":"Julia","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"First install Julia, you can,","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"use juliaup\nor download releases from https://julialang.org/downloads/","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nQuick notes for installing juliaup, on Linux or macOS:curl -fsSL https://install.julialang.org | sh\njuliaup add release","category":"page"},{"location":"start/#Wannier.jl","page":"Getting Started","title":"Wannier.jl","text":"","category":"section"},{"location":"start/#From-Julia-package-manager","page":"Getting Started","title":"From Julia package manager","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Install with the Julia package manager Pkg, just like any other registered Julia package:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"pkg> add Wannier  # Press ']' to enter the Pkg mode","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"or","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg; Pkg.add(\"Wannier\")","category":"page"},{"location":"start/#From-GitHub","page":"Getting Started","title":"From GitHub","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"If you want to play with the code, you can clone the repo:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"git clone https://github.com/qiaojunfeng/Wannier.jl.git\ncd Wannier.jl\njulia --project=. -e 'using Pkg; Pkg.update(); Pkg.resolve(); Pkg.instantiate()'","category":"page"},{"location":"start/#From-tarball","page":"Getting Started","title":"From tarball","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Download releases from https://github.com/qiaojunfeng/Wannier.jl/releases","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tar xvf Wannier.jl.tar.gz\ncd Wannier.jl\njulia --project=. -e 'using Pkg; Pkg.update(); Pkg.resolve(); Pkg.instantiate()'","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nIf you install with Pkg, then start Julia REPL just with julia; if you install with git or tarball, then start with julia --project=PATH_OF_Wannier.jl.","category":"page"},{"location":"start/#Command-line-interface","page":"Getting Started","title":"Command-line interface","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Additionally, there is a command-line interface (CLI)","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\njulia --project deps/build.jl install  # install CLI","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The executable will be installed in ~/.julia/bin/wjl.","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"After appending ~/.julia/bin to your $PATH, you can use the CLI as follows:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"$ wjl -h\n\n\n  wannier v0.1.0\n\nJulia package for Wannier functions.\n\nUsage\n\n  wannier <command>\n...","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"note: Note\nSince julia needs precompilation of the code, there will be some delay when running the CLI.","category":"page"},{"location":"start/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"For example, running a maximal localization can be easily achieved by","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"using Wannier\n\nmodel = read_w90(\"silicon\")\nU = max_localize(model)\nwrite_amn(\"silicon.amn\", U)","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"For a much more detailed usage, please refer to the API documentation and the source code of each function.","category":"page"},{"location":"start/#Development","page":"Getting Started","title":"Development","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The repo is hosted at https://github.com/qiaojunfeng/Wannier.jl","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"To reduce the startup latency of the Wannier.jl package, and to allow smoother user/development experience, some of the functionality are implemented inside standalone packages:","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"The input/output functions are inside   WannierIO.jl repo,   and its documentation at   io.wannierjl.org\nThe plotting related code is inside   WannierPlots.jl repo,   and its documentation at   plots.wannierjl.org","category":"page"},{"location":"start/#Pre-commit","page":"Getting Started","title":"Pre-commit","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"To ensure uniform code style, we use pre-commit, which auto check and fix code style before each git commit. Install the hooks with","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\npre-commit install","category":"page"},{"location":"start/#Tests","page":"Getting Started","title":"Tests","text":"","category":"section"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"Run tests with","category":"page"},{"location":"start/","page":"Getting Started","title":"Getting Started","text":"cd Wannier.jl\njulia --project=.  # start REPL\n]                  # activate Pkg mode\ntest               # run tests","category":"page"},{"location":"theory/fourier/#Fourier-transforms","page":"Wannier Interpolation","title":"Fourier transforms","text":"","category":"section"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"The Fourier-space frequencies for Wannier interpolation, also called mathbfR-vectors.","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"The Wannier interpolation is a Fourier transform of a (theoretically continuous periodic function (Bloch wavefunction) into a Fourier series. However, since the wavefunctions are discretized in mathbfk-space on a grid, the Fourier series of a coutinuous functionis turns into a discrete-time Fourier transform (DTFT). For the usual DTFT, the signal is transformed from time domain to frequency domain. Here, the time domain is the mathbfk-space, while the frequency domain is the mathbfR-space.","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"To improve interpolation accuracy, the frequencies (often they are called the mathbfR-vectors, since they live in 3D space) are not chosen inside a parallelepiped, but inside a Wigner-Seitz cell to make sure most of the large-magnitude interactions (e.g., Hamiltonian H(mathbfR)) are included. Therefore, we have some special algorithms to generate the mathbfR-space domain.","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"Th function [generate_Rspace] can generate two kinds of R-space domains, by providing an argument of type WannierInterpolationAlgorithm:","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"WSInterpolation: Wigner-Seitz interpolation,   returns a WignerSeitzRspace\nMDRSInterpolation: minimal-distance replica selection interpolation,   returns a MDRSRspace","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"However, the details of how to place the R-vectors and setting their degeneracies are irrelevant to the Fourier / inverse Fourier transforms, therefore, we provide a function simplify that can convert each kind of RspaceDomain to a BareRspace, enabling faster Fourier transforms.","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"Depending on the type of RspaceDomain, there are three kinds of Fourier transform:","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"BareRspace: simple Fourier sum   math   O_{mn}(\\\\mathbf{R}) = \\\\frac{1}{N_{\\\\mathbf{k}}}   \\\\sum_{\\\\mathbf{k}} \\\\exp(-i {\\\\mathbf{k}} \\\\mathbf{R}) O_{mn}(\\\\mathbf{k}),\nWignerSeitzRspace: Wigner-Seitz interpolation, the forward Fourier transform   is the same as BareRspace,\nMDRSRspace: minimal-distance replica selection interpolation   math   O_{mn}(\\\\widetilde{ \\\\mathbf{R} }) =   \\\\sum_{ \\\\mathbf{R} } \\\\frac{1}{\\\\mathcal{N}_{\\\\mathbf{R}} \\\\mathcal{N}_{mn \\\\mathbf{R}}}   O_{mn}(\\\\mathbf{R})   \\\\sum_{i=1}^{\\\\mathcal{N}_{mn \\\\mathbf{R}}}   \\\\delta_{ \\\\widetilde{\\\\mathbf{R}}, \\\\mathbf{R} + \\\\mathbf{T}_{mn \\\\mathbf{R}}^{(i)} },","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"where","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"N_mathbfk: the total number of kpoints\nmathcalN_mathbfR: the degeneracy of R-vectors\nmathcalN_mn mathbfR is the degeneracy of mathbfT_mn mathbfR vectors","category":"page"},{"location":"theory/fourier/#invfourier","page":"Wannier Interpolation","title":"invfourier","text":"","category":"section"},{"location":"theory/fourier/#WS","page":"Wannier Interpolation","title":"WS","text":"","category":"section"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"O_mn(mathbfk) = sum_mathbfR frac1mathcalN_mathbfR\nexp(i mathbfk mathbfR) O_mn(mathbfR)","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"where mathcalN_mathbfR is the degeneracy of R vectors (not the total number of R vectors).","category":"page"},{"location":"theory/fourier/#MDRS","page":"Wannier Interpolation","title":"MDRS","text":"","category":"section"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"X_mn(mathbfk) = sum_mathbfR\nfrac1 mathcalN_mn mathbfR  X_mn(mathbfR)\nsum_j=1^mathcalN_ mn mathbfR \nexpleft( i mathbfk cdot left( mathbfR + mathbfT_ mn mathbfR ^(j) right) right)","category":"page"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"where mathcalN_mathbfR is the degeneracy of R vectors (not the total number of R vectors), and mathcalN_ mn mathbfR  is the degeneracy of mathbfT_ mn mathbfR  vectors.","category":"page"},{"location":"theory/fourier/#MDRSv2","page":"Wannier Interpolation","title":"MDRSv2","text":"","category":"section"},{"location":"theory/fourier/","page":"Wannier Interpolation","title":"Wannier Interpolation","text":"X_mn(mathbfk) = sum_ widetildemathbfR \nexpleft( i mathbfk widetilde mathbfR  right) widetildeX_mn(widetildemathbfR)","category":"page"},{"location":"theory/algorithm/#Algorithms","page":"Localization","title":"Algorithms","text":"","category":"section"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"Here are some detailed explanations of the algorithms used in this package, however, it might still be too concise, please refer to the references for full discussion.","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"Moreover, a good starting point for the WF theory could be[RMP].","category":"page"},{"location":"theory/algorithm/#Wannierization","page":"Localization","title":"Wannierization","text":"","category":"section"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"maximal localization for isolated bands, e.g. insulators\ndifferent from[MV97], optimize on unitary matrix manifolds (adaptation of [DLL19] to isolated bands)\ndisentanglement for entangled bands, e.g. metal\ndifferent from[SMV01], optimize on Stiefel manifolds[DLL19]\nparallel transport gauge[GLS19]\nyou can further improve the spread by optimization w.r.t. a single rotation matrix[QMP21]\nsplit valence and conduction WFs from a valence + conduction calculation[QMP21]\nas a by-product, automated initial projection for valence or conduction WFs\nfor the initial projection of valence + conduction calculation, you can start with either conventional spdf projection, SCDM[DL18], or an automated projection and disentanglement from pseudopotential orbitals[QPM21]\ndifferent from SCDM, the valence+conduction manifold is chosen by the valence+conduction calculation, instead of SCDM μ and σ. Moreover, works in reciprocal space thus more memory-efficient\nconstrain WF center for max localization or disentanglement[QMP21]\nsimilar to[WLPMM14], add an Lagrange multiplier term to spread functional, but optimize on matrix manifolds, and applying to both max localization and disentanglement (whereas in [WLPMM14] the center is constrained only during max localization)","category":"page"},{"location":"theory/algorithm/#Interpolation","page":"Localization","title":"Interpolation","text":"","category":"section"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"Two algorithms:","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"Wigner-Seitz (WS) interpolation\nMinimal-distance replica selection (MDRS) method","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"for band structure along a kpath or on a grid.","category":"page"},{"location":"theory/algorithm/#References","page":"Localization","title":"References","text":"","category":"section"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[MV97]: Marzari, N. & Vanderbilt, D., Maximally localized generalized Wannier functions for composite energy bands, Physical Review B, 1997, 56, 12847","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[RMP]: Marzari, N.; Mostofi, A. A.; Yates, J. R.; Souza, I. & Vanderbilt, D., Maximally localized Wannier functions: Theory and applications, Reviews of Modern Physics, 2012, 84, 1419","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[SMV01]: Souza, I.; Marzari, N. & Vanderbilt, D., Maximally localized Wannier functions for entangled energy bands, Physical Review B, 2001, 65, 035109","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[DLL19]: Damle, A.; Levitt, A. & Lin, L., Variational Formulation for Wannier Functions with Entangled Band Structure, Multiscale Modeling & Simulation, 2019, 17, 167","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[GLS19]: Gontier, D.; Levitt, A. & Siraj-dine, S., Numerical construction of Wannier functions through homotopy, Journal of Mathematical Physics, 2019, 60, 031901","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[QPM21]: Qiao, J.; Pizzi, G. & Marzari, N., Projectability disentanglement for accurate high-throughput Wannierization, xxx","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[QMP21]: Qiao, J.; Marzari, N. & Pizzi, G., Automated separate Wannierization for valence and conduction manifolds, xxx","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[DL18]: Damle, A. & Lin, L., Disentanglement via Entanglement: A Unified Method for Wannier Localization Multiscale Modeling & Simulation, 2018, 16, 1392","category":"page"},{"location":"theory/algorithm/","page":"Localization","title":"Localization","text":"[WLPMM14]: Wang, R.; Lazar, E. A.; Park, H.; Millis, A. J. & Marianetti, C. A., Selectively localized Wannier functions, Physical Review B, 2014, 90, 165125","category":"page"},{"location":"api/interpolation/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"This page lists struct and functions for Wannier interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"There are two flavors of interpolation:","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"WS: the Wigner-Seitz interpolation\nMDRS: the Minimal-distance replica selection method","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"MDRS has better interpolation quality[WAN20], so it should be used in most cases. Moreover, we implement two versions of MDRS:","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"MDRSv1: the original version in Wannier90[WAN20].   This is slower than the WS interpolation.\nMDRSv2: a slightly modified version which removes some for loops, same as what is implemented   in Wannier Berri[WBERRI]. The speed is similar to the WS interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"By default, we use the MDRSv2 interpolation.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"CurrentModule = Wannier","category":"page"},{"location":"api/interpolation/#Contents","page":"Interpolation","title":"Contents","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Pages = [\"interpolation.md\"]\nDepth = 2","category":"page"},{"location":"api/interpolation/#Index","page":"Interpolation","title":"Index","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Pages = [\"interpolation.md\"]","category":"page"},{"location":"api/interpolation/#R-vectors","page":"Interpolation","title":"R vectors","text":"","category":"section"},{"location":"api/interpolation/#RVectors","page":"Interpolation","title":"RVectors","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nThe R vectors are automatically generated by calling either of these two approaches:read_w90_with_chk to read the Wannier90 output seedname.chk.fmt file,   and generate an InterpModel,\nInterpModel a constructor   to generate the InterpModel from a Wannierization Model.So usually the user does not need to call the following functions.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/rvector.jl\"]","category":"page"},{"location":"api/interpolation/#KRVectors","page":"Interpolation","title":"KRVectors","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"The KRVectors contains both kpoint mappings and RVectors, allowing both forward and inverse Fourier transform.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/krvector.jl\"]","category":"page"},{"location":"api/interpolation/#Fourier-transforms","page":"Interpolation","title":"Fourier transforms","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Performs Fourier transform between k and R spaces defined by KRVectors.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nIn general, the user only need to call the fourier(kRvectors, Oᵏ) and invfourier(kRvectors, Oᴿ, kpoints) functions directly, irrespective of the type of kRVectors. Other functions are internally used based on the type of KRVectors, thanks to multiple dispatch.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/fourier.jl\"]","category":"page"},{"location":"api/interpolation/#InterpModel","page":"Interpolation","title":"InterpModel","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"To separate the Wannier interpolation from Wannierization, we have another model, the InterpModel, which is solely for the purpose of interpolation, while Model works only for Wannierization.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/interp_model.jl\"]","category":"page"},{"location":"api/interpolation/#Band-structure","page":"Interpolation","title":"Band structure","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"warning: Warning\nNeed some care when comparing the band interpolation between Wannier.jl and Wannier90, after running the Wannier.jl disentanglement and writing an optimized amn file for Wannier90 to interpolate band structure.When Wannier90 read an amn file, it will (Wannier90 v3.1.0)Lowdin orthogonalize the amn matrices, in disentangle.F90:dis_project, line 1418  This should do no harm, since the optimized amn is already semi-unitary,  a SVD of it should not change the optimized amn (apart from numerical noise)\ngenerate a new amn according to the frozen window, in disentangle.F90:dis_proj_froz,  line 1830. This will DESTROY the optimized amn matrices, if we restart  Wannier90 from the optimized amn with dis_num_iter = 0, the spreads in wout file  is very different from the output of Wannier.jl, we must skip this step by commenting  out ALL the dis_froz_min/max in the win file, then  use Wannier90 to interpolate bands, remember also set num_iter and dis_num_ite = 0.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/hamiltonian.jl\"]","category":"page"},{"location":"api/interpolation/#Fermi-surface","page":"Interpolation","title":"Fermi surface","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"note: Note\nThe fermi_surface function will use WS or MDRS interpolation based on the type of Rvectors. However, Wannier90 only use WS interpolation when plotting Fermi surface (even if the use_ws_distance is set as true in the win file). So the fermi_surface function will output different result than Wannier90 if using MDRS.","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/fermisurf.jl\"]","category":"page"},{"location":"api/interpolation/#Derivatives","page":"Interpolation","title":"Derivatives","text":"","category":"section"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"Modules = [Wannier]\nPages   = [\"interp/derivative.jl\"]","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"[WAN20]: Pizzi, G.; Vitale, V.; Arita, R.; Blügel, S.; Freimuth, F.; Géranton, G.; Gibertini, M.; Gresch, D.; Johnson, C.; Koretsune, T.; Ibañez-Azpiroz, J.; Lee, H.; Lihm, J.-M.; Marchand, D.; Marrazzo, A.; Mokrousov, Y.; Mustafa, J. I.; Nohara, Y.; Nomura, Y.; Paulatto, L.; Poncé, S.; Ponweiser, T.; Qiao, J.; Thöle, F.; Tsirkin, S. S.; Wierzbowska, M.; Marzari, N.; Vanderbilt, D.; Souza, I.; Mostofi, A. A. & Yates, J. R., Wannier90 as a community code: new features and applications, Journal of Physics: Condensed Matter, 2020, 32, 165902","category":"page"},{"location":"api/interpolation/","page":"Interpolation","title":"Interpolation","text":"[WBERRI]: Tsirkin, S. S., High performance Wannier interpolation of Berry curvature and related quantities with WannierBerri code, npj Computational Materials, 2021, 7","category":"page"},{"location":"api/wannierize/#Wannierize","page":"Localization","title":"Wannierize","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"These are some Wannierization algorithms.","category":"page"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"CurrentModule = Wannier","category":"page"},{"location":"api/wannierize/#Contents","page":"Localization","title":"Contents","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Pages = [\"wannierize.md\"]\nDepth = 2","category":"page"},{"location":"api/wannierize/#Index","page":"Localization","title":"Index","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Pages = [\"wannierize.md\"]","category":"page"},{"location":"api/wannierize/#Disentanglement","page":"Localization","title":"Disentanglement","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/disentangle.jl\"]","category":"page"},{"location":"api/wannierize/#Maximal-localization","page":"Localization","title":"Maximal localization","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/max_localize.jl\"]","category":"page"},{"location":"api/wannierize/#Parallel-transport","page":"Localization","title":"Parallel transport","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\n    \"wannierize/parallel_transport/parallel_transport.jl\",\n    \"wannierize/parallel_transport/contraction.jl\",\n]","category":"page"},{"location":"api/wannierize/#Optimal-rotation","page":"Localization","title":"Optimal rotation","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/opt_rotate.jl\"]","category":"page"},{"location":"api/wannierize/#Splitting-the-Model","page":"Localization","title":"Splitting the Model","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/split.jl\"]","category":"page"},{"location":"api/wannierize/#Co-optimization-of-spin-polarized-WFs","page":"Localization","title":"Co-optimization of spin-polarized WFs","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/coopt.jl\"]","category":"page"},{"location":"api/wannierize/#Constraining-WF-centers","page":"Localization","title":"Constraining WF centers","text":"","category":"section"},{"location":"api/wannierize/#Disentanglement-2","page":"Localization","title":"Disentanglement","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/disentangle.jl\"]","category":"page"},{"location":"api/wannierize/#Maximal-localization-2","page":"Localization","title":"Maximal localization","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/max_localize.jl\"]","category":"page"},{"location":"api/wannierize/#Co-optimization-of-spin-polarized-WFs-2","page":"Localization","title":"Co-optimization of spin-polarized WFs","text":"","category":"section"},{"location":"api/wannierize/","page":"Localization","title":"Localization","text":"Modules = [Wannier]\nPages   = [\"wannierize/constrain_center/coopt.jl\"]","category":"page"},{"location":"theory/discretization/#Discretization-of-reciprocal-space","page":"k-space Discretization","title":"Discretization of reciprocal space","text":"","category":"section"},{"location":"theory/initial_projection/#Initial-projection-for-plane-wave-DFT-codes","page":"Initial projection","title":"Initial projection for plane-wave DFT codes","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Here I write down the formulae for initial projection in plane-wave DFT codes, e.g., as implemented in DFTK.jl or Quantum ESPRESSO.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"In essence, the initial projection A_m n mathbfk is the inner product between the Bloch wavefunction psi_m mathbfk(mathbfr) and some initial guess phi_n mathbfk(mathbfr),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"A_m n mathbfk = langle psi_m mathbfk  phi_n mathbfk rangle","category":"page"},{"location":"theory/initial_projection/#Bloch-wavefunction","page":"Initial projection","title":"Bloch wavefunction","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The Bloch wavefunction is expanded in plane waves,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"psi_m mathbfk(mathbfr) = frac1sqrtV sum_mathbfG\n  c_m mathbfk(mathbfG) e^i (mathbfk + mathbfG) mathbfr","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where V is the volume of the unit cell, the sum is over the plane-wave expansions (integer multiples of reciprocal lattice vectors) mathbfG, which are limited by the energy cutoff E_mathrmcut,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"frachbar^22 m_e  mathbfk + mathbfG ^2 leq E_mathrmcut","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where m_e is the electron mass. The coefficients c_m mathbfk(mathbfG) are obtained from DFT calculations.","category":"page"},{"location":"theory/initial_projection/#Localized-atomic-orbitals","page":"Initial projection","title":"Localized atomic orbitals","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Usually we choose some atomic orbitals as the initial projections, given by a product of radial function R(r) times spherical harmonics Y_l m(theta phi),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"f(mathbfr) = R(r) Y_l m(theta phi)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where mathbfr is the vector and r = mathbfr is its norm; theta and phi are the polar and azimuthal angles or mathbfr, respectively; l and m are the angular momentum, and the Y_l m(theta phi) are the real spherical harmonics (as a comparison, we use the notation Y_l^m(theta phi) for the complex spherical harmonics, see [SphHarm]).","category":"page"},{"location":"theory/initial_projection/#Bloch-sum","page":"Initial projection","title":"Bloch sum","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The atomic orbitals do not have the periodicity of the lattice, so we need to sum over the lattice to obtain the Bloch sum of the localized atomic orbitals,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"phi_mathbfk(mathbfr) = frac1N sqrtV sum_mathbfR\n  e^i mathbfk mathbfR f(mathbfr - mathbfR)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where N is the number of unit cells in the supercell (determined by the k-point mesh), V is the volume of unit cell, and mathbfR labels the unit cell inside the supercell.","category":"page"},{"location":"theory/initial_projection/#Fourier-transform-to-plane-waves","page":"Initial projection","title":"Fourier transform to plane waves","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"To obtain the inner product between the Bloch wavefunction and the Bloch sum of the localized atomic orbitals, we need to Fourier transform the Bloch sum to plane waves, i.e., compute inner product in mathbfG-vector space.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"For a wavefunction having a form of radial functions times spherical harmonics, i.e., f(mathbfr) = R(r) Y_l m(theta phi), its Fourier transform hatf( mathbfq ) can be computed by","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nhatf(mathbfq)\n= int_mathbb R^3 e^-i mathbfq cdot mathbfr f(mathbfr) dmathbfr \n= 4 pi Y_l m(mathbfqq) (-i)^l\n  int_mathbb R^+ r^2 R(r)  j_l(q r) dr\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where q = mathbfq, and j_l(x) is the spherical Bessel function of the first kind [SphBess].","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Here we have used the plane wave expansion in spherical harmonics [PwExpand] (valid for both complex and real spherical harmonics),","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\n  e^i mathbfq cdot mathbfr\n= 4 pi sum_l=0^infty sum_m=-l^l\n    i^l j_l(q r) Y_l^m(mathbfqq) Y_l^m*(mathbfrr) \n= 4 pi sum_l=0^infty sum_m=-l^l\n    i^l j_l(q r) Y_l m(mathbfqq) Y_l m(mathbfrr)\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"For e^-i mathbfq cdot mathbfr, due to the parity of spherical harmonics, Y_l^m(- mathbfr ) = (-1)^l Y_l^m( mathbfr ) (also hold true for real spherical harmonics Y_l m(- mathbfr ) = (-1)^l Y_l m( mathbfr )), the i^l in the expression of e^i mathbfq cdot mathbfr becomes (-i)^l in that of e^-i mathbfq cdot mathbfr.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"note: Note\nTo really convince you that there should be a minus sign, I created a notebook which includes some numerical tests, click here to download.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Now, using the orthogonality of spherical harmonics,","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"int_theta = 0^pi int_phi=0^2pi\nY_l^m Y_l^prime^m^prime * dOmega\n= delta_l l^prime delta_m m^prime","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"we reach the expression of hatf(mathbfq). Note in the above equation dOmega = sin theta dtheta dphi is the solid angle element, and dV = r^2 dr dOmega is the volume element.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Note that alternatively, we can use Hankel transform to reach the same result, see Appendix: Hankel transform.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Thus, f(mathbfr) can be expanded as","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"f(mathbfr) = frac1(2pi)^3 int dmathbfq hatf(mathbfq)\nexp(i mathbfq cdot mathbfr)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Then the Fourier transform of the Bloch sum is","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nphi_mathbfk(mathbfq)\n= mathcalF_mathbfr rightarrow mathbfq\n   phi_mathbfk (mathbfr - mathbftau)  \n= mathcalF  frac1N sqrtV\n  sum_mathbfR exp(i mathbfk mathbfR)\n  f(mathbfr - mathbftau - mathbfR)  \n= frac1N sqrtV sum_mathbfR\n  exp(i mathbfk mathbfR)\n  mathcalF  f(mathbfr - mathbftau - mathbfR)  \n= frac1N sqrtV sum_mathbfR\n  exp(i mathbfk mathbfR)\n  hatf(mathbfq) exp(-i mathbfq (mathbftau + mathbfR) )\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where mathbftau = (tau_x tau_y tau_z) is the center of the orbital.","category":"page"},{"location":"theory/initial_projection/#Inner-product","page":"Initial projection","title":"Inner product","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Now we can compute the initial projection A_m n mathbfk. Note that the Bloch state psi_n mathbfk(mathbfr) are actually a sum over e^i (mathbfk + mathbfG) mathbfr, so we need to set the mathbfq in phi_mathbfk(mathbfq) to mathbfk + mathbfG so that the inner product is on the same basis functions.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"phi_mathbfk(mathbfk + G)\n= frac1sqrtV exp(-i (mathbfk + G) mathbftau )\n  hatf(mathbfk + G)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Since the localized orbitals f(mathbfr) might not be normalized, often we apply Löwdin orthonormalization on the mathbfq-space wavefunction phi_mathbfk(mathbfq) at each mathbfk-point.","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"Finally, the initial projection is","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nA_m n mathbfk\n= psi_m mathbfk^* phi_n mathbfk \n= sum_mathbfG c_m mathbfk(mathbfG)^* phi_n mathbfk(mathbfk + G)\nendaligned","category":"page"},{"location":"theory/initial_projection/#Appendix:-Hankel-transform","page":"Initial projection","title":"Appendix: Hankel transform","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"The Fourier transform of f(mathbfr) can also be obtained using Hankel transform [Hankel],","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nF_nu (k) = int _0^infty  f(r) J_nu (kr) r  mathrmd r \nf(r) = int _0^infty  F_nu (k) J_nu (kr) k  mathrmd k\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where nu in mathbbC, J_nu (x) is the Bessel function; for integer n, the spherical Bessel function j_n(x) is related to the Bessel function by","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"j_n(x) = sqrt frac pi 2x J_n + frac12(x)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"By using the relation between Fourier transform and Hankel transform [Hankel], we can write the Fourier transform as","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"hatf(mathbfq) = (2pi)^frac32 (-i)^l R_l(q) Y_l m(mathbfqq)","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"where","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"beginaligned\nR_l(q)\n= frac1sqrtq int_mathbb R^+ sqrtr R(r) J_l+frac12(q r) r dr \n= sqrtfrac2pi int_mathbb R^+ r^2 R(r)  j_l(q r) dr\nendaligned","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"restoring the same equation.","category":"page"},{"location":"theory/initial_projection/#References","page":"Initial projection","title":"References","text":"","category":"section"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[SphHarm]: https://en.wikipedia.org/wiki/Spherical_harmonics#Real_form","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[SphBess]: https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[PwExpand]: https://en.wikipedia.org/wiki/Plane-wave_expansion","category":"page"},{"location":"theory/initial_projection/","page":"Initial projection","title":"Initial projection","text":"[Hankel]: https://en.wikipedia.org/wiki/Hankel_transform","category":"page"},{"location":"api/util/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"These are some simple convenience functions to smoothen developer experience.","category":"page"},{"location":"api/util/","page":"Utility","title":"Utility","text":"CurrentModule = Wannier","category":"page"},{"location":"api/util/#Contents","page":"Utility","title":"Contents","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Pages = [\"util.md\"]\nDepth = 2","category":"page"},{"location":"api/util/#Index","page":"Utility","title":"Index","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Pages = [\"util.md\"]","category":"page"},{"location":"api/util/#Structure","page":"Utility","title":"Structure","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/structure.jl\"]","category":"page"},{"location":"api/util/#Matrices","page":"Utility","title":"Matrices","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/linalg.jl\"]","category":"page"},{"location":"api/util/#Kpoint","page":"Utility","title":"Kpoint","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/kpoint.jl\"]","category":"page"},{"location":"api/util/#Kpath","page":"Utility","title":"Kpath","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"The KPath and KPathInterpolant are defined in Brillouin.jl, they are used to store the high-symmetry kpoints and their labels.","category":"page"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/kpath.jl\"]","category":"page"},{"location":"api/util/#Centers","page":"Utility","title":"Centers","text":"","category":"section"},{"location":"api/util/","page":"Utility","title":"Utility","text":"Modules = [Wannier]\nPages   = [\"util/center.jl\"]","category":"page"},{"location":"api/io/#Input/Output","page":"Input/Output","title":"Input/Output","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"CurrentModule = Wannier","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"The reading and writing functions are implemented in the WannierIO.jl package. However, here are also some convenience functions which wrap the corresponding functions in WannierIO.jl, to utilize the structs defined in Wannier90.jl, e.g. KspaceStencil, RGrid, etc.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nIn most cases, the units of the function arguments and returns are in angstrom unit for lattice, and fractional w.r.t lattice for atomic positions, etc.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nThe following abbreviations are used throughout the code and documentation:n_bands for number of bands\nn_wann for number of WFs\nn_kpts for number of kpoints\nn_bvecs for number of b-vectors\nn_atoms for number of atoms\nU for amn or the gauge matrices\nM for mmn matrices\nE for eig matrices\nS for spn matrices","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"note: Note\nIn most cases, for arrays we adopt the convention that n_bands is the first index, n_wann is the second index, and n_kpts is the third index. For example, U for the gauge matrices is a 3D array of size (n_bands, n_wann, n_kpts).","category":"page"},{"location":"api/io/#Contents","page":"Input/Output","title":"Contents","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Pages = [\"io.md\"]\nDepth = 2","category":"page"},{"location":"api/io/#Index","page":"Input/Output","title":"Index","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Pages = [\"io.md\"]","category":"page"},{"location":"api/io/#Wannier90-files","page":"Input/Output","title":"Wannier90 files","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/w90/amn.jl\",\n    \"io/w90/band.jl\",\n    \"io/w90/chk.jl\",\n    \"io/w90/model.jl\",\n    \"io/w90/nnkp.jl\",\n    \"io/w90/tb.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.read_amn_ortho-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_amn_ortho","text":"read_amn_ortho(filename)\n\n\nRead amn file and Lowdin orthonormalize the unitary matrices.\n\nThe U matrix for Wannier functions must be unitary or semi-unitary. Thus, in most cases, this function should be used instead of WannierIO.read_amn, where the latter one just parse the amn file and return whatever is in it.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.generate_w90_kpoint_path-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}","page":"Input/Output","title":"Wannier.generate_w90_kpoint_path","text":"generate_w90_kpoint_path(\n    recip_lattice,\n    kpoints,\n    symm_point_indices,\n    symm_point_labels\n)\n\n\nGenerate a KPathInterpolant from the kpoint coordinates and high-symmetry kpoints.\n\nThe WannierIO.read_w90_band(prefix) function returns the required arguments of this function.\n\nArguments\n\nrecip_lattice: each column is a reciprocal lattice vector in Å\nkpoints: list of kpoint coordinates along a kpath, fractional coordinates\nsymm_point_indices: indices of the high-symmetry kpoints\nsymm_point_labels: labels of the high-symmetry kpoints\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.get_symm_point_indices_labels-Tuple{Brillouin.KPaths.KPathInterpolant}","page":"Input/Output","title":"Wannier.get_symm_point_indices_labels","text":"get_symm_point_indices_labels(kpi)\n\n\nReturn the symmetry indices and labels.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_w90_kpt_label-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant}","page":"Input/Output","title":"Wannier.write_w90_kpt_label","text":"write_w90_kpt_label(prefix, kpi)\n\n\nWrite kpoints into wannier90 formats: prefix_band.kpt, prefix_band.labelinfo.dat.\n\nArguments\n\nprefix: the prefix of the output files prefix_band.kpt and prefix_band.labelinfo.dat\nkpi: a KPathInterpolant object\n\ntip: Tip\nThis allows auto generating the high-symmetry kpoints and labels from crystal structure using generate_kpath, writing them into files. Then other codes can use the kpoints for band structure calculations, e.g., QE pw.x bands calculation, or in the win input file for Wannier90.\n\nExample\n\nwin = read_win(\"si2.win\")\nkp = generate_kpath(win.unit_cell_cart, win.atoms_frac, win.atom_labels)\nkpi = Wannier.generate_w90_kpoint_path(kp, 100)\nWannier.write_w90_kpt_label(\"si2\", kpi)\n\n\n\n\n\n","category":"method"},{"location":"api/io/#WannierIO.read_w90_band-Tuple{AbstractString, AbstractMatrix}","page":"Input/Output","title":"WannierIO.read_w90_band","text":"read_w90_band(prefix, recip_lattice)\n\n\nArguments\n\nrecip_lattice: each column is a reciprocal lattice vector in Å.\n\nReturn\n\nkpi: a KPathInterpolant object\neigenvalues: the eigenvalues of the band structure\n\nnote: Note\nThe WannierIO.read_w90_band(prefix) function returns a NamedTuple containing basis variables such as kpoints, symm_point_indices, etc. Here, once we know the recip_lattice, we can generate a KPathInterpolant which can be used directly in plotting functions.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#WannierIO.write_w90_band-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant, AbstractVector}","page":"Input/Output","title":"WannierIO.write_w90_band","text":"write_w90_band(prefix, kpi, eigenvalues)\n\n\nWrite prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat.\n\nThis is a more user-friendly version that works with KPathInterpolant; the WannierIO.write_w90_band(prefix; kwargs...) is the low-level version.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.Model-Tuple{WannierIO.Chk}","page":"Input/Output","title":"Wannier.Model","text":"Model(chk; kmesh_tol)\n\n\nConstruct a Model from a WannierIO.Chk struct.\n\nArguments\n\nchk: a WannierIO.Chk struct\n\nwarning: Warning\nThe Chk struct does not contain eigenvalues, and the Model.E will be set to zeros.Moreover, the M matrix in Chk is already rotated by the gauge transformation, thus by default, the U matrix is set to identity. Note that although maximal localization, or disentanglement (after frozen states are chosen), do not require eigenvalues (so the user can still Wannierize the Model), it is required when writing the Model to a chk file, in write_chk.Additionally, be careful that the M matrix is rotated, and this rotation needs to make sure that the rotated Hamiltonian is diagonal so that E stores the diagonal eigenvalues of the Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#WannierIO.write_chk","page":"Input/Output","title":"WannierIO.write_chk","text":"write_chk(filename, model; ...)\nwrite_chk(\n    filename,\n    model,\n    gauges;\n    exclude_bands,\n    binary,\n    header\n)\n\n\nWrite a Model to a wannier90 chk file.\n\nArguments\n\nfilename: filename of the .chk file\nmodel: a Model struct\nU: gauge transformation matrices, default is model.U.\n\nKeyword Arguments\n\nexclude_bands: a list of band indices to be excluded.\nbinary: write the chk file in binary format\nheader: header of the chk file\n\nnote: Note\nThe exclude_bands is totally not used throughout the code. However, if one want to use wannier90 to restart from the written chk file, the exclude_bands must be consistent with that in wannier90 win file. The wannier90 exclude_bands input parameter in only used in the pw2wannier90 step to remove some bands (usually semicore states) when computing amn/mmn/eig files, therefore this exclude_bands is totally irrelevant to our Model struct.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.read_w90-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_w90","text":"read_w90(prefix; ortho_amn)\n\n\nRead win file, and read amn, mmn, eig files if they exist.\n\nKeyword arguments\n\northo_amn: Lowdin orthonormalization after reading amn matrices.   Should be true for most cases, since usually the input amn matrices are   not guaranteed to be unitary or semi-unitary.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_w90_with_chk","page":"Input/Output","title":"Wannier.read_w90_with_chk","text":"read_w90_with_chk(prefix)\nread_w90_with_chk(prefix, chk)\n\n\nReturn a Model with U matrix filled by that from a chk file.\n\nArguments\n\nchk: path of chk file to get the unitary matrices.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.write_w90-Tuple{AbstractString, Wannier.Model}","page":"Input/Output","title":"Wannier.write_w90","text":"write_w90(prefix, model; binary)\n\n\nWrite Model into eig, mmn, amn files.\n\nKeyword arguments\n\nbinary: write eig, mmn, and amn in Fortran binary format\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_nnkp_compute_bweights-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_nnkp_compute_bweights","text":"read_nnkp_compute_bweights(filename)\n\n\nRead the nnkp file.\n\nThis function calls WannierIO.read_nnkp to parse the file, compute the bweights of b-vectors, and returns a KspaceStencil (while WannierIO.read_nnkp only returns a NamedTuple).\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_nnkp-Tuple{AbstractString, Wannier.KspaceStencil}","page":"Input/Output","title":"Wannier.write_nnkp","text":"write_nnkp(filename, kstencil; kwargs...)\n\n\nWrite nnkp that can be used by pw2wannier90.\n\nArguments\n\nfilename: the filename to write to\nkstencil: a KspaceStencil object\n\ntip: Tip\nSome important tags in nnkp file (can be passed as keyword arguments):n_wann: the number of WFs, needed by pw2wannier90\nexclude_bands: the bands (often semicore states) to exclude, needed by   pw2wannier90For other keyword arguments, see WannierIO.write_nnkp.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier._raw_read_w90_tb-Tuple{AbstractString}","page":"Input/Output","title":"Wannier._raw_read_w90_tb","text":"Only read tb files, without further processing\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_w90_tb-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_w90_tb","text":"read_w90_tb(prefix)\n\n\nRead prefix_tb.dat and prefix_wsvec.dat and construct tight-binding models.\n\nArguments\n\nprefix: the prefix of prefix_tb.dat and prefix_wsvec.dat\n\nReturn\n\na TBHamiltonian\na TBPosition\n\nnote: Note\nThis will call simplify to absorb the R-vector degeneracies and T-vectors into the operator, leading to faster interpolations.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_w90_tb-Tuple{AbstractString, TBOperator, TBOperator}","page":"Input/Output","title":"Wannier.write_w90_tb","text":"write_w90_tb(prefix, hamiltonian, position)\n\n\nWrite a tight-binding model of Hamiltonian and position operator into prefix_tb.dat and prefix_wsvec.dat files.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#File-manipulation","page":"Input/Output","title":"File manipulation","text":"","category":"section"},{"location":"api/io/#Truncate-Wannier90-matrices","page":"Input/Output","title":"Truncate Wannier90 matrices","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"tip: Tip\nHere are some functions to remove some bands from mmn, eig, or UNK files, so as to skip rerunning NSCF calculations and pw2wannier90.x.","category":"page"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\"io/truncate.jl\"]","category":"page"},{"location":"api/io/#Wannier.truncate-Union{Tuple{T}, Tuple{Wannier.Model, T}, Tuple{Wannier.Model, T, Union{Nothing, AbstractVector{Int64}, T}}} where T<:AbstractVector{Int64}","page":"Input/Output","title":"Wannier.truncate","text":"truncate(model::Model, keep_bands::Vector{Int}, keep_wfs::Vector{Int}=nothing;\n    orthonorm_U::Bool=true)\n\nTruncate U, M, E matrices in model.\n\nArguments\n\nmodel: the Model to be truncated.\nkeep_bands: Band indexes to be kept, start from 1.\nkeep_wfs: WF indexes to be kept, start from 1. If nothing, keep all.\n\nKeyword arguments\n\northonorm_U: If true, Lowdin orthonormalize U after truncation.   The U needs to be (semi-)unitary, so it should always be true.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.truncate_mmn_eig","page":"Input/Output","title":"Wannier.truncate_mmn_eig","text":"truncate_mmn_eig(seedname, keep_bands::Vector{Int}, outdir=\"truncate\")\n\nTruncate number of bands of mmn and eig files.\n\nArguments\n\nkeep_bands: a vector of band indices to keep, starting from 1.\noutdir: the folder for writing mmn and eig files.\n\ntip: Tip\nThis is useful for generating valence only mmn, eig files from a valence+conduction NSCF calculation, so that no need to recompute NSCF with lower number of bands again.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.truncate_unk","page":"Input/Output","title":"Wannier.truncate_unk","text":"truncate_unk(dir, keep_bands::Vector{Int}, outdir=\"truncate\"; binary=true)\n\nTruncate UNK files for specified bands.\n\nArguments\n\ndir: folder of UNK files.\nkeep_bands: the band indexes to keep. Start from 1.\noutdir: folder to write output UNK files.\nbinary: whether to write binary UNK files.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#Wannier.truncate_w90","page":"Input/Output","title":"Wannier.truncate_w90","text":"truncate_w90(seedname, keep_bands::Vector{Int}, outdir=\"truncate\", unk=false)\n\nTruncate mmn, eig, and optionally UNK files.\n\nArguments\n\nseedname: seedname for input mmn and eig files.\nkeep_bands: Band indexes to be kept, start from 1.\nunk: If true also truncate UNK files.\noutdir: folder for output files.\n\n\n\n\n\n","category":"function"},{"location":"api/io/#D-visualization-files","page":"Input/Output","title":"3D visualization files","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/volume/xsf.jl\",\n    \"io/volume/bxsf.jl\",\n    \"io/volume/cube.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.read_xsf-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_xsf","text":"read_xsf(filename::AbstractString)\n\nRead xsf file.\n\nReturn\n\nprimvec: 3 * 3, Å, each column is a primitive lattice vector\nconvvec: 3 * 3, Å, each column is a conventional lattice vector\natoms: n_atoms String, atomic symbols or numbers\natom_positions: 3 * n_atoms, Å, cartesian coordinates\nrgrid: RGrid, grid on which W is defined\nW: nx * ny * nz, volumetric data\n\nnote: Note\nOnly support reading 1 datagrid in BLOCK_DATAGRID_3D.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, Wannier.RGrid, AbstractArray{T, 3}}} where T<:Real","page":"Input/Output","title":"Wannier.write_xsf","text":"write_xsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)\n\nWrite xsf file.\n\nArguments\n\nlattice: 3 * 3, Å, each column is a lattice vector\natom_positions: 3 * n_atoms, fractional coordinates\natom_numbers: n_atoms, atomic numbers\nrgrid: RGrid\nW: nx * ny * nz, volumetric data\n\nThis is a more user-friendly version. The rgrid contains the information of the grid origin and spanning vectors.\n\nSee also WannierIO.write_xsf\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_bxsf-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_bxsf","text":"read_bxsf(filename::AbstractString)\n\nRead bxsf file.\n\nReturn\n\nrgrid: RGrid, grid on which E is defined\nfermi_energy: in eV\nE: n_bands * n_kx * n_ky * n_kz, energy eigenvalues\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, Wannier.RGrid, T, AbstractArray{T, 4}}} where T<:Real","page":"Input/Output","title":"Wannier.write_bxsf","text":"write_bxsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)\n\nWrite bxsf file.\n\nArguments\n\nrgrid: RGrid\nfermi_energy: in eV\nE: n_bands * n_kx * n_ky * n_kz, energy eigenvalues\n\nThis is a more user-friendly version. The rgrid contains the information of the grid origin and spanning vectors.\n\nSee also WannierIO.write_bxsf\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.read_cube-Tuple{AbstractString}","page":"Input/Output","title":"Wannier.read_cube","text":"read_cube(filename::AbstractString)\n\nRead cube file.\n\nnote: Note\nBy default, cube use Bohr unit, here all returns are in Cartesian coordinates, Å unit.\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T<:Real","page":"Input/Output","title":"Wannier.write_cube","text":"write_cube(filename, lattice, atom_positions, atom_numbers, wf_center, rgrid, W; radius=4.0)\n\nWrite cube file for WF.\n\nArguments\n\nlattice: each column is a lattice vector, Å\natom_positions: 3 * n_atoms, fractional coordinates\natom_numbers: n_atoms, atomic numbers\nwf_centers: 3, fractional coordinates w.r.t. lattice\nrgrid: RGrid\nW: nx * ny * nz, volumetric data\n\nKeyword arguments\n\nradius: Å. Periodic replica of atoms are written only for the region   within radius Å from wf_center.\n\nSee also write_cube(filename, filename, atom_positions, atom_numbers, origin, span_vectors, W)\n\n\n\n\n\n","category":"method"},{"location":"api/io/#Interface-to-DFT-codes","page":"Input/Output","title":"Interface to DFT codes","text":"","category":"section"},{"location":"api/io/","page":"Input/Output","title":"Input/Output","text":"Modules = [Wannier]\nPages   = [\n    \"io/interface/mud.jl\",\n]","category":"page"},{"location":"api/io/#Wannier.compute_mud-Tuple{AbstractString, AbstractString}","page":"Input/Output","title":"Wannier.compute_mud","text":"compute_mud(dir_up, dir_dn)\n\nCompute the overlap matrix between spin up and down from UNK files.\n\nM^uparrowdownarrow_m n bmk =\nlangle u^uparrow_m bmk  u^downarrow_n bmk rangle\n\nThis function compute mud matrix in real space (thus much slower), checked with QE pw2wannier90.x function which computes mud in reciprocal space, the difference is on the order of 1e-13.\n\nwarning: Warning\nThis only works for norm-conserving pseudopotentials since in that case the overlap operator is just identity; for ultrasoft or PAW, a simple dot product is not enough. Also I assume the UNK files are written with a normalization factor of N (total points of the FFT grid) over the unit cell, i.e., the UNK generated by QE pw2wannier90.x. If the UNK files are normalized to 1, the result should be multiplied by N.\n\nArguments\n\ndir_up: directory of spin up UNK files\ndir_dn: directory of spin down UNK files\n\n\n\n\n\n","category":"method"},{"location":"theory/normalization/#Normalization-convention-of-WFs","page":"Normalization","title":"Normalization convention of WFs","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"There are several different conventions for Fourier transform, this page describes the normalization convention used in Wannier.jl. In short, we adopt the same convention as the Section II 3 of [RMP].","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"For a unit cell having volume V, the Bloch functions  psi rangle are periodic in a super cell which is N times the unit cell (thus having volume NV), where N is determined by the discretization of the reciprocal space, i.e. the total number of kpoints.","category":"page"},{"location":"theory/normalization/#Continuous-case","page":"Normalization","title":"Continuous case","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"If the super cell is large enough (N to infty), then the kpoint bmk is a continuous variable in the reciprocal cell having volume frac(2pi)^3V. The inner product between bra and ket langle f  g rangle are integrated over the the NV super cell that is (-infty infty) in the continuous case. If we normalize the Bloch functions over one unit cell, that is,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"langle psi_n bmk  psi_n bmk rangle_V\n= int_V  u_n bmk(bmr) ^2 bmr = 1","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"where psi_n bmk = exp(i bmk bmr) u_n bmk(bmr), then the inner product between bra and ket is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"langle psi_n bmk  psi_m bmk^prime rangle\n= frac(2pi)^3V delta_n m delta(bmk - bmk^prime)","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"This can be proven, e.g. in 1D with periodicity bmR, by","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle psi_n bmk  psi_m bmk^prime rangle\n= int_-infty^+infty psi_n bmk^* psi_m bmk^prime dbmr \n=  int_-infty^+infty exp(i (bmk^prime - bmk) bmr)\n    u_n bmk^*(bmr) u_m bmk^prime(bmr) dbmr \n=  sum_l = -infty^+infty int_l bmR^(l+1) bmR d(bmr + l bmR)\n    exp(i (bmk^prime - bmk) (bmr + l bmR))\n    u_n bmk^*(bmr + l bmR) u_m bmk^prime(bmr + l bmR) \n=  sum_l = -infty^+infty exp(i (bmk^prime - bmk) l bmR)\n    int_0^bmR dbmr exp(i (bmk^prime - bmk) bmr)\n    u_n bmk^*(bmr) u_m bmk^prime(bmr) dbmr \n=  frac2pibmR operatornametextШ_frac2pibmR(bmk^prime - bmk)\n    int_0^bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  frac2pibmR delta(bmk - bmk^prime) delta_n m\nendaligned","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the third line of the above equation, we replace the real space coordinate bmr by bmr + l bmR, such that bmr in 0 bmR). In the fourth line, we utilize the real space periodicity of u_n bmk. In the second last line, the Dirac comb operatornametextШ_T(t) having periodicity T can be expanded as a Fourier series","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"operatorname textШ _T(t) =\nfrac 1T sum _n=-infty ^infty e^i2pi nfrac tT","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the last line, the Bloch function  psi rangle is periodic in bmk thus the Dirac comb is reduced to a Dirac delta function delta(bmk - bmk^prime), and of course the normalization of  psi rangle over one unit cell is used in the last line.","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Thus, the Bloch functions are orthogonal w.r.t. bmk only in the super cell, they are not orthogonal when only integrating over one unit cell.","category":"page"},{"location":"theory/normalization/#Discretized-case","page":"Normalization","title":"Discretized case","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"For finite sampling of reciprocal space, e.g. a 1D cell of periodicity bmR, sampled by N kpoints, then bmk = frac2pibmRfracnN n = 0 1  N-1. The inner product between bra and ket is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle psi_n bmk  psi_m bmk^prime rangle\n= int_0^N bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  sum_l = 0^N-1 exp(i (bmk^prime - bmk) l bmR)\n    int_0^bmR psi_n bmk^* psi_m bmk^prime dbmr \n=  N delta_bmkbmk^prime delta_n m\nendaligned","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"The second last line uses the fact that the discrete Fourier transform of Dirac delta function is 1,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"mathcal F(delta_n)_k =\n    sum_n=0^N-1 delta_n cdot e^-fraci2pi N kn\n    = 1 k = 0 1  N-1","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"so that the delta function can be represented by","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"delta_n = frac1N sum_k=0^N-1 e^fraci2pi N kn","category":"page"},{"location":"theory/normalization/#Real-space-representation","page":"Normalization","title":"Real space representation","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"In the discrete case, the WFs are the discrete Fourier transform of the Bloch function,","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":" bmR n rangle = frac1N sum_bmk\n    e^-i bmk bmR  psi_n bmk rangle","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Note the factor frac1N is multiplied in the forward transform, while the inverse transform is","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":" psi_n bmk rangle = sum_bmk e^i bmk bmR  bmR n rangle","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"Then the orthonormalization relation of WFs are (note the inner product is integrated over the super cell NV)","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"beginaligned\n langle bmR n  bmR^prime m rangle \n=  frac1N^2 sum_bmkbmk^prime e^i bmk bmR - i bmk^prime bmR^prime\n    langle psi_n bmk  psi_m bmk^prime rangle \n=  frac1N^2 sum_bmkbmk^prime e^i bmk bmR - i bmk^prime bmR^prime\n    N delta_bmkbmk^prime delta_n m \n=  frac1N delta_n m sum_bmk e^i bmk (bmR - bmR^prime) \n=  frac1N delta_n m N delta_bmR bmR^prime\n= delta_n m delta_bmR bmR^prime\nendaligned","category":"page"},{"location":"theory/normalization/#Implementation-details","page":"Normalization","title":"Implementation details","text":"","category":"section"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"The UNK files (generated by QE pw2wannier90.x) are not normalized to 1 in the unit cell (instead to N = N_x times N_y times N_z, where N_x N_y N_z are the number of points of the real space grid), so we need to multiply a factor of frac1sqrtN. This is done in the read_realspace_wf function.\nwarning: Warning\nThis means for other DFT codes to interface with Wannier.jl, the output UNKs need to be normalized to N in the unit cell, otherwise the real space computations, e.g., center(rgrid::RGrid, W::AbstractArray), are wrong!\nThen calculating the WF center in real space can be easily achieved in center(rgrid::RGrid, W::AbstractArray).\nnote: Note\nThis is not as accurate as computing WF center in reciprocal space, unless you have a dense real space sampling (usually determined by the energy cutoff in plane-wave code), and generate the real space WF in the NV-sized super cell (the WF lives in the super cell!).\nHowever, Wannier90 does not consider this factor when writing xsf or cube files, so we remove the factor in write_realspace_wf function, such that\nthe output file is consistent with Wannier90 output.\nanother advantage is that WF is normalized in one unit cell, so the numbers in the xsf are not too small.\nnote: Note\nSomehow the Wannier90 output xsf or cube is on a slightly shifted grid, in write_realspace_wf we just output the WF on the unshifted grid so that the origin of the WF 3D mesh is the same as the lattice origin (or its periodic replicas translated by lattice vectors).","category":"page"},{"location":"theory/normalization/","page":"Normalization","title":"Normalization","text":"[RMP]: Marzari, N.; Mostofi, A. A.; Yates, J. R.; Souza, I. & Vanderbilt, D., Maximally localized Wannier functions: Theory and applications, Reviews of Modern Physics, 2012, 84, 1419","category":"page"},{"location":"#Wannier.jl","page":"Home","title":"Wannier.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for playing with Wannier functions (WFs), including","category":"page"},{"location":"","page":"Home","title":"Home","text":"Generation of WFs from density functional theory (DFT) calculations\nWannier interpolation of operators, e.g. band structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"The purpose of this package is to write clean and modularized functions for Wannierization and Wannier interpolation, together with the expressive and interactive Julia language, to enable fast prototyping and development of new ideas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compared with Wannier90, the package provides different Wannierization algorithms using matrix manifold optimization. Currently, MPI is not supported, so probably not suitable for large systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is still under development, and the API is subject to change.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Wannierization\nmaximal localization for isolated bands, e.g. insulators\ndisentanglement for entangled bands, e.g. metal\nparallel transport gauge\nsplit valence and conduction WFs\nautomated initial projection for valence or conduction WFs\nconstrain WF center\nInterpolation of operators, e.g. band structure\nReal space WFs\noutput xsf or cube file\nevaluate operators in real space","category":"page"}]
}
