<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>B vector · Wannier.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Wannier.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../start/">Getting Started</a></li><li><span class="tocitem">Examples</span></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/algorithm/">Algorithm</a></li><li><a class="tocitem" href="../../theory/normalization/">Normalization</a></li><li><a class="tocitem" href="../../theory/initial_projection/">Initial projection</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../util/">Utility</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li class="is-active"><a class="tocitem" href>B vector</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#B-vector-shells-and-B-vectors"><span>B vector shells and B vectors</span></a></li></ul></li><li><a class="tocitem" href="../model/">Model</a></li><li><a class="tocitem" href="../wannierize/">Wannierize</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../realspace/">Real space</a></li><li><a class="tocitem" href="../cli/">Command line</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>B vector</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>B vector</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qiaojunfeng/Wannier.jl/blob/main/docs/src/api/bvector.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="B-vector"><a class="docs-heading-anchor" href="#B-vector">B vector</a><a id="B-vector-1"></a><a class="docs-heading-anchor-permalink" href="#B-vector" title="Permalink"></a></h1><p>The <span>$\bm{b}$</span>-vectors connect kpoint <span>$\bm{k}$</span> to its neighboring kpoints <span>$\bm{k}+\bm{b}$</span>, for calculating WF centers, spreads in reciprocal space.</p><p>The bvectors are first arranged in layers of shells, which contain bvectors having same norm. Then parallel shells are deleted, and the shells satisfying B1 condition are the final bvectors. At last, the bvectors are sorted at each kpoint, to reproduce exactly the same order as <code>Wannier90</code>. This ensures that we have the same order as <code>mmn</code> file.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To reproduce the same order as <code>Wannier90</code>, we need to be careful with some floating point comparison, i.e., the <code>atol</code> keyword arguments in the following functions. Their default value reproduce the <code>Wannier90</code> order. Note the <code>kmesh_tol</code> in the <code>win</code> file also influence the search of bvectors.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In most cases, the user only need to call <a href="#Wannier.get_bvectors-Tuple{Vector{&lt;:StaticArraysCore.SVector{3}}, StaticArraysCore.SMatrix{3, 3, &lt;:Real, 9}}"><code>get_bvectors</code></a> to generate bvectors having the same order as <code>Wannier90</code>. Other functions are intermediate steps that are called inside <code>get_bvectors</code>.</p></div></div><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#B-vector">B vector</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#B-vector-shells-and-B-vectors">B vector shells and B vectors</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Wannier.BVectorShells"><code>Wannier.BVectorShells</code></a></li><li><a href="#Wannier.BVectorShells-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, Any, Any, AbstractVector{T}}} where T&lt;:Real"><code>Wannier.BVectorShells</code></a></li><li><a href="#Wannier.BVectors"><code>Wannier.BVectors</code></a></li><li><a href="#Wannier._bvec_to_kb-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>Wannier._bvec_to_kb</code></a></li><li><a href="#Wannier._sort_kb-Tuple{AbstractVector, AbstractVector{Int64}, AbstractVector{StaticArraysCore.SVector{3, Int64}}, AbstractVector{StaticArraysCore.SVector{3, Int64}}}"><code>Wannier._sort_kb</code></a></li><li><a href="#Wannier.are_parallel-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.are_parallel</code></a></li><li><a href="#Wannier.check_b1-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T"><code>Wannier.check_b1</code></a></li><li><a href="#Wannier.compute_weights-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.compute_weights</code></a></li><li><a href="#Wannier.compute_weights-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.compute_weights</code></a></li><li><a href="#Wannier.delete_parallel-Tuple{Wannier.BVectorShells}"><code>Wannier.delete_parallel</code></a></li><li><a href="#Wannier.delete_parallel-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.delete_parallel</code></a></li><li><a href="#Wannier.flatten_shells-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.flatten_shells</code></a></li><li><a href="#Wannier.get_bvectors-Tuple{Vector{&lt;:StaticArraysCore.SVector{3}}, StaticArraysCore.SMatrix{3, 3, &lt;:Real, 9}}"><code>Wannier.get_bvectors</code></a></li><li><a href="#Wannier.get_bvectors_nearest-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real"><code>Wannier.get_bvectors_nearest</code></a></li><li><a href="#Wannier.index_bvector-Tuple{AbstractVector, AbstractVector, Integer, Integer, AbstractVector{&lt;:Integer}}"><code>Wannier.index_bvector</code></a></li><li><a href="#Wannier.search_shells-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real"><code>Wannier.search_shells</code></a></li><li><a href="#Wannier.sort_bvectors-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.sort_bvectors</code></a></li><li><a href="#Wannier.sort_supercell-Tuple{AbstractVector, AbstractMatrix}"><code>Wannier.sort_supercell</code></a></li></ul><h2 id="B-vector-shells-and-B-vectors"><a class="docs-heading-anchor" href="#B-vector-shells-and-B-vectors">B vector shells and B vectors</a><a id="B-vector-shells-and-B-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#B-vector-shells-and-B-vectors" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.BVectorShells" href="#Wannier.BVectorShells"><code>Wannier.BVectorShells</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BVectorShells</code></pre><p>Shells of bvectors.</p><p>The bvectors are sorted by norm such that equal-norm bvectors are grouped into one shell.</p><p><strong>Fields</strong></p><ul><li><code>recip_lattice</code>: <code>3 * 3</code>, each column is a reciprocal lattice vector</li><li><code>kpoints</code>: <code>3 * n_kpts</code>, in fractional coordinates</li><li><code>bvectors</code>: vectors of <code>3 * n_bvecs_per_shell</code>, in cartesian coordinates</li><li><code>weights</code>: vector of float, weights of each shell</li><li><code>multiplicities</code>: number of bvectors in each shell</li><li><code>n_bvecs</code>: total number of bvectors</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.BVectorShells-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, Any, Any, AbstractVector{T}}} where T&lt;:Real" href="#Wannier.BVectorShells-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, Any, Any, AbstractVector{T}}} where T&lt;:Real"><code>Wannier.BVectorShells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BVectorShells(recip_lattice, kpoints, bvectors, weights)</code></pre><p>Constructor of <code>BVectorShells</code>.</p><p>Only essential arguments are required, remaing fields of <code>BVectorShells</code> are initialized accordingly. This should be used instead of directly constructing <code>BVectorShells</code>.</p><p><strong>Arguments</strong></p><ul><li><code>recip_lattice</code>: <code>3 * 3</code>, each column is a reciprocal lattice vector</li><li><code>kpoints</code>: <code>3 * n_kpts</code>, in fractional coordinates</li><li><code>bvectors</code>: vectors of <code>3 * n_bvecs_per_shell</code>, in cartesian coordinates</li><li><code>weights</code>: vector of float, weights of each shell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L43-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.BVectors" href="#Wannier.BVectors"><code>Wannier.BVectors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BVectors</code></pre><p>The bvectors for each kpoint.</p><p><strong>Fields</strong></p><ul><li><code>recip_lattice</code>: <code>3 * 3</code>, each column is a reciprocal lattice vector</li><li><code>kpoints</code>: <code>3 * n_kpts</code>, in fractional coordinates</li><li><code>bvectors</code>: <code>3 * n_bvecs</code>, in cartesian coordinates</li><li><code>weights</code>: <code>n_bvecs</code>, weights of each bvector</li><li><code>kpb_k</code>: k+b vectors at kpoint <code>k</code>, <code>k</code> -&gt; <code>k + b</code>   (index of periodically equivalent kpoint inside <code>recip_lattice</code>)</li><li><code>kpb_G</code>: <code>3 * n_bvecs * n_kpts</code>,   displacements between k + b and its periodic image inside <code>recip_lattice</code>,   such that k+b = <code>kpoints[:, kpb_k[ib, ik]] + kpb_G[:, ib, ik]</code> (in fractional)</li><li><code>n_kpts</code>: number of kpoints</li><li><code>n_bvecs</code>: total number of bvectors</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In principle, we don&#39;t need to sort the bvectors for each kpoint, so that the bvectors have the same order as each kpoint. However, since <code>Wannier90</code> sort the bvectors, and the <code>mmn</code> file is written in that order, so we also sort in the same order as <code>Wannier90</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L80-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier._bvec_to_kb-Tuple{AbstractVector, AbstractVector, AbstractVector}" href="#Wannier._bvec_to_kb-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>Wannier._bvec_to_kb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find equivalent kpoint and displacement vector of bvectors <code>bvecs</code> at kpoint <code>k</code>.</p><p>all inputs in fractional coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L494-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier._sort_kb-Tuple{AbstractVector, AbstractVector{Int64}, AbstractVector{StaticArraysCore.SVector{3, Int64}}, AbstractVector{StaticArraysCore.SVector{3, Int64}}}" href="#Wannier._sort_kb-Tuple{AbstractVector, AbstractVector{Int64}, AbstractVector{StaticArraysCore.SVector{3, Int64}}, AbstractVector{StaticArraysCore.SVector{3, Int64}}}"><code>Wannier._sort_kb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort bvectors specified by equivalent kpoint indices <code>k</code> and cell displacements <code>b</code>.</p><p>Sorting order:</p><ol><li>length of bvectors: nearest k+b goes first, this is achieved by comparing  the norm <code>bvecs_norm</code>.</li><li>supercell index: the supercell are already sorted by <code>sort_supercell</code>,  which generates our input <code>translations</code>.</li><li>index of kpoint: the smaller index goes first, dictated by the input <code>kpoints</code>.</li></ol><p>bvecs_norm: length of bvectors, cartesian norm. k: index in <code>kpoints</code> for equivalent kpoint of bvectors b: cell displacements of bvectors, fractional coordinates translations: of supercell, fractional coordinates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L521-L535">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.are_parallel-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.are_parallel-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.are_parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">are_parallel(A, B; atol=1e-6)</code></pre><p>Check if the columns of matrix <code>A</code> and columns of matrix <code>B</code> are parallel.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix</li><li><code>B</code>: matrix</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance to check parallelism</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L227-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.check_b1-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T" href="#Wannier.check_b1-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T"><code>Wannier.check_b1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_b1(shells::BVectorShells; atol=1e-6)</code></pre><p>Check completeness (B1 condition) of <code>BVectorShells</code>.</p><p><strong>Arguments</strong></p><ul><li><code>shells</code>: <code>BVectorShells</code> containing bvectors in each shell</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance, equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L389-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.compute_weights-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real" href="#Wannier.compute_weights-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.compute_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_weights(bvectors::Vector{Matrix{T}}; atol=1e-6)</code></pre><p>Try to guess bvector weights from MV1997 Eq. (B1).</p><p>The input bvectors are overcomplete vectors found during shell search, i.e. from <code>search_shells</code>. This function tries to find the minimum number of bvector shells that satisfy the B1 condition, and return the new <code>BVectorShells</code> and weights.</p><p><strong>Arguments</strong></p><ul><li><code>bvectors</code>: vector of bvectors in each shell</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance to satisfy B1 condition,   equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L303-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.compute_weights-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real" href="#Wannier.compute_weights-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.compute_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_weights(shells::BVectorShells; atol=1e-6)</code></pre><p>Try to guess bvector weights from MV1997 Eq. (B1).</p><p><strong>Arguments</strong></p><ul><li><code>shells</code>: <code>BVectorShells</code> containing bvectors in each shell</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance to satisfy B1 condition,   equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L372-L383">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.delete_parallel-Tuple{Wannier.BVectorShells}" href="#Wannier.delete_parallel-Tuple{Wannier.BVectorShells}"><code>Wannier.delete_parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_parallel(shells::BVectorShells)</code></pre><p>Remove shells having parallel bvectors.</p><p><strong>Arguments</strong></p><ul><li><code>shells</code>: <code>BVectorShells</code> containing bvectors in each shell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L290-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.delete_parallel-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real" href="#Wannier.delete_parallel-Union{Tuple{Array{Array{StaticArraysCore.SVector{3, T}, 1}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.delete_parallel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delete_parallel(bvectors::Vector{Matrix{T}})</code></pre><p>Remove shells having parallel bvectors.</p><p><strong>Arguments</strong></p><ul><li><code>bvectors</code>: vector of bvectors in each shell</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L257-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.flatten_shells-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real" href="#Wannier.flatten_shells-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.flatten_shells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten_shells(shells::BVectorShells)</code></pre><p>Flatten shell vectors into a matrix.</p><p>Return a tuple of <code>(bvecs, bvecs_weight)</code>, where</p><ul><li><code>bvecs</code>: <code>3 * n_bvecs</code></li><li><code>bvecs_weight</code>: <code>n_bvecs</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L424-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_bvectors-Tuple{Vector{&lt;:StaticArraysCore.SVector{3}}, StaticArraysCore.SMatrix{3, 3, &lt;:Real, 9}}" href="#Wannier.get_bvectors-Tuple{Vector{&lt;:StaticArraysCore.SVector{3}}, StaticArraysCore.SMatrix{3, 3, &lt;:Real, 9}}"><code>Wannier.get_bvectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bvectors(kpoints, recip_lattice; kmesh_tol=1e-6)</code></pre><p>Generate and sort bvectors for all the kpoints.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, kpoints in fractional coordinates</li><li><code>recip_lattice</code>: <code>3 * 3</code>, columns are reciprocal lattice vectors</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kmesh_tol</code>: equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L638-L649">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_bvectors_nearest-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real" href="#Wannier.get_bvectors_nearest-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real"><code>Wannier.get_bvectors_nearest</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_bvectors_nearest(kpoints, recip_lattice; kmesh_tol=1e-6)</code></pre><p>Generate and sort bvectors for all the kpoints.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, kpoints in fractional coordinates</li><li><code>recip_lattice</code>: <code>3 * 3</code>, columns are reciprocal lattice vectors</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>kmesh_tol</code>: equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L708-L719">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.index_bvector-Tuple{AbstractVector, AbstractVector, Integer, Integer, AbstractVector{&lt;:Integer}}" href="#Wannier.index_bvector-Tuple{AbstractVector, AbstractVector, Integer, Integer, AbstractVector{&lt;:Integer}}"><code>Wannier.index_bvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_bvector(kpb_k, kpb_G, k1, k2, b)</code></pre><p>Given bvector <code>b</code> connecting kpoints <code>k1</code> and <code>k2</code>, return the index of the bvector <code>ib</code>.</p><p>This is a reverse search of bvector index if you only know the two kpoints <code>k1</code> and <code>k2</code>, and the connecting displacement vector <code>b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>kpb_k</code>: <code>n_bvecs * n_kpts</code>, k+b kpoints at <code>k1</code></li><li><code>kpb_G</code>: <code>3 * n_bvecs * n_kpts</code>, displacement vector for k+b bvectors at <code>k1</code></li><li><code>k1</code>: integer, index of kpoint <code>k1</code></li><li><code>k2</code>: integer, index of kpoint <code>k2</code></li><li><code>b</code>: vector of 3 integer, displacement vector from <code>k1</code> to <code>k2</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L671-L685">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.search_shells-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real" href="#Wannier.search_shells-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, StaticArraysCore.SMatrix{3, 3, T, 9}}} where T&lt;:Real"><code>Wannier.search_shells</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">search_shells(kpoints, recip_lattice; atol=1e-6, max_shells=36)</code></pre><p>Search bvector shells satisfing B1 condition.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: fractional coordinates</li><li><code>recip_lattice</code>: each column is a reciprocal lattice vector</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance to select a shell (points having equal distances),   equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code>.</li><li><code>max_shells</code>: max number of nearest-neighbor shells,   equivalent to <code>Wannier90</code> input parameter <code>search_shells</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L152-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.sort_bvectors-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real" href="#Wannier.sort_bvectors-Union{Tuple{Wannier.BVectorShells{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.sort_bvectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_bvectors(shells::BVectorShells; atol=1e-6)</code></pre><p>Sort bvectors in shells at each kpoints, to be consistent with <code>Wannier90</code>.</p><p><code>Wannier90</code> use different order of bvectors at each kpoint, in principle, this is not needed. However, the <code>mmn</code> file is written in such order, so we need to sort bvectors and calculate weights, since <code>nnkp</code> file has no section of weights.</p><p><strong>Arguments</strong></p><ul><li><code>shells</code>: <code>BVectorShells</code></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: equivalent to <code>Wannier90</code> input parameter <code>kmesh_tol</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L578-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.sort_supercell-Tuple{AbstractVector, AbstractMatrix}" href="#Wannier.sort_supercell-Tuple{AbstractVector, AbstractMatrix}"><code>Wannier.sort_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_supercell(translations, recip_lattice; atol=1e-8)</code></pre><p>Sort supercell to fix the order of bvectors.</p><p>Both input and output <code>translations</code> are in fractional coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>translations</code>: <code>3 * n_supercell</code> matrix, in fractional coordinates</li><li><code>recip_lattice</code>: each column is a reciprocal lattice vector</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>atol</code>: tolerance to compare bvectors,   this is the same as what is hardcoded in <code>Wannier90</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is used to reproduce <code>Wannier90</code> bvector order.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/764f27096e3408234bdd1f076356c95ea9621903/src/bvector.jl#L450-L468">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../io/">« Input/Output</a><a class="docs-footer-nextpage" href="../model/">Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 21:55">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
