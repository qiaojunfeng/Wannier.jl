<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Interpolation · Wannier.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Wannier.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../start/">Getting Started</a></li><li><span class="tocitem">Examples</span></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/algorithm/">Algorithm</a></li><li><a class="tocitem" href="../../theory/normalization/">Normalization</a></li><li><a class="tocitem" href="../../theory/initial_projection/">Initial projection</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../util/">Utility</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../bvector/">B vector</a></li><li><a class="tocitem" href="../model/">Model</a></li><li><a class="tocitem" href="../wannierize/">Wannierize</a></li><li class="is-active"><a class="tocitem" href>Interpolation</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#R-vectors"><span>R vectors</span></a></li><li><a class="tocitem" href="#Fourier-transforms"><span>Fourier transforms</span></a></li><li><a class="tocitem" href="#InterpModel"><span>InterpModel</span></a></li><li><a class="tocitem" href="#Band-structure"><span>Band structure</span></a></li><li><a class="tocitem" href="#Fermi-surface"><span>Fermi surface</span></a></li><li><a class="tocitem" href="#Derivatives"><span>Derivatives</span></a></li></ul></li><li><a class="tocitem" href="../realspace/">Real space</a></li><li><a class="tocitem" href="../cli/">Command line</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Interpolation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Interpolation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qiaojunfeng/Wannier.jl/blob/main/docs/src/api/interpolation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Interpolation"><a class="docs-heading-anchor" href="#Interpolation">Interpolation</a><a id="Interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation" title="Permalink"></a></h1><p>This page lists <code>struct</code> and <code>function</code>s for Wannier interpolation.</p><p>There are two flavors of interpolation:</p><ul><li>WS: the Wigner-Seitz interpolation</li><li>MDRS: the Minimal-distance replica selection method</li></ul><p>MDRS has better interpolation quality<sup class="footnote-reference"><a id="citeref-WAN20" href="#footnote-WAN20">[WAN20]</a></sup>, so it should be used in most cases. Moreover, we implement two versions of MDRS:</p><ul><li><code>MDRSv1</code>: the original version in <code>Wannier90</code><sup class="footnote-reference"><a id="citeref-WAN20" href="#footnote-WAN20">[WAN20]</a></sup>.   This is slower than the WS interpolation.</li><li><code>MDRSv2</code>: a slightly modified version which removes some for loops, same as what is implemented   in <code>Wannier Berri</code><sup class="footnote-reference"><a id="citeref-WBERRI" href="#footnote-WBERRI">[WBERRI]</a></sup>. The speed is similar to the WS interpolation.</li></ul><p>By default, we use the <code>MDRSv2</code> interpolation.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Interpolation">Interpolation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#R-vectors">R vectors</a></li><li><a href="#Fourier-transforms">Fourier transforms</a></li><li><a href="#InterpModel">InterpModel</a></li><li><a href="#Band-structure">Band structure</a></li><li><a href="#Fermi-surface">Fermi surface</a></li><li><a href="#Derivatives">Derivatives</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Wannier.HamiltonianKGrid-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}, Function}} where T"><code>Wannier.HamiltonianKGrid</code></a></li><li><a href="#Wannier.InterpModel-Tuple{Wannier.Model}"><code>Wannier.InterpModel</code></a></li><li><a href="#Wannier.InterpModel"><code>Wannier.InterpModel</code></a></li><li><a href="#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}}} where T&lt;:Complex"><code>Wannier.InterpModel</code></a></li><li><a href="#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}, Array{T, 4}}} where T&lt;:Complex"><code>Wannier.InterpModel</code></a></li><li><a href="#Wannier.KRVectors"><code>Wannier.KRVectors</code></a></li><li><a href="#Wannier.KRVectors-Union{Tuple{Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}, Tuple{T}} where T&lt;:Real"><code>Wannier.KRVectors</code></a></li><li><a href="#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Vector{StaticArraysCore.SVector{3, Int64}}, Array{Int64, 3}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real"><code>Wannier.KRVectors</code></a></li><li><a href="#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real"><code>Wannier.KRVectors</code></a></li><li><a href="#Wannier.RVectors-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVector{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{T}}} where T&lt;:Integer"><code>Wannier.RVectors</code></a></li><li><a href="#Wannier.RVectors"><code>Wannier.RVectors</code></a></li><li><a href="#Wannier.RVectorsMDRS"><code>Wannier.RVectorsMDRS</code></a></li><li><a href="#Wannier.RVectorsMDRS-Tuple{Wannier.RVectors, Vector{Matrix{Vector{StaticArraysCore.SVector{3, Int64}}}}, Vector{Matrix{Int64}}}"><code>Wannier.RVectorsMDRS</code></a></li><li><a href="#Wannier.Hk-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, StaticArraysCore.SVector{3}}"><code>Wannier.Hk</code></a></li><li><a href="#Wannier._get_D-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier._get_D</code></a></li><li><a href="#Wannier.check_weights-Tuple{Wannier.RVectors}"><code>Wannier.check_weights</code></a></li><li><a href="#Wannier.cut_hamiltonian-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Complex{T}, 3}, T}} where T&lt;:Real"><code>Wannier.cut_hamiltonian</code></a></li><li><a href="#Wannier.effmass_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.effmass_fd</code></a></li><li><a href="#Wannier.fermi_surface-Union{Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}, Tuple{KT}} where KT&lt;:Union{Integer, AbstractVector{Int64}}"><code>Wannier.fermi_surface</code></a></li><li><a href="#Wannier.fourier-Tuple{Function, Any, Any}"><code>Wannier.fourier</code></a></li><li><a href="#Wannier.get_Hk-Tuple{Vector, Vector}"><code>Wannier.get_Hk</code></a></li><li><a href="#Wannier.get_Rvectors_mdrs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_Rvectors_mdrs</code></a></li><li><a href="#Wannier.get_Rvectors_ws-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.get_Rvectors_ws</code></a></li><li><a href="#Wannier.get_d2H_dadb-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_d2H_dadb</code></a></li><li><a href="#Wannier.get_dH_da-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_dH_da</code></a></li><li><a href="#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Any}"><code>Wannier.interpolate</code></a></li><li><a href="#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Brillouin.KPaths.KPathInterpolant}"><code>Wannier.interpolate</code></a></li><li><a href="#Wannier.invfourier-Union{Tuple{T}, Tuple{Function, Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, StaticArraysCore.SVector{3}}} where T"><code>Wannier.invfourier</code></a></li><li><a href="#Wannier.sort_hamiltonian_by_norm-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}"><code>Wannier.sort_hamiltonian_by_norm</code></a></li><li><a href="#Wannier.velocity-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.velocity</code></a></li><li><a href="#Wannier.velocity_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.velocity_fd</code></a></li></ul><h2 id="R-vectors"><a class="docs-heading-anchor" href="#R-vectors">R vectors</a><a id="R-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#R-vectors" title="Permalink"></a></h2><h3 id="RVectors"><a class="docs-heading-anchor" href="#RVectors">RVectors</a><a id="RVectors-1"></a><a class="docs-heading-anchor-permalink" href="#RVectors" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The R vectors are automatically generated by calling either of these two approaches:</p><ul><li><a href="../io/#Wannier.read_w90_with_chk"><code>read_w90_with_chk</code></a> to read the <code>Wannier90</code> output <code>seedname.chk.fmt</code> file,   and generate an <code>InterpModel</code>,</li><li><a href="#Wannier.InterpModel"><code>InterpModel</code></a> a constructor   to generate the <code>InterpModel</code> from a Wannierization <code>Model</code>.</li></ul><p>So usually the user does not need to call the following functions.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Wannier.RVectors" href="#Wannier.RVectors"><code>Wannier.RVectors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RVectors</code></pre><p>The R vectors for interpolation.</p><p><strong>Fields</strong></p><ul><li><code>lattice</code>: columns are lattice vectors</li><li><code>grid</code>: number of FFT grid points in each direction, actually equal to <code>kgrid</code></li><li><code>R</code>: <code>3 * n_rvecs</code>, R vectors in fractional coordinates w.r.t. lattice</li><li><code>N</code>: <code>n_rvecs</code>, degeneracy of each R vector</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The R vectors are sorted in the same order as <code>Wannier90</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.RVectors-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVector{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{T}}} where T&lt;:Integer" href="#Wannier.RVectors-Union{Tuple{T}, Tuple{AbstractMatrix, AbstractVector{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{T}}} where T&lt;:Integer"><code>Wannier.RVectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RVectors(lattice, grid, R, N)</code></pre><p>Constructor for <code>RVectors</code>.</p><p>Auto transform <code>lattice</code> and <code>grid</code> to <code>Mat3</code> and <code>Vec3</code>, respectively.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: columns are lattice vectors</li><li><code>grid</code>: number of FFT grid points in each direction, actually equal to <code>kgrid</code></li><li><code>R</code>: <code>3 * n_rvecs</code>, R vectors in fractional coordinates w.r.t. lattice</li><li><code>N</code>: <code>n_rvecs</code>, degeneracy of each R vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L47-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.RVectorsMDRS" href="#Wannier.RVectorsMDRS"><code>Wannier.RVectorsMDRS</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RVectorsMDRS</code></pre><p>The R vectors for MDRS interpolation.</p><p><strong>Fields</strong></p><ul><li><code>Rvectors</code>: <code>Rvectors</code> for Wigner-Seitz interpolation</li></ul><p><strong>For MDRSv1</strong></p><ul><li><code>T</code>: <code>n_wann * n_wann * n_rvecs</code>, translation vectors w.r.t to lattice for MDRSv1</li><li><code>Nᵀ</code>: <code>n_wann * n_wann * n_rvecs</code>, degeneracy of each <code>T</code> vector for MDRSv1</li></ul><p><strong>For MDRSv2</strong></p><ul><li><code>R̃vectors</code>: <code>RVectors</code> containing expanded set of <code>R + T</code> vectors used in MDRSv2</li><li><code>R̃_RT</code>: mapping of <code>R̃vectors</code> to <code>R</code> and <code>T</code> vectors</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The R vectors are sorted in the same order as <code>Wannier90</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L161-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.RVectorsMDRS-Tuple{Wannier.RVectors, Vector{Matrix{Vector{StaticArraysCore.SVector{3, Int64}}}}, Vector{Matrix{Int64}}}" href="#Wannier.RVectorsMDRS-Tuple{Wannier.RVectors, Vector{Matrix{Vector{StaticArraysCore.SVector{3, Int64}}}}, Vector{Matrix{Int64}}}"><code>Wannier.RVectorsMDRS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RVectorsMDRS(Rvectors, T, Nᵀ)</code></pre><p>A friendly constructor for <code>RVectorsMDRS</code>.</p><p>The remaining fields <code>R̃vectors</code> and <code>R̃_RT</code> are only used in MDRSv2, the are calculated automatically based on the input arguments.</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectors</code> for Wigner-Seitz interpolation</li><li><code>T</code>: <code>n_wann * n_wann * n_rvecs</code>, translation vectors w.r.t to lattice for MDRSv1</li><li><code>Nᵀ</code>: <code>n_wann * n_wann * n_rvecs</code>, degeneracy of each <code>T</code> vector for MDRSv1</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L204-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.check_weights-Tuple{Wannier.RVectors}" href="#Wannier.check_weights-Tuple{Wannier.RVectors}"><code>Wannier.check_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_weights(R::RVectors)</code></pre><p>Sanity check for the degeneracies of R vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_Rvectors_mdrs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.get_Rvectors_mdrs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Int64}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_Rvectors_mdrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Rvectors_mdrs(lattice, rgrid, centers; atol=1e-5, max_cell=3)</code></pre><p>Generate R vectors for MDRS interpolation (both v1 and v2).</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: columns are lattice vectors</li><li><code>rgrid</code>: number of FFT grid points in each direction, actually equal to <code>kgrid</code></li><li><code>centers</code>: <code>3 * n_wann</code>, WF centers in fractional coordinates</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>atol</code>: toerance for checking degeneracy,   equivalent to <code>Wannier90</code> input parameter <code>ws_distance_tol</code></li><li><code>max_cell</code>: number of neighboring cells to be searched,   equivalent to <code>Wannier90</code> input parameter <code>ws_search_size</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L274-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_Rvectors_ws-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}" href="#Wannier.get_Rvectors_ws-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.get_Rvectors_ws</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Rvectors_ws(lattice, rgrid; atol=1e-5, max_cell=3)</code></pre><p>Generate R vectors for Wigner-Seitz interpolation.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: columns are lattice vectors</li><li><code>rgrid</code>: number of FFT grid points in each direction, actually equal to <code>kgrid</code></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>atol</code>: toerance for checking degeneracy,   equivalent to <code>Wannier90</code> input parameter <code>ws_distance_tol</code></li><li><code>max_cell</code>: number of neighboring cells to be searched,   equivalent to <code>Wannier90</code> input parameter <code>ws_search_size</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/rvector.jl#L89-L103">source</a></section></article><h3 id="KRVectors"><a class="docs-heading-anchor" href="#KRVectors">KRVectors</a><a id="KRVectors-1"></a><a class="docs-heading-anchor-permalink" href="#KRVectors" title="Permalink"></a></h3><p>The <code>KRVectors</code> contains both kpoint mappings and <code>RVectors</code>, allowing both forward and inverse Fourier transform.</p><article class="docstring"><header><a class="docstring-binding" id="Wannier.KRVectors" href="#Wannier.KRVectors"><code>Wannier.KRVectors</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct KRVectors</code></pre><p>Contains both kpoints mapping and R vectors.</p><p><strong>Fields</strong></p><ul><li><code>lattice</code>: each column is a lattice vector</li><li><code>kgrid</code>: number of kpoints along 3 directions</li><li><code>kpoints</code>: each column is a kpoint in fractional coordinates</li><li><code>k_xyz</code>: kpoints mappings from <code>ik</code> to <code>[ikx, iky, ikz]</code></li><li><code>xyz_k</code>: kpoints mappings from <code>[ikx, iky, ikz]</code> to <code>ik</code></li><li><code>Rvectors</code>: R vectors, can be either <code>RVectors</code> or <code>RVectorsMDRS</code></li><li><code>recip_lattice</code>: each column is a reciprocal lattice vector</li><li><code>n_kpts</code>: number of kpoints</li><li><code>n_rvecs</code>: number of R vectors</li><li><code>n_r̃vecs</code>: number of R̃ vectors, only for MDRS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/krvector.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real" href="#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real"><code>Wannier.KRVectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KRVectors(lattice, kgrid, kpoints, Rvectors)</code></pre><p>A friendly constructor for <code>KRVectors</code>.</p><p>The kpoint mappings <code>k_xyz</code> and <code>xyz_k</code> are generated based on <code>kpoints</code> and <code>kgrid</code>. Remaining fields are generated automatically based on input arguments.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: each column is a lattice vector</li><li><code>kgrid</code>: number of kpoints along 3 directions</li><li><code>kpoints</code>: each column is a kpoint in fractional coordinates</li><li><code>Rvectors</code>: R vectors, can be either <code>RVectors</code> or <code>RVectorsMDRS</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/krvector.jl#L97-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Vector{StaticArraysCore.SVector{3, Int64}}, Array{Int64, 3}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real" href="#Wannier.KRVectors-Union{Tuple{T}, Tuple{StaticArraysCore.SMatrix{3, 3, T, 9}, StaticArraysCore.SVector{3, Int64}, Matrix{T}, Vector{StaticArraysCore.SVector{3, Int64}}, Array{Int64, 3}, Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}} where T&lt;:Real"><code>Wannier.KRVectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KRVectors(lattice, kgrid, kpoints, k_xyz, xyz_k, Rvectors)</code></pre><p>A friendly constructor for <code>KRVectors</code>.</p><p>Remaining fields are generated automatically based on input arguments.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: each column is a lattice vector</li><li><code>kgrid</code>: number of kpoints along 3 directions</li><li><code>kpoints</code>: each column is a kpoint in fractional coordinates</li><li><code>k_xyz</code>: kpoints mappings from <code>ik</code> to <code>[ikx, iky, ikz]</code></li><li><code>xyz_k</code>: kpoints mappings from <code>[ikx, iky, ikz]</code> to <code>ik</code></li><li><code>Rvectors</code>: R vectors, can be either <code>RVectors</code> or <code>RVectorsMDRS</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/krvector.jl#L69-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.KRVectors-Union{Tuple{Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}, Tuple{T}} where T&lt;:Real" href="#Wannier.KRVectors-Union{Tuple{Union{Wannier.RVectors{T}, Wannier.RVectorsMDRS{T}}}, Tuple{T}} where T&lt;:Real"><code>Wannier.KRVectors</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">KRVectors(Rvectors)</code></pre><p>Construct a <code>KRVectors</code> from <code>RVectors</code> or <code>RVectorsMDRS</code>.</p><p>The kpoints part are just empty.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If we only need to Wannier interpolate operators, e.g., interpolate band structure from <code>tb.dat</code> file, then we don&#39;t need info on the kpoint grid of Wannierization, so we can just leave it empty.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/krvector.jl#L121-L133">source</a></section></article><h2 id="Fourier-transforms"><a class="docs-heading-anchor" href="#Fourier-transforms">Fourier transforms</a><a id="Fourier-transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-transforms" title="Permalink"></a></h2><p>Performs Fourier transform between k and R spaces defined by <code>KRVectors</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In general, the user only need to call the <code>fourier(kRvectors, Oᵏ)</code> and <code>invfourier(kRvectors, Oᴿ, kpoints)</code> functions directly, irrespective of the type of <code>kRVectors</code>. Other functions are internally used based on the type of <code>KRVectors</code>, thanks to multiple dispatch.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Wannier.fourier-Tuple{Function, Any, Any}" href="#Wannier.fourier-Tuple{Function, Any, Any}"><code>Wannier.fourier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fourier(f::Function, q_vectors, R_vectors)</code></pre><p>Performs a fourier transform from the ab-initio kpoints to the wigner seitz unit cells. The function will be executed inside the fourier transform loop, being called like <code>f(iR, ik, phase)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/fourier.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.invfourier-Union{Tuple{T}, Tuple{Function, Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, StaticArraysCore.SVector{3}}} where T" href="#Wannier.invfourier-Union{Tuple{T}, Tuple{Function, Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, StaticArraysCore.SVector{3}}} where T"><code>Wannier.invfourier</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Fourier transforms the tight binding hamiltonian and calls the R_function with the current index and the phase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/fourier.jl#L23">source</a></section></article><h2 id="InterpModel"><a class="docs-heading-anchor" href="#InterpModel">InterpModel</a><a id="InterpModel-1"></a><a class="docs-heading-anchor-permalink" href="#InterpModel" title="Permalink"></a></h2><p>To separate the Wannier interpolation from Wannierization, we have another model, the <code>InterpModel</code>, which is solely for the purpose of interpolation, while <code>Model</code> works only for Wannierization.</p><article class="docstring"><header><a class="docstring-binding" id="Wannier.InterpModel" href="#Wannier.InterpModel"><code>Wannier.InterpModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct InterpModel</code></pre><p>The model for Wannier interpolation.</p><p>Store the real space matrices, e.g., the Hamiltonian <span>$H(\bm{R})$</span>.</p><p>Usually after Wannierization of a <a href="api/@ref Model"><code>Model</code></a>, we construct this <code>InterpModel</code> for Wannier interpolation of operators.</p><p><strong>Fields</strong></p><ul><li><code>kRvectors</code>: the kpoints and R vectors</li><li><code>kpath</code>: the kpoint path for band structure</li><li><code>H</code>: <code>n_wann * n_wann * n_rvecs</code>, the Hamiltonian in real space</li><li><code>r</code>: <code>n_wann * n_wann * n_rvecs</code>, the position operator in real space</li><li><code>S</code>: <code>n_wann * n_wann * n_rvecs * 3</code>, optional, the spin operator</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For MDRS interpolation, the <code>n_rvecs</code> in this docstring is actually the number of <span>$\tilde{\bm{R}}$</span> vectors, i.e., <code>KRVectors.Rvectors.n_r̃vecs</code>. For WS interpolation, it is just <code>KRVectors.Rvectors.n_rvecs</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/interp_model.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.InterpModel-Tuple{Wannier.Model}" href="#Wannier.InterpModel-Tuple{Wannier.Model}"><code>Wannier.InterpModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpModel(model::Model; mdrs::Bool=true)</code></pre><p>Construct a <code>InterpModel</code> from a Wannierization <a href="../model/#Wannier.Model"><code>Model</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the Wannierization <a href="../model/#Wannier.Model"><code>Model</code></a></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>mdrs</code>: whether to use MDRS interpolation</li><li><code>kpath</code>: if not given, use <a href="../util/#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractString}"><code>get_kpath</code></a> to auto generate a kpath.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/interp_model.jl#L127-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}, Array{T, 4}}} where T&lt;:Complex" href="#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}, Array{T, 4}}} where T&lt;:Complex"><code>Wannier.InterpModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpModel(kRvectors, H, kpath, H, r)</code></pre><p>A <code>InterpModel</code> constructor ignoring spin operator matrices.</p><p><strong>Arguments</strong></p><ul><li><code>kRvectors</code>: the kpoint and R vectors</li><li><code>kpath</code>: the kpoint path for band structure</li><li><code>H</code>: <code>n_wann * n_wann * n_rvecs</code>, the Hamiltonian in real space</li><li><code>r</code>: <code>n_wann * n_wann * n_rvecs * 3</code>, the position operator in real space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/interp_model.jl#L88-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}}} where T&lt;:Complex" href="#Wannier.InterpModel-Union{Tuple{T}, Tuple{Wannier.KRVectors, Brillouin.KPaths.KPath, Array{T, 3}}} where T&lt;:Complex"><code>Wannier.InterpModel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpModel(kRvectors, H, kpath, H)</code></pre><p>A <code>InterpModel</code> constructor ignoring position and spin operator matrices.</p><p><strong>Arguments</strong></p><ul><li><code>kRvectors</code>: the kpoint and R vectors</li><li><code>kpath</code>: the kpoint path for band structure</li><li><code>H</code>: <code>n_wann * n_wann * n_rvecs</code>, the Hamiltonian in real space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/interp_model.jl#L109-L118">source</a></section></article><h2 id="Band-structure"><a class="docs-heading-anchor" href="#Band-structure">Band structure</a><a id="Band-structure-1"></a><a class="docs-heading-anchor-permalink" href="#Band-structure" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Need some care when comparing the band interpolation between <code>Wannier.jl</code> and <code>Wannier90</code>, after running the <code>Wannier.jl</code> disentanglement and writing an optimized <code>amn</code> file for <code>Wannier90</code> to interpolate band structure.</p><p>When <code>Wannier90</code> read an <code>amn</code> file, it will (<code>Wannier90</code> v3.1.0)</p><ol><li>Lowdin orthogonalize the <code>amn</code> matrices, in <code>disentangle.F90:dis_project</code>, line 1418  This should do no harm, since the optimized amn is already semi-unitary,  a SVD of it should not change the optimized amn (apart from numerical noise)</li><li>generate a new <code>amn</code> according to the frozen window, in <code>disentangle.F90:dis_proj_froz</code>,  line 1830. This will <strong>DESTROY</strong> the optimized <code>amn</code> matrices, if we restart  <code>Wannier90</code> from the optimized <code>amn</code> with <code>dis_num_iter = 0</code>, the spreads in <code>wout</code> file  is very different from the output of <code>Wannier.jl</code>, we must skip this step by commenting  out <strong>ALL</strong> the <code>dis_froz_min/max</code> in the <code>win</code> file, then  use <code>Wannier90</code> to interpolate bands, remember also set <code>num_iter</code> and <code>dis_num_ite = 0</code>.</li></ol></div></div><article class="docstring"><header><a class="docstring-binding" id="Wannier.HamiltonianKGrid-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}, Function}} where T" href="#Wannier.HamiltonianKGrid-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {LT, M}, Vector{&lt;:StaticArraysCore.SVector{3}}, Function}} where T"><code>Wannier.HamiltonianKGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">HamiltonianKGrid(hami::TBHamiltonian{T}, nk, H_function_k::Function = x -&gt; nothing) where T
HamiltonianKGrid(hami::TBHamiltonian{T}, k_grid, H_function_k::Function = x -&gt; nothing) where T</code></pre><p>Takes a k grid, calculates Hk for each of them and diagonalizes. Only the eigenvectors and eigenvalues of Hk are stored, the <code>H_function_k</code> function is called on the intermediate Hk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L158-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.Hk-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, StaticArraysCore.SVector{3}}" href="#Wannier.Hk-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, StaticArraysCore.SVector{3}}"><code>Wannier.Hk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Hk(hamiltonian::TBHamiltonian, kpoint::Vec3)
Hk!(hk::AbstractMatrix, hamiltonian::TBHamiltonian, kpoint::Vec3)</code></pre><p>Constructs the reciprocal Hamiltonian at a given <em>k</em>-point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.cut_hamiltonian-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Complex{T}, 3}, T}} where T&lt;:Real" href="#Wannier.cut_hamiltonian-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Complex{T}, 3}, T}} where T&lt;:Real"><code>Wannier.cut_hamiltonian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cut_hamiltonian(Rvectors::RVectorsMDRS{T}, Hᴿ::Array{Complex{T},3}, Rcut::T) where {T&lt;:Real}</code></pre><p>Cut real space Hamiltonian <code>Hᴿ</code> by the given cutoff radius.</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectorsMDRS</code></li><li><code>Hᴿ</code>: <code>n_wann * n_wann * n_rvecs</code>, Hamiltonian in real space.</li><li><code>Rcut</code>: cutoff radius in angstrom, the Hamiltonian <code>H(R)</code> corresponds to the R vectors with norm larger than <code>Rcut</code> will be set to 0.</li></ul><p><strong>Return</strong></p><ul><li><code>H</code>: <code>n_wann * n_wann * n_rvecs</code>, cutted Hamiltonian in real space.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R, H, pos = read_w90_tb(&quot;mos2&quot;)
# Expand the H(R) to R̃, I assume the H(R) is read from w90 tb.dat file
H1 = Wannier.mdrs_v1tov2(R, H)
H2 = cut_hamiltonian(R, H1, 7.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L93-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_Hk-Tuple{Vector, Vector}" href="#Wannier.get_Hk-Tuple{Vector, Vector}"><code>Wannier.get_Hk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Hk(E, U)</code></pre><p>Construct k space Hamiltonian Hᵏ.</p><p class="math-container">\[H_{\bm{k}} = U_{\bm{k}}^\dagger [\epsilon_{n \bm{k}}] U_{\bm{k}},\]</p><p>where <span>$[\epsilon_{n \bm{k}}]$</span> is a diagonal matrix with <span>$\epsilon_{n \bm{k}}$</span> as the diagonal elements.</p><p><strong>Arguments</strong></p><ul><li><code>E</code>: <code>n_bands * n_kpts</code>, energy eigenvalue</li><li><code>U</code>: <code>n_bands * n_wann * n_kpts</code>, gauge matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Any}" href="#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Any}"><code>Wannier.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(model::TBHamiltonian{T}, kpoints::Matrix{T}) where {T&lt;:Real}</code></pre><p>Interpolate energy eigenvalues at <code>kpoints</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: <code>TBHamiltonian</code></li><li><code>kpoints</code>: <code>3 * n_kpts</code>, kpoints to be interpolated, in fractional coordinates,   can be nonuniform.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L227-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Brillouin.KPaths.KPathInterpolant}" href="#Wannier.interpolate-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, Brillouin.KPaths.KPathInterpolant}"><code>Wannier.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(model::TBHamiltonian, kpi::KPathInterpolant)</code></pre><p>Interpolate band structure along the given kpath.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: <code>TBHamiltonian</code></li><li><code>kpi</code>: <code>KPathInterpolant</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.sort_hamiltonian_by_norm-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}" href="#Wannier.sort_hamiltonian_by_norm-Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}"><code>Wannier.sort_hamiltonian_by_norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_hamiltonian_by_norm(Rvectors::RVectorsMDRS{T}, Hᴿ::Array{Complex{T},3}) where {T&lt;:Real}</code></pre><p>Sort the Hamiltonian <span>$H(m{R})$</span> by its norm in descending order.</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectorsMDRS</code></li><li><code>Hᴿ</code>: <code>n_wann * n_wann * n_rvecs</code>, Hamiltonian in real space.</li></ul><p><strong>Return</strong></p><ul><li><code>idx</code>: the index to sort the Hamiltonian, i.e. <code>Hᴿ[:, :, idx]</code> is the sorted Hamiltonian.</li><li><code>normR</code>: the norm of R vectors, <code>normR[idx]</code> is the sorted <code>R</code> vectors in descending order.</li><li><code>normH</code>: the norm of H, <code>normH[idx]</code> is the sorted <code>Hᴿ</code> in descending order.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">R, H, pos = read_w90_tb(&quot;mos2&quot;)
# Expand the H(R) to R̃, I assume the H(R) is read from w90 tb.dat file
H1 = Wannier.mdrs_v1tov2(R, H)
idx, normR, normH = sort_hamiltonian_by_norm(R, H1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/hamiltonian.jl#L58-L79">source</a></section></article><h2 id="Fermi-surface"><a class="docs-heading-anchor" href="#Fermi-surface">Fermi surface</a><a id="Fermi-surface-1"></a><a class="docs-heading-anchor-permalink" href="#Fermi-surface" title="Permalink"></a></h2><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>fermi_surface</code> function will use WS or MDRS interpolation based on the type of <code>Rvectors</code>. However, <code>Wannier90</code> only use WS interpolation when plotting Fermi surface (even if the <code>use_ws_distance</code> is set as <code>true</code> in the <code>win</code> file). So the <code>fermi_surface</code> function will output different result than <code>Wannier90</code> if using MDRS.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Wannier.fermi_surface-Union{Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}, Tuple{KT}} where KT&lt;:Union{Integer, AbstractVector{Int64}}" href="#Wannier.fermi_surface-Union{Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}}, Tuple{KT}} where KT&lt;:Union{Integer, AbstractVector{Int64}}"><code>Wannier.fermi_surface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fermi_surface(Rvectors, H; n_k)</code></pre><p>Interpolate Fermi surface.</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectors</code> or <code>RVectorsMDRS</code></li><li><code>H</code>: <code>n_wann * n_wann * n_r̃vecs</code>, Hamiltonian in R space</li><li><code>n_k</code>: integer or 3-vector, number of interpolated kpoints along three directions</li></ul><p><strong>Return</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kx * n_ky * n_kz</code>, interpolated kpoints in fractional coordinates</li><li><code>E</code>: <code>n_wann * n_kx * n_ky * n_kz</code>, interpolated eigenvalues</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The output <code>n_kx = n_k + 1</code>, since the bxsf format requires general grid, i.e., the last kpoint is the periodic image of the first one. This also restores the behavior of <code>Wannier90</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For MDRS interpolation, the <code>H</code> should be defined on the <span>$\bm{R}$</span> vectors instead of the MDRSv2 <span>$\tilde{\bm{R}}$</span> vectors; the expansion of <span>$H(\bm{R})$</span> to <span>$H(\tilde{\bm{R}})$</span> is done internally. This means that if you read the <code>seedname_tb.dat</code> file, then you can directly pass the <code>H</code> to this function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/fermisurf.jl#L3-L29">source</a></section></article><h2 id="Derivatives"><a class="docs-heading-anchor" href="#Derivatives">Derivatives</a><a id="Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Derivatives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier._get_D-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier._get_D-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier._get_D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_get_D(Rvectors, Hᴿ, kpoints; use_degen_pert=false, degen=1e-4)</code></pre><p>Compute the matrix D in YWVS Eq. 25 (or Eq. 32 if <code>use_degen_pert = true</code>).</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectorsMDRS</code></li><li><code>Hᴿ</code>: <code>n_wann * n_wann * n_r̃vecs</code>, the Hamiltonian matrix</li><li><code>kpoints</code>: <code>3 * n_kpts</code>, each column is a fractional kpoints coordinates</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_degen_pert</code>: use perturbation treatment for degenerate eigenvalues</li><li><code>degen</code>: degeneracy threshold in eV</li></ul><p><strong>Return</strong></p><ul><li><code>E</code>: <code>n_wann * n_kpts</code>, energy eigenvalues</li><li><code>U</code>: <code>n_wann * n_wann * n_kpts</code>, the unitary transformation matrix</li><li><code>Haᴴ</code>: <code>n_wann * n_wann * n_kpts * 3</code>, the covariant part of derivative of   Hamiltonian in Hamiltonian gauge,   the <span>$\bar{H}_{\alpha}^{(H)}$</span> in YWVS Eq. 26</li><li><code>D</code>: <code>n_wann * n_wann * n_kpts * 3</code>, the matrix D in YWVS Eq. 25 or Eq. 32</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>If <code>use_degen_pert = true</code>, the degenerate subspace is rotated such that <span>$\bar{H}_{x}^{(H)}$</span> is diagonal, note only the <span>$x$</span> direction. I cannot diagonalize simultaneously all the three directions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L97-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.effmass_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.effmass_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.effmass_fd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">effmass_fd(Rvectors, Hᴿ, kpoints; Δk=1e-3)</code></pre><p>Compute the inverse of effective mass using finite differences of 2nd order.</p><p>Apply twice PRB 93, 205147 (2016)  Eq. 80.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L350-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_d2H_dadb-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.get_d2H_dadb-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_d2H_dadb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_d2H_dadb(Rvectors, Hᴿ, kpoints)</code></pre><p>Compute the second derivative of the Hamiltonian <span>$H$</span> with respect to three Cartesian directions.</p><p>YWVS Eq. 28.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L240-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_dH_da-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.get_dH_da-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.get_dH_da</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_dH_da(Rvectors, Hᴿ, kpoints)</code></pre><p>Compute the derivative of the Hamiltonian <span>$H$</span> with respect to three Cartesian</p><p>directions. YWVS Eq. 26.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L209-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.velocity-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.velocity-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.velocity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity(Rvectors, Hᴿ, kpoints; use_degen_pert=false, degen=1e-4)</code></pre><p>Compute velocity along three Cartesian directions.</p><p>YWVS Eq. 27.</p><p><strong>Arguments</strong></p><ul><li><code>Rvectors</code>: <code>RVectorsMDRS</code></li><li><code>Hᴿ</code>: <code>n_wann * n_wann * n_r̃vecs</code>, the Hamiltonian matrix</li><li><code>kpoints</code>: <code>3 * n_kpts</code>, each column is a fractional kpoints coordinates</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_degen_pert</code>: use perturbation treatment for degenerate eigenvalues</li><li><code>degen</code>: degeneracy threshold in eV</li></ul><p><strong>Return</strong></p><ul><li><code>E</code>: <code>n_wann * n_kpts</code>, energy eigenvalues</li><li><code>v</code>: <code>n_wann * n_kpts * 3</code>, velocity along three Cartesian directions,   in unit <code>hbar * m / s</code></li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>Wannier90</code> by default set <code>use_degen_pert = false</code>. In 3D, and for N degenerate states, the velocity is a tensor of size N * N * 3, where 3 is for three Cartesian directions. Thus I cannot simultaneously diagonalize the tensor for all 3 directions. This means I can only use perturbation treatment for one of the directions, and only in that direction the velocity matrix is diagonal. So for degenerate states, the velocity is not well defined, and the results are meaningless, instead one should use the full velocity matrix which also include non-diagonal part, see <a href="#Wannier.get_dH_da-Union{Tuple{T}, Tuple{Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>get_dH_da</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L3-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.velocity_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.velocity_fd-Union{Tuple{T}, Tuple{Wannier.RVectorsMDRS{T}, Array{Wannier.TBBlock{T, LT, M}, 1} where {T, LT, M}, AbstractArray{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.velocity_fd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">velocity_fd(Rvectors, Hᴿ, kpoints; Δk=1e-3)</code></pre><p>Compute the velocity using finite differences of 2nd order.</p><p>PRB 93, 205147 (2016)  Eq. 80.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/interp/derivative.jl#L297-L303">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-WAN20"><a class="tag is-link" href="#citeref-WAN20">WAN20</a>Pizzi, G.; Vitale, V.; Arita, R.; Blügel, S.; Freimuth, F.; Géranton, G.; Gibertini, M.; Gresch, D.; Johnson, C.; Koretsune, T.; Ibañez-Azpiroz, J.; Lee, H.; Lihm, J.-M.; Marchand, D.; Marrazzo, A.; Mokrousov, Y.; Mustafa, J. I.; Nohara, Y.; Nomura, Y.; Paulatto, L.; Poncé, S.; Ponweiser, T.; Qiao, J.; Thöle, F.; Tsirkin, S. S.; Wierzbowska, M.; Marzari, N.; Vanderbilt, D.; Souza, I.; Mostofi, A. A. &amp; Yates, J. R., Wannier90 as a community code: new features and applications, <a href="https://doi.org/10.1088/1361-648x/ab51ff">Journal of Physics: Condensed Matter, 2020, 32, 165902</a></li><li class="footnote" id="footnote-WBERRI"><a class="tag is-link" href="#citeref-WBERRI">WBERRI</a>Tsirkin, S. S., High performance Wannier interpolation of Berry curvature and related quantities with WannierBerri code, <a href="https://doi.org/10.1038/s41524-021-00498-5">npj Computational Materials, 2021, 7</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../wannierize/">« Wannierize</a><a class="docs-footer-nextpage" href="../realspace/">Real space »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 19 July 2023 14:53">Wednesday 19 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
