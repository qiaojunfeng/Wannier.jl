<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utility · Wannier.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Wannier.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../start/">Getting Started</a></li><li><span class="tocitem">Examples</span></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/algorithm/">Algorithm</a></li><li><a class="tocitem" href="../../theory/normalization/">Normalization</a></li><li><a class="tocitem" href="../../theory/initial_projection/">Initial projection</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>Utility</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Structure"><span>Structure</span></a></li><li><a class="tocitem" href="#Matrices"><span>Matrices</span></a></li><li><a class="tocitem" href="#Kpoint"><span>Kpoint</span></a></li><li><a class="tocitem" href="#Kpath"><span>Kpath</span></a></li><li><a class="tocitem" href="#Centers"><span>Centers</span></a></li></ul></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../bvector/">B vector</a></li><li><a class="tocitem" href="../model/">Model</a></li><li><a class="tocitem" href="../wannierize/">Wannierize</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../realspace/">Real space</a></li><li><a class="tocitem" href="../cli/">Command line</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Utility</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Utility</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qiaojunfeng/Wannier.jl/blob/main/docs/src/api/util.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Utility"><a class="docs-heading-anchor" href="#Utility">Utility</a><a id="Utility-1"></a><a class="docs-heading-anchor-permalink" href="#Utility" title="Permalink"></a></h1><p>These are some simple convenience functions to smoothen developer experience.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Utility">Utility</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Structure">Structure</a></li><li><a href="#Matrices">Matrices</a></li><li><a href="#Kpoint">Kpoint</a></li><li><a href="#Kpath">Kpath</a></li><li><a href="#Centers">Centers</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Wannier.compute_imre_ratio-Tuple{AbstractArray}"><code>Wannier.compute_imre_ratio</code></a></li><li><a href="#Wannier.eyes_U-Tuple{Type, Int64, Int64, Int64}"><code>Wannier.eyes_U</code></a></li><li><a href="#Wannier.eyes_U-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T"><code>Wannier.eyes_U</code></a></li><li><a href="#Wannier.find_nearest_atom-Union{Tuple{T}, Tuple{Vector, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.find_nearest_atom</code></a></li><li><a href="#Wannier.find_nearests-Union{Tuple{R}, Tuple{T}, Tuple{AbstractVector{T}, R, AbstractMatrix{T}, Vector}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.find_nearests</code></a></li><li><a href="#Wannier.findvector-Tuple{Function, AbstractVector, AbstractMatrix}"><code>Wannier.findvector</code></a></li><li><a href="#Wannier.fix_global_phase-Tuple{AbstractArray}"><code>Wannier.fix_global_phase</code></a></li><li><a href="#Wannier.get_atom_number-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractString"><code>Wannier.get_atom_number</code></a></li><li><a href="#Wannier.get_atom_number-Tuple{AbstractString}"><code>Wannier.get_atom_number</code></a></li><li><a href="#Wannier.get_kgrid-Union{Tuple{Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.get_kgrid</code></a></li><li><a href="#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractString}"><code>Wannier.get_kpath</code></a></li><li><a href="#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.get_kpath</code></a></li><li><a href="#Wannier.get_kpath-Union{Tuple{SV}, Tuple{AbstractMatrix, Array{Vector{SV}, 1}}} where SV&lt;:(Pair{Symbol, StaticArraysCore.SVector{3, T}} where T)"><code>Wannier.get_kpath</code></a></li><li><a href="#Wannier.get_kpoint_mappings-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}}} where T&lt;:Real"><code>Wannier.get_kpoint_mappings</code></a></li><li><a href="#Wannier.get_kpoints-Tuple{AbstractVector{&lt;:Integer}}"><code>Wannier.get_kpoints</code></a></li><li><a href="#Wannier.get_kpoints-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_kpoints</code></a></li><li><a href="#Wannier.get_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}"><code>Wannier.get_lattice</code></a></li><li><a href="#Wannier.get_projectability-Tuple{AbstractVector}"><code>Wannier.get_projectability</code></a></li><li><a href="#Wannier.get_recip_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}"><code>Wannier.get_recip_lattice</code></a></li><li><a href="#Wannier.get_x-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_x</code></a></li><li><a href="#Wannier.imaglog-Tuple{T} where T&lt;:Complex"><code>Wannier.imaglog</code></a></li><li><a href="#Wannier.interpolate_w90-Tuple{Brillouin.KPaths.KPath, Int64}"><code>Wannier.interpolate_w90</code></a></li><li><a href="#Wannier.isunitary-Tuple{AbstractVector{AbstractMatrix}}"><code>Wannier.isunitary</code></a></li><li><a href="#Wannier.make_supercell"><code>Wannier.make_supercell</code></a></li><li><a href="#Wannier.make_supercell-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{&lt;:AbstractRange}}} where T"><code>Wannier.make_supercell</code></a></li><li><a href="#Wannier.orthonorm_lowdin-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Union{Real, Complex}"><code>Wannier.orthonorm_lowdin</code></a></li><li><a href="#Wannier.orthonorm_lowdin-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T&lt;:Union{Real, Complex}"><code>Wannier.orthonorm_lowdin</code></a></li><li><a href="#Wannier.rand_unitary-Tuple{Type, Int64}"><code>Wannier.rand_unitary</code></a></li><li><a href="#Wannier.rand_unitary-Tuple{Type, Int64, Int64}"><code>Wannier.rand_unitary</code></a></li><li><a href="#Wannier.rand_unitary-Tuple{Type, Integer, Integer, Integer}"><code>Wannier.rand_unitary</code></a></li><li><a href="#Wannier.rotate_M-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>Wannier.rotate_M</code></a></li><li><a href="#Wannier.rotate_U-Tuple{AbstractVector, AbstractVector}"><code>Wannier.rotate_U</code></a></li><li><a href="#Wannier.rotate_gauge-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}} where T&lt;:Number"><code>Wannier.rotate_gauge</code></a></li><li><a href="#Wannier.sort_kpoints-Tuple{Vector}"><code>Wannier.sort_kpoints</code></a></li><li><a href="#Wannier.wrap_centers-Tuple{Vector, AbstractMatrix}"><code>Wannier.wrap_centers</code></a></li></ul><h2 id="Structure"><a class="docs-heading-anchor" href="#Structure">Structure</a><a id="Structure-1"></a><a class="docs-heading-anchor-permalink" href="#Structure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_atom_number-Tuple{AbstractString}" href="#Wannier.get_atom_number-Tuple{AbstractString}"><code>Wannier.get_atom_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_atom_number(symbol::AbstractString)</code></pre><p>Get atom number from symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/structure.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_atom_number-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractString" href="#Wannier.get_atom_number-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractString"><code>Wannier.get_atom_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_atom_number(symbol::Vector{String})</code></pre><p>Get atom number from symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/structure.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}" href="#Wannier.get_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}"><code>Wannier.get_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_lattice(recip_lattice::Mat3)</code></pre><p>Return lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/structure.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_recip_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}" href="#Wannier.get_recip_lattice-Tuple{StaticArraysCore.SMatrix{3, 3, T, 9} where T}"><code>Wannier.get_recip_lattice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_recip_lattice(lattice::Mat3)</code></pre><p>Return reciprocal lattice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/structure.jl#L24-L28">source</a></section></article><h2 id="Matrices"><a class="docs-heading-anchor" href="#Matrices">Matrices</a><a id="Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.compute_imre_ratio-Tuple{AbstractArray}" href="#Wannier.compute_imre_ratio-Tuple{AbstractArray}"><code>Wannier.compute_imre_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_imre_ratio(W::AbstractArray)</code></pre><p>Compute Im/Re ratio of the wavefunction.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This follows the same logic as <code>Wannier90</code> when computing the ratio for real space WFs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.eyes_U-Tuple{Type, Int64, Int64, Int64}" href="#Wannier.eyes_U-Tuple{Type, Int64, Int64, Int64}"><code>Wannier.eyes_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eyes_U(T::Type, n_bands::Int, n_wann::Int, n_kpts::Int)</code></pre><p>Return a series of indentity matrices of type <code>T</code> and size <code>n_bands * n_wann * n_kpts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.eyes_U-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T" href="#Wannier.eyes_U-Union{Tuple{T}, Tuple{Type{T}, Int64, Int64}} where T"><code>Wannier.eyes_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eyes_U(T::Type, n_wann::Int, n_kpts::Int)</code></pre><p>Return a series of indentity matrices of type <code>T</code> and size <code>n_wann * n_wann * n_kpts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.findvector-Tuple{Function, AbstractVector, AbstractMatrix}" href="#Wannier.findvector-Tuple{Function, AbstractVector, AbstractMatrix}"><code>Wannier.findvector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findvector(predicate::Function, v::AbstractVector, M::AbstractMatrix)</code></pre><p>Find index of vector in the columns of a matrix.</p><p><strong>Arguments</strong></p><ul><li><code>predicate</code>: comparison function</li><li><code>v</code>: the vector to be found</li><li><code>M</code>: the matrix to be searched, its column will be compared to <code>v</code> by <code>predicate</code> function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.fix_global_phase-Tuple{AbstractArray}" href="#Wannier.fix_global_phase-Tuple{AbstractArray}"><code>Wannier.fix_global_phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_global_phase(W::AbstractArray)</code></pre><p>Return a factor to fix the global phase of wavefunction, such that the point having max norm is real.</p><p><strong>Arguments</strong></p><ul><li><code>W</code>: usually <code>size(W) = nx * ny * nz</code></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This follows the same logic as <code>Wannier90</code> when computing the ratio for real space WFs.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L38-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_projectability-Tuple{AbstractVector}" href="#Wannier.get_projectability-Tuple{AbstractVector}"><code>Wannier.get_projectability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_projectability(U)</code></pre><p>Return projectability of each kpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.imaglog-Tuple{T} where T&lt;:Complex" href="#Wannier.imaglog-Tuple{T} where T&lt;:Complex"><code>Wannier.imaglog</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">imaglog(z)</code></pre><p>Return the imaginary part of the logarithm of <code>z</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.isunitary-Tuple{AbstractVector{AbstractMatrix}}" href="#Wannier.isunitary-Tuple{AbstractVector{AbstractMatrix}}"><code>Wannier.isunitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isunitary(U; atol=1e-10)</code></pre><p>Check if matrix is unitary or semi-unitary for all the kpoints?</p><p>I.e. does it have orthogonal columns?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L190-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.orthonorm_lowdin-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T&lt;:Union{Real, Complex}" href="#Wannier.orthonorm_lowdin-Union{Tuple{Array{Matrix{T}, 1}}, Tuple{T}} where T&lt;:Union{Real, Complex}"><code>Wannier.orthonorm_lowdin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthonorm_lowdin(U::Array{T,3})</code></pre><p>Lowdin orthonormalize a series of matrices <code>U</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.orthonorm_lowdin-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Union{Real, Complex}" href="#Wannier.orthonorm_lowdin-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Union{Real, Complex}"><code>Wannier.orthonorm_lowdin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthonorm_lowdin(U::Matrix{T})</code></pre><p>Lowdin orthonormalize a matrix <code>U</code> to be (semi-)unitary.</p><p>If <code>U</code> is a matrix with orthogonal columns and <code>V</code> a non-singular matrix, then Lowdin-orthogonalizing <code>U*V</code> is equivalent to computing <code>U*orthonorm_lowdin(V)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L13-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rand_unitary-Tuple{Type, Int64, Int64}" href="#Wannier.rand_unitary-Tuple{Type, Int64, Int64}"><code>Wannier.rand_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unitary(T::Type, m::Int, n::Int)</code></pre><p>Generate a random (semi-)unitary matrix using Lowdin orthonormalization.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: the type of the matrix, e.g., <code>ComplexF64</code>, <code>Float64</code></li><li><code>m</code>: number of rows</li><li><code>n</code>: number of columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L240-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rand_unitary-Tuple{Type, Int64}" href="#Wannier.rand_unitary-Tuple{Type, Int64}"><code>Wannier.rand_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unitary(T::Type, m::Int)</code></pre><p>Generate a random unitary matrix using Lowdin orthonormalization.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: the type of the matrix</li><li><code>m</code>: number of rows (= number of columns)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L256-L264">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rand_unitary-Tuple{Type, Integer, Integer, Integer}" href="#Wannier.rand_unitary-Tuple{Type, Integer, Integer, Integer}"><code>Wannier.rand_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unitary(T::Type, m, n, k)</code></pre><p>Generate a series of random (semi-)unitary matrix using Lowdin orthonormalization.</p><p>The returned <code>M[:, :, ik]</code> is (semi-)unitary for all <code>ik = 1:k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: the type of the matrix</li><li><code>m</code>: number of rows</li><li><code>n</code>: number of columns</li><li><code>k</code>: number of matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L267-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rotate_M-Tuple{AbstractVector, AbstractVector, AbstractVector}" href="#Wannier.rotate_M-Tuple{AbstractVector, AbstractVector, AbstractVector}"><code>Wannier.rotate_M</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_M(M, kpb_k, U)</code></pre><p>Rotate <code>mmn</code> matrices according to gauge <code>U</code>.</p><p>i.e., for each kpoint <span>$\bm{k}$</span>, <span>$U_{\bm{k}+\bm{b}}^{\dagger} M_{\bm{k},\bm{b}} U_{\bm{k}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rotate_U-Tuple{AbstractVector, AbstractVector}" href="#Wannier.rotate_U-Tuple{AbstractVector, AbstractVector}"><code>Wannier.rotate_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_U(U, V)</code></pre><p>Rotate the gauge matrices <code>U</code> by <code>V</code>.</p><p>For each kpoint <span>$\bm{k}$</span>, return <span>$U_{\bm{k}} V_{\bm{k}}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>U</code>: a series of gauge matrices, usually <code>size(U) = n_bands * n_wann * n_kpts</code></li><li><code>V</code>: a series of gauge matrices, usually <code>size(V) = n_wann * n_wann * n_kpts</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L139-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rotate_gauge-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}} where T&lt;:Number" href="#Wannier.rotate_gauge-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}} where T&lt;:Number"><code>Wannier.rotate_gauge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_gauge(O::Array{T,3}, U::Array{T,3})</code></pre><p>Rotate the gauge of the operator <code>O</code>.</p><p>I.e., <span>$U^{\dagger} O U$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/linalg.jl#L96-L102">source</a></section></article><h2 id="Kpoint"><a class="docs-heading-anchor" href="#Kpoint">Kpoint</a><a id="Kpoint-1"></a><a class="docs-heading-anchor-permalink" href="#Kpoint" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kgrid-Union{Tuple{Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{T}} where T&lt;:Real" href="#Wannier.get_kgrid-Union{Tuple{Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{T}} where T&lt;:Real"><code>Wannier.get_kgrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kgrid(kpoints)</code></pre><p>Guess kgrid from list of kpoint coordinates.</p><p>Input <code>kpoints</code> has size <code>3 * n_kpts</code>, where <code>n_kpts = nkx * nky *  nkz</code>, output <code>[nkx, nky, nkz]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, fractional coordiantes</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L161-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpoint_mappings-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}}} where T&lt;:Real" href="#Wannier.get_kpoint_mappings-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}}} where T&lt;:Real"><code>Wannier.get_kpoint_mappings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpoint_mappings(kpoints, kgrid)</code></pre><p>Get the mappings between kpoint indexes and kpoint coordiantes.</p><p>Return a tuple of <code>(k_xyz, xyz_k)</code>:</p><ul><li><code>k_xyz[ik]</code> maps kpoint <code>kpoints[:, ik]</code> to kpoint coordinates <code>[ikx, iky, ikz]</code></li><li><code>xyz_k[ikx, iky, ikz]</code> maps kpoint coordinates <code>[ikx, iky, ikz]</code> to kpoint index <code>ik</code></li><li>the kpoint fractional coordinates is <code>[(ikx - 1)/nkx, (iky - 1)/nky, (ikz - 1)/nkz]</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, in fractional coordinates</li><li><code>kgrid</code>: <code>3</code>, number of kpoints along each reciprocal lattice vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpoints-Tuple{AbstractVector{&lt;:Integer}}" href="#Wannier.get_kpoints-Tuple{AbstractVector{&lt;:Integer}}"><code>Wannier.get_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpoints(kgrid; fractional=true, endpoint=false)</code></pre><p>Generate list of kpoint coordinates from kpoint grid.</p><p><strong>Arguments</strong></p><ul><li><code>kgrid</code>: vector of 3 integers specifying a <code>nkx * nky * nkz</code> mesh</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>fractional</code>: return an explicit list of kpoints in fractional coordinates, else integers</li><li><code>endpoint</code>: include the endpoint of the grid, only for fractional case. E.g., if true, 1.0 is included</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If the default keyword arguments are used, this function works just like <code>kmesh.pl</code> of <code>Wannier90</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L94-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.make_supercell" href="#Wannier.make_supercell"><code>Wannier.make_supercell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_supercell(kpoints, replica=5)</code></pre><p>Make a supercell of kpoints by translating it along 3 directions.</p><p><strong>Arguments</strong></p><ul><li><code>replica</code>: integer, number of repetitions along ±x, ±y, ±z directions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L80-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.make_supercell-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{&lt;:AbstractRange}}} where T" href="#Wannier.make_supercell-Union{Tuple{T}, Tuple{Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{&lt;:AbstractRange}}} where T"><code>Wannier.make_supercell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">make_supercell(kpoints, replica)</code></pre><p>Make a supercell of kpoints by translating it along 3 directions.</p><p>On output there are <code>(2*replica + 1)^3</code> cells, in fractional coordinates.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, in fractional coordinates</li><li><code>replica</code>: <code>3</code>, number of repetitions along ±x, ±y, ±z directions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.sort_kpoints-Tuple{Vector}" href="#Wannier.sort_kpoints-Tuple{Vector}"><code>Wannier.sort_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_kpoints(kpoints)</code></pre><p>Sort kpoints such that z increases the fastest, then y, then x.</p><p><strong>Arguments</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpoint.jl#L149-L156">source</a></section></article><h2 id="Kpath"><a class="docs-heading-anchor" href="#Kpath">Kpath</a><a id="Kpath-1"></a><a class="docs-heading-anchor-permalink" href="#Kpath" title="Permalink"></a></h2><p>The <code>KPath</code> and <code>KPathInterpolant</code> are defined in <a href="https://thchr.github.io/Brillouin.jl/stable/"><code>Brillouin.jl</code></a>, they are used to store the high-symmetry kpoints and their labels.</p><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractString}" href="#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractString}"><code>Wannier.get_kpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpath(lattice, atom_positions, atom_labels)</code></pre><p>Get a <code>Brillouin.KPath</code> for arbitrary cell (can be non-standard).</p><p>Internally use <code>Brillouin.jl</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: <code>3 * 3</code>, each column is a lattice vector</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, fractional coordinates</li><li><code>atom_labels</code>: <code>n_atoms</code> of string, atomic labels</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L233-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}" href="#Wannier.get_kpath-Union{Tuple{R}, Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, AbstractVector{R}}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.get_kpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpath(lattice, atom_positions, atom_numbers)</code></pre><p>Get a <code>Brillouin.KPath</code> for arbitrary cell (can be non-standard).</p><p>Internally use <code>Brillouin.jl</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: <code>3 * 3</code>, each column is a lattice vector</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, fractional coordinates</li><li><code>atom_numbers</code>: <code>n_atoms</code> of integer, atomic numbers</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L210-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpath-Union{Tuple{SV}, Tuple{AbstractMatrix, Array{Vector{SV}, 1}}} where SV&lt;:(Pair{Symbol, StaticArraysCore.SVector{3, T}} where T)" href="#Wannier.get_kpath-Union{Tuple{SV}, Tuple{AbstractMatrix, Array{Vector{SV}, 1}}} where SV&lt;:(Pair{Symbol, StaticArraysCore.SVector{3, T}} where T)"><code>Wannier.get_kpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpath(lattice, kpoint_path)</code></pre><p>Construct a <code>Brillouin.KPath</code> from the returned <code>kpoint_path</code> of <code>WannierIO.read_win</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: each column is a lattice vector</li><li><code>kpoint_path</code>: the returned <code>kpoint_path</code> of <code>WannierIO.read_win</code>, e.g.,</li></ul><pre><code class="language-julia hljs">kpoint_path = [
    [:Γ =&gt; [0.0, 0.0, 0.0], :M =&gt; [0.5, 0.5, 0.0]],
    [:M =&gt; [0.5, 0.5, 0.0], :R =&gt; [0.5, 0.5, 0.5]],
]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_kpoints-Tuple{Brillouin.KPaths.KPathInterpolant}" href="#Wannier.get_kpoints-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_kpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_kpoints(kpi::KPathInterpolant)</code></pre><p>Get the kpoints coordinates from a <code>KPathInterpolant</code>.</p><p><strong>Arguments</strong></p><ul><li><code>kpi</code>: <code>KPathInterpolant</code></li></ul><p><strong>Return</strong></p><ul><li><code>kpoints</code>: <code>3 * n_kpts</code>, kpath points coordinates in fractional coordinates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L188-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_x-Tuple{Brillouin.KPaths.KPathInterpolant}" href="#Wannier.get_x-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_x</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_x(kpi::KPathInterpolant)</code></pre><p>Get x axis value for plotting, in cartesian length.</p><p><strong>Arguments</strong></p><ul><li><code>kpi</code>: a <code>KPathInterpolant</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.interpolate_w90-Tuple{Brillouin.KPaths.KPath, Int64}" href="#Wannier.interpolate_w90-Tuple{Brillouin.KPaths.KPath, Int64}"><code>Wannier.interpolate_w90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_w90(kpath::KPath, n_points::Int)</code></pre><p>Get kpoint coordinates from a <code>Brillouin.KPath</code>.</p><p>Use the kpath density of first segment to generate the following kpaths, also need to take care of high symmetry kpoints at the start and end of each segment.</p><p>Return a <code>KPathInterpolant</code>.</p><p><strong>Arguments</strong></p><ul><li><code>kpath</code>: a <code>Brillouin.KPath</code></li><li><code>n_points</code>: number of kpoints in the first segment, remaining segments   have the same density as the 1st segment.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This reproduce exactly the <code>Wannier90</code> input parameter <code>kpoint_path</code> block and the input parameter <code>bands_num_points</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/kpath.jl#L80-L99">source</a></section></article><h2 id="Centers"><a class="docs-heading-anchor" href="#Centers">Centers</a><a id="Centers-1"></a><a class="docs-heading-anchor-permalink" href="#Centers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.find_nearest_atom-Union{Tuple{T}, Tuple{Vector, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real" href="#Wannier.find_nearest_atom-Union{Tuple{T}, Tuple{Vector, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}}} where T&lt;:Real"><code>Wannier.find_nearest_atom</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_nearest_atom(centers, lattice, atom_positions)</code></pre><p>Find nearest atom for each WF center.</p><p><strong>Arguments</strong></p><ul><li><code>centers</code>: <code>3 * n_wann</code>, in fractional coordinates</li><li><code>lattice</code>: <code>3 * 3</code>, each column is a lattice vector</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, each column is fractional coordinate ∈ <code>[0, 1)</code></li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">wout = read_wout(&quot;silicon.wout&quot;)
points = inv(wout.lattice) * wout.centers  # to fractional
find_nearest_atom(points, wout.lattice, wout.atom_positions)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/center.jl#L45-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.find_nearests-Union{Tuple{R}, Tuple{T}, Tuple{AbstractVector{T}, R, AbstractMatrix{T}, Vector}} where {T&lt;:Real, R&lt;:Integer}" href="#Wannier.find_nearests-Union{Tuple{R}, Tuple{T}, Tuple{AbstractVector{T}, R, AbstractMatrix{T}, Vector}} where {T&lt;:Real, R&lt;:Integer}"><code>Wannier.find_nearests</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_nearests(point, search_neighbors, lattice, atom_positions)</code></pre><p>Find nearest-atom (including its periodic images) to a <code>point</code>.</p><p>Usually <code>point</code> is the WF center, so the function returns nearest atom to WF center.</p><p><strong>Arguments</strong></p><ul><li><code>point</code>: vector of <code>3</code> floats, fractional coordinates w.r.t. lattice</li><li><code>search_neighbors</code>: number of nearest-neighbors to be returned</li><li><code>lattice</code>: <code>3 * 3</code>, each column is a lattice vector</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, each column is fractional coordinate ∈ <code>[0, 1)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/center.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.wrap_centers-Tuple{Vector, AbstractMatrix}" href="#Wannier.wrap_centers-Tuple{Vector, AbstractMatrix}"><code>Wannier.wrap_centers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wrap_centers(centers, lattice)</code></pre><p>Wrap around centers back to unit cell at origin.</p><p><strong>Arguments</strong></p><ul><li><code>centers</code>:: <code>3 * n_wann</code>, in Cartesian coordiantes</li><li><code>lattice</code>:: <code>3 * 3</code>, each column is a lattice vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/63fba4cc1fecf9e56567cbd0d6a9dfdf12234eea/src/util/center.jl#L79-L87">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/initial_projection/">« Initial projection</a><a class="docs-footer-nextpage" href="../io/">Input/Output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 27 July 2023 21:54">Thursday 27 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
