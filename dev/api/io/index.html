<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Input/Output · Wannier.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Wannier.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../start/">Getting Started</a></li><li><span class="tocitem">Examples</span></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/normalization/">Normalization</a></li><li><a class="tocitem" href="../../theory/discretization/"><span>$k$</span>-space Discretization</a></li><li><a class="tocitem" href="../../theory/initial_projection/">Initial projection</a></li><li><a class="tocitem" href="../../theory/algorithm/">Localization</a></li><li><a class="tocitem" href="../../theory/fourier/">Wannier Interpolation</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../util/">Utility</a></li><li class="is-active"><a class="tocitem" href>Input/Output</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Wannier90-files"><span>Wannier90 files</span></a></li><li><a class="tocitem" href="#File-manipulation"><span>File manipulation</span></a></li><li><a class="tocitem" href="#D-visualization-files"><span>3D visualization files</span></a></li><li><a class="tocitem" href="#Interface-to-DFT-codes"><span>Interface to DFT codes</span></a></li></ul></li><li><a class="tocitem" href="../model/">Model</a></li><li><a class="tocitem" href="../bvector/"><span>$b$</span>-vector</a></li><li><a class="tocitem" href="../wannierize/">Localization</a></li><li><a class="tocitem" href="../realspace/">Real space</a></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../cli/">Command line</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Input/Output</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Input/Output</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qiaojunfeng/Wannier.jl/blob/main/docs/src/api/io.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Input/Output"><a class="docs-heading-anchor" href="#Input/Output">Input/Output</a><a id="Input/Output-1"></a><a class="docs-heading-anchor-permalink" href="#Input/Output" title="Permalink"></a></h1><p>The reading and writing functions are implemented in the <a href="https://github.com/qiaojunfeng/WannierIO.jl"><code>WannierIO.jl</code></a> package. However, here are also some convenience functions which wrap the corresponding functions in <code>WannierIO.jl</code>, to utilize the <code>struct</code>s defined in <code>Wannier90.jl</code>, e.g. <a href="api/@ref"><code>KspaceStencil</code></a>, <a href="../realspace/#Wannier.RGrid"><code>RGrid</code></a>, etc.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In most cases, the units of the function arguments and returns are in angstrom unit for lattice, and fractional w.r.t lattice for atomic positions, etc.</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The following abbreviations are used throughout the code and documentation:</p><ul><li><code>n_bands</code> for number of bands</li><li><code>n_wann</code> for number of WFs</li><li><code>n_kpts</code> for number of kpoints</li><li><code>n_bvecs</code> for number of b-vectors</li><li><code>n_atoms</code> for number of atoms</li><li><code>U</code> for <code>amn</code> or the gauge matrices</li><li><code>M</code> for <code>mmn</code> matrices</li><li><code>E</code> for <code>eig</code> matrices</li><li><code>S</code> for <code>spn</code> matrices</li></ul></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>In most cases, for arrays we adopt the convention that <code>n_bands</code> is the first index, <code>n_wann</code> is the second index, and <code>n_kpts</code> is the third index. For example, <code>U</code> for the gauge matrices is a 3D array of size <code>(n_bands, n_wann, n_kpts)</code>.</p></div></div><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Input/Output">Input/Output</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Wannier90-files">Wannier90 files</a></li><li><a href="#File-manipulation">File manipulation</a></li><li><a href="#D-visualization-files">3D visualization files</a></li><li><a href="#Interface-to-DFT-codes">Interface to DFT codes</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Wannier.Model-Tuple{WannierIO.Chk}"><code>Wannier.Model</code></a></li><li><a href="#Wannier._raw_read_w90_tb-Tuple{AbstractString}"><code>Wannier._raw_read_w90_tb</code></a></li><li><a href="#Wannier.compute_mud-Tuple{AbstractString, AbstractString}"><code>Wannier.compute_mud</code></a></li><li><a href="#Wannier.generate_w90_kpoint_path-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}"><code>Wannier.generate_w90_kpoint_path</code></a></li><li><a href="#Wannier.get_symm_point_indices_labels-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_symm_point_indices_labels</code></a></li><li><a href="#Wannier.read_amn_ortho-Tuple{AbstractString}"><code>Wannier.read_amn_ortho</code></a></li><li><a href="#Wannier.read_bxsf-Tuple{AbstractString}"><code>Wannier.read_bxsf</code></a></li><li><a href="#Wannier.read_cube-Tuple{AbstractString}"><code>Wannier.read_cube</code></a></li><li><a href="#Wannier.read_nnkp_compute_bweights-Tuple{AbstractString}"><code>Wannier.read_nnkp_compute_bweights</code></a></li><li><a href="#Wannier.read_w90-Tuple{AbstractString}"><code>Wannier.read_w90</code></a></li><li><a href="#Wannier.read_w90_tb-Tuple{AbstractString}"><code>Wannier.read_w90_tb</code></a></li><li><a href="#Wannier.read_w90_with_chk"><code>Wannier.read_w90_with_chk</code></a></li><li><a href="#Wannier.read_xsf-Tuple{AbstractString}"><code>Wannier.read_xsf</code></a></li><li><a href="#Wannier.truncate-Union{Tuple{T}, Tuple{Wannier.Model, T}, Tuple{Wannier.Model, T, Union{Nothing, AbstractVector{Int64}, T}}} where T&lt;:AbstractVector{Int64}"><code>Wannier.truncate</code></a></li><li><a href="#Wannier.truncate_mmn_eig"><code>Wannier.truncate_mmn_eig</code></a></li><li><a href="#Wannier.truncate_unk"><code>Wannier.truncate_unk</code></a></li><li><a href="#Wannier.truncate_w90"><code>Wannier.truncate_w90</code></a></li><li><a href="#Wannier.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, Wannier.RGrid, T, AbstractArray{T, 4}}} where T&lt;:Real"><code>Wannier.write_bxsf</code></a></li><li><a href="#Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real"><code>Wannier.write_cube</code></a></li><li><a href="#Wannier.write_nnkp-Tuple{AbstractString, Wannier.KspaceStencil}"><code>Wannier.write_nnkp</code></a></li><li><a href="#Wannier.write_w90-Tuple{AbstractString, Wannier.Model}"><code>Wannier.write_w90</code></a></li><li><a href="#Wannier.write_w90_kpt_label-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant}"><code>Wannier.write_w90_kpt_label</code></a></li><li><a href="#Wannier.write_w90_tb-Tuple{AbstractString, TBOperator, TBOperator}"><code>Wannier.write_w90_tb</code></a></li><li><a href="#Wannier.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real"><code>Wannier.write_xsf</code></a></li><li><a href="#WannierIO.read_w90_band-Tuple{AbstractString, AbstractMatrix}"><code>WannierIO.read_w90_band</code></a></li><li><a href="#WannierIO.write_chk"><code>WannierIO.write_chk</code></a></li><li><a href="#WannierIO.write_w90_band-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant, AbstractVector}"><code>WannierIO.write_w90_band</code></a></li></ul><h2 id="Wannier90-files"><a class="docs-heading-anchor" href="#Wannier90-files">Wannier90 files</a><a id="Wannier90-files-1"></a><a class="docs-heading-anchor-permalink" href="#Wannier90-files" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_amn_ortho-Tuple{AbstractString}" href="#Wannier.read_amn_ortho-Tuple{AbstractString}"><code>Wannier.read_amn_ortho</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_amn_ortho(filename)
</code></pre><p>Read <code>amn</code> file and Lowdin orthonormalize the unitary matrices.</p><p>The <code>U</code> matrix for Wannier functions must be unitary or semi-unitary. Thus, in most cases, this function should be used instead of <code>WannierIO.read_amn</code>, where the latter one just parse the <code>amn</code> file and return whatever is in it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/amn.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.generate_w90_kpoint_path-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}" href="#Wannier.generate_w90_kpoint_path-Tuple{AbstractMatrix, AbstractVector, AbstractVector, AbstractVector}"><code>Wannier.generate_w90_kpoint_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_w90_kpoint_path(
    recip_lattice,
    kpoints,
    symm_point_indices,
    symm_point_labels
)
</code></pre><p>Generate a <code>KPathInterpolant</code> from the kpoint coordinates and high-symmetry kpoints.</p><p>The <code>WannierIO.read_w90_band(prefix)</code> function returns the required arguments of this function.</p><p><strong>Arguments</strong></p><ul><li><code>recip_lattice</code>: each column is a reciprocal lattice vector in Å</li><li><code>kpoints</code>: list of kpoint coordinates along a kpath, fractional coordinates</li><li><code>symm_point_indices</code>: indices of the high-symmetry kpoints</li><li><code>symm_point_labels</code>: labels of the high-symmetry kpoints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/band.jl#L8-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_symm_point_indices_labels-Tuple{Brillouin.KPaths.KPathInterpolant}" href="#Wannier.get_symm_point_indices_labels-Tuple{Brillouin.KPaths.KPathInterpolant}"><code>Wannier.get_symm_point_indices_labels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_symm_point_indices_labels(kpi)
</code></pre><p>Return the symmetry indices and labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/band.jl#L90-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_w90_kpt_label-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant}" href="#Wannier.write_w90_kpt_label-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant}"><code>Wannier.write_w90_kpt_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90_kpt_label(prefix, kpi)
</code></pre><p>Write kpoints into wannier90 formats: <code>prefix_band.kpt</code>, <code>prefix_band.labelinfo.dat</code>.</p><p><strong>Arguments</strong></p><ul><li><code>prefix</code>: the prefix of the output files <code>prefix_band.kpt</code> and <code>prefix_band.labelinfo.dat</code></li><li><code>kpi</code>: a <code>KPathInterpolant</code> object</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This allows auto generating the high-symmetry kpoints and labels from crystal structure using <code>generate_kpath</code>, writing them into files. Then other codes can use the kpoints for band structure calculations, e.g., QE <code>pw.x</code> <code>bands</code> calculation, or in the <code>win</code> input file for <code>Wannier90</code>.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia hljs">win = read_win(&quot;si2.win&quot;)
kp = generate_kpath(win.unit_cell_cart, win.atoms_frac, win.atom_labels)
kpi = Wannier.generate_w90_kpoint_path(kp, 100)
Wannier.write_w90_kpt_label(&quot;si2&quot;, kpi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/band.jl#L135-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WannierIO.read_w90_band-Tuple{AbstractString, AbstractMatrix}" href="#WannierIO.read_w90_band-Tuple{AbstractString, AbstractMatrix}"><code>WannierIO.read_w90_band</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_w90_band(prefix, recip_lattice)
</code></pre><p><strong>Arguments</strong></p><ul><li><code>recip_lattice</code>: each column is a reciprocal lattice vector in Å.</li></ul><p><strong>Return</strong></p><ul><li><code>kpi</code>: a <code>KPathInterpolant</code> object</li><li><code>eigenvalues</code>: the eigenvalues of the band structure</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>WannierIO.read_w90_band(prefix)</code> function returns a <code>NamedTuple</code> containing basis variables such as <code>kpoints</code>, <code>symm_point_indices</code>, etc. Here, once we know the <code>recip_lattice</code>, we can generate a <code>KPathInterpolant</code> which can be used directly in plotting functions.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/band.jl#L65-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WannierIO.write_w90_band-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant, AbstractVector}" href="#WannierIO.write_w90_band-Tuple{AbstractString, Brillouin.KPaths.KPathInterpolant, AbstractVector}"><code>WannierIO.write_w90_band</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90_band(prefix, kpi, eigenvalues)
</code></pre><p>Write <code>prefix_band.dat, prefix_band.kpt, prefix_band.labelinfo.dat</code>.</p><p>This is a more user-friendly version that works with <code>KPathInterpolant</code>; the <code>WannierIO.write_w90_band(prefix; kwargs...)</code> is the low-level version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/band.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.Model-Tuple{WannierIO.Chk}" href="#Wannier.Model-Tuple{WannierIO.Chk}"><code>Wannier.Model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Model(chk; kmesh_tol)
</code></pre><p>Construct a <code>Model</code> from a <code>WannierIO.Chk</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>chk</code>: a <code>WannierIO.Chk</code> struct</li></ul><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>The <code>Chk</code> struct does not contain eigenvalues, and the <code>Model.E</code> will be set to zeros.</p><p>Moreover, the <code>M</code> matrix in <code>Chk</code> is already rotated by the gauge transformation, thus by default, the <code>U</code> matrix is set to identity. Note that although maximal localization, or disentanglement (after frozen states are chosen), do not require eigenvalues (so the user can still Wannierize the <code>Model</code>), it is required when writing the <code>Model</code> to a <code>chk</code> file, in <a href="#WannierIO.write_chk"><code>write_chk</code></a>.</p><p>Additionally, be careful that the <code>M</code> matrix is rotated, and this rotation needs to make sure that the rotated Hamiltonian is diagonal so that <code>E</code> stores the diagonal eigenvalues of the Hamiltonian.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/chk.jl#L87-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WannierIO.write_chk" href="#WannierIO.write_chk"><code>WannierIO.write_chk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_chk(filename, model)
write_chk(
    filename,
    model,
    gauges;
    exclude_bands,
    binary,
    header
)
</code></pre><p>Write a <code>Model</code> to a wannier90 <code>chk</code> file.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: filename of the <code>.chk</code> file</li><li><code>model</code>: a <code>Model</code> struct</li><li><code>U</code>: gauge transformation matrices, default is <code>model.U</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>exclude_bands</code>: a list of band indices to be excluded.</li><li><code>binary</code>: write the <code>chk</code> file in binary format</li><li><code>header</code>: header of the <code>chk</code> file</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>exclude_bands</code> is totally not used throughout the code. However, if one want to use wannier90 to restart from the written <code>chk</code> file, the <code>exclude_bands</code> must be consistent with that in wannier90 <code>win</code> file. The wannier90 <code>exclude_bands</code> input parameter in only used in the pw2wannier90 step to remove some bands (usually semicore states) when computing <code>amn</code>/<code>mmn</code>/<code>eig</code> files, therefore this <code>exclude_bands</code> is totally irrelevant to our <code>Model</code> struct.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/chk.jl#L4-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_w90-Tuple{AbstractString}" href="#Wannier.read_w90-Tuple{AbstractString}"><code>Wannier.read_w90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_w90(prefix; ortho_amn)
</code></pre><p>Read <code>win</code> file, and read <code>amn</code>, <code>mmn</code>, <code>eig</code> files if they exist.</p><p><strong>Keyword arguments</strong></p><ul><li>ortho_amn: Lowdin orthonormalization after reading <code>amn</code> matrices.   Should be <code>true</code> for most cases, since usually the input <code>amn</code> matrices are   not guaranteed to be unitary or semi-unitary.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/model.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_w90_with_chk" href="#Wannier.read_w90_with_chk"><code>Wannier.read_w90_with_chk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_w90_with_chk(prefix)
read_w90_with_chk(prefix, chk)
</code></pre><p>Return a <code>Model</code> with U matrix filled by that from a chk file.</p><p><strong>Arguments</strong></p><ul><li>chk: path of chk file to get the unitary matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/model.jl#L91-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_w90-Tuple{AbstractString, Wannier.Model}" href="#Wannier.write_w90-Tuple{AbstractString, Wannier.Model}"><code>Wannier.write_w90</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90(prefix, model; binary)
</code></pre><p>Write <code>Model</code> into <code>eig</code>, <code>mmn</code>, <code>amn</code> files.</p><p><strong>Keyword arguments</strong></p><ul><li><code>binary</code>: write <code>eig</code>, <code>mmn</code>, and <code>amn</code> in Fortran binary format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/model.jl#L106-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_nnkp_compute_bweights-Tuple{AbstractString}" href="#Wannier.read_nnkp_compute_bweights-Tuple{AbstractString}"><code>Wannier.read_nnkp_compute_bweights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_nnkp_compute_bweights(filename)
</code></pre><p>Read the <code>nnkp</code> file.</p><p>This function calls <code>WannierIO.read_nnkp</code> to parse the file, compute the bweights of b-vectors, and returns a <a href="api/@ref"><code>KspaceStencil</code></a> (while <code>WannierIO.read_nnkp</code> only returns a <code>NamedTuple</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/nnkp.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_nnkp-Tuple{AbstractString, Wannier.KspaceStencil}" href="#Wannier.write_nnkp-Tuple{AbstractString, Wannier.KspaceStencil}"><code>Wannier.write_nnkp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_nnkp(filename, kstencil; kwargs...)
</code></pre><p>Write nnkp that can be used by <code>pw2wannier90</code>.</p><p><strong>Arguments</strong></p><ul><li><code>filename</code>: the filename to write to</li><li><code>kstencil</code>: a <a href="api/@ref"><code>KspaceStencil</code></a> object</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Some important tags in <code>nnkp</code> file (can be passed as keyword arguments):</p><ul><li><code>n_wann</code>: the number of WFs, needed by <code>pw2wannier90</code></li><li><code>exclude_bands</code>: the bands (often semicore states) to exclude, needed by   <code>pw2wannier90</code></li></ul><p>For other keyword arguments, see <a href="api/@ref"><code>WannierIO.write_nnkp</code></a>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/nnkp.jl#L36-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier._raw_read_w90_tb-Tuple{AbstractString}" href="#Wannier._raw_read_w90_tb-Tuple{AbstractString}"><code>Wannier._raw_read_w90_tb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Only read tb files, without further processing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/tb.jl#L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_w90_tb-Tuple{AbstractString}" href="#Wannier.read_w90_tb-Tuple{AbstractString}"><code>Wannier.read_w90_tb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_w90_tb(prefix)
</code></pre><p>Read <code>prefix_tb.dat</code> and <code>prefix_wsvec.dat</code> and construct tight-binding models.</p><p><strong>Arguments</strong></p><ul><li><code>prefix</code>: the prefix of <code>prefix_tb.dat</code> and <code>prefix_wsvec.dat</code></li></ul><p><strong>Return</strong></p><ul><li>a <a href="api/@ref"><code>TBHamiltonian</code></a></li><li>a <a href="api/@ref"><code>TBPosition</code></a></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This will call <a href="api/@ref"><code>simplify</code></a> to absorb the R-vector degeneracies and T-vectors into the operator, leading to faster interpolations.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/tb.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_w90_tb-Tuple{AbstractString, TBOperator, TBOperator}" href="#Wannier.write_w90_tb-Tuple{AbstractString, TBOperator, TBOperator}"><code>Wannier.write_w90_tb</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_w90_tb(prefix, hamiltonian, position)
</code></pre><p>Write a tight-binding model of Hamiltonian and position operator into <code>prefix_tb.dat</code> and <code>prefix_wsvec.dat</code> files.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/w90/tb.jl#L57-L62">source</a></section></article><h2 id="File-manipulation"><a class="docs-heading-anchor" href="#File-manipulation">File manipulation</a><a id="File-manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#File-manipulation" title="Permalink"></a></h2><h3 id="Truncate-Wannier90-matrices"><a class="docs-heading-anchor" href="#Truncate-Wannier90-matrices">Truncate Wannier90 matrices</a><a id="Truncate-Wannier90-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Truncate-Wannier90-matrices" title="Permalink"></a></h3><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Here are some functions to remove some bands from <code>mmn</code>, <code>eig</code>, or <code>UNK</code> files, so as to skip rerunning NSCF calculations and <code>pw2wannier90.x</code>.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Wannier.truncate-Union{Tuple{T}, Tuple{Wannier.Model, T}, Tuple{Wannier.Model, T, Union{Nothing, AbstractVector{Int64}, T}}} where T&lt;:AbstractVector{Int64}" href="#Wannier.truncate-Union{Tuple{T}, Tuple{Wannier.Model, T}, Tuple{Wannier.Model, T, Union{Nothing, AbstractVector{Int64}, T}}} where T&lt;:AbstractVector{Int64}"><code>Wannier.truncate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncate(model::Model, keep_bands::Vector{Int}, keep_wfs::Vector{Int}=nothing;
    orthonorm_U::Bool=true)</code></pre><p>Truncate <code>U</code>, <code>M</code>, <code>E</code> matrices in <code>model</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be truncated.</li><li><code>keep_bands</code>: Band indexes to be kept, start from 1.</li><li><code>keep_wfs</code>: WF indexes to be kept, start from 1. If <code>nothing</code>, keep all.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>orthonorm_U</code>: If true, Lowdin orthonormalize <code>U</code> after truncation.   The <code>U</code> needs to be (semi-)unitary, so it should always be true.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/truncate.jl#L123-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.truncate_mmn_eig" href="#Wannier.truncate_mmn_eig"><code>Wannier.truncate_mmn_eig</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_mmn_eig(seedname, keep_bands::Vector{Int}, outdir=&quot;truncate&quot;)</code></pre><p>Truncate number of bands of <code>mmn</code> and <code>eig</code> files.</p><p><strong>Arguments</strong></p><ul><li><code>keep_bands</code>: a vector of band indices to keep, starting from 1.</li><li><code>outdir</code>: the folder for writing <code>mmn</code> and <code>eig</code> files.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>This is useful for generating valence only <code>mmn</code>, <code>eig</code> files from a valence+conduction NSCF calculation, so that no need to recompute NSCF with lower number of bands again.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/truncate.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.truncate_unk" href="#Wannier.truncate_unk"><code>Wannier.truncate_unk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_unk(dir, keep_bands::Vector{Int}, outdir=&quot;truncate&quot;; binary=true)</code></pre><p>Truncate <code>UNK</code> files for specified bands.</p><p><strong>Arguments</strong></p><ul><li><code>dir</code>: folder of <code>UNK</code> files.</li><li><code>keep_bands</code>: the band indexes to keep. Start from 1.</li><li><code>outdir</code>: folder to write output <code>UNK</code> files.</li><li><code>binary</code>: whether to write binary <code>UNK</code> files.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/truncate.jl#L44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.truncate_w90" href="#Wannier.truncate_w90"><code>Wannier.truncate_w90</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">truncate_w90(seedname, keep_bands::Vector{Int}, outdir=&quot;truncate&quot;, unk=false)</code></pre><p>Truncate <code>mmn</code>, <code>eig</code>, and optionally <code>UNK</code> files.</p><p><strong>Arguments</strong></p><ul><li>seedname: seedname for input <code>mmn</code> and <code>eig</code> files.</li><li>keep_bands: Band indexes to be kept, start from 1.</li><li>unk: If true also truncate <code>UNK</code> files.</li><li>outdir: folder for output files.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/truncate.jl#L85-L95">source</a></section></article><h2 id="D-visualization-files"><a class="docs-heading-anchor" href="#D-visualization-files">3D visualization files</a><a id="D-visualization-files-1"></a><a class="docs-heading-anchor-permalink" href="#D-visualization-files" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_xsf-Tuple{AbstractString}" href="#Wannier.read_xsf-Tuple{AbstractString}"><code>Wannier.read_xsf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_xsf(filename::AbstractString)</code></pre><p>Read <code>xsf</code> file.</p><p><strong>Return</strong></p><ul><li><code>primvec</code>: <code>3 * 3</code>, Å, each column is a primitive lattice vector</li><li><code>convvec</code>: <code>3 * 3</code>, Å, each column is a conventional lattice vector</li><li><code>atoms</code>: <code>n_atoms</code> String, atomic symbols or numbers</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, Å, cartesian coordinates</li><li><code>rgrid</code>: <a href="../realspace/#Wannier.RGrid"><code>RGrid</code></a>, grid on which <code>W</code> is defined</li><li><code>W</code>: <code>nx * ny * nz</code>, volumetric data</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only support reading 1 datagrid in <code>BLOCK_DATAGRID_3D</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/xsf.jl#L7-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real" href="#Wannier.write_xsf-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, Array{StaticArraysCore.SVector{3, T}, 1}, AbstractVector{Int64}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real"><code>Wannier.write_xsf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_xsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)</code></pre><p>Write <code>xsf</code> file.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: <code>3 * 3</code>, Å, each column is a lattice vector</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, fractional coordinates</li><li><code>atom_numbers</code>: <code>n_atoms</code>, atomic numbers</li><li><code>rgrid</code>: <code>RGrid</code></li><li><code>W</code>: <code>nx * ny * nz</code>, volumetric data</li></ul><p>This is a more user-friendly version. The <code>rgrid</code> contains the information of the grid origin and spanning vectors.</p><p>See also <a href="api/@ref"><code>WannierIO.write_xsf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/xsf.jl#L35-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_bxsf-Tuple{AbstractString}" href="#Wannier.read_bxsf-Tuple{AbstractString}"><code>Wannier.read_bxsf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_bxsf(filename::AbstractString)</code></pre><p>Read <code>bxsf</code> file.</p><p><strong>Return</strong></p><ul><li><code>rgrid</code>: <a href="../realspace/#Wannier.RGrid"><code>RGrid</code></a>, grid on which <code>E</code> is defined</li><li><code>fermi_energy</code>: in eV</li><li><code>E</code>: <code>n_bands * n_kx * n_ky * n_kz</code>, energy eigenvalues</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/bxsf.jl#L4-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, Wannier.RGrid, T, AbstractArray{T, 4}}} where T&lt;:Real" href="#Wannier.write_bxsf-Union{Tuple{T}, Tuple{AbstractString, Wannier.RGrid, T, AbstractArray{T, 4}}} where T&lt;:Real"><code>Wannier.write_bxsf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_bxsf(filename, lattice, atom_positions, atom_numbers, rgrid, W)</code></pre><p>Write <code>bxsf</code> file.</p><p><strong>Arguments</strong></p><ul><li><code>rgrid</code>: <code>RGrid</code></li><li><code>fermi_energy</code>: in eV</li><li><code>E</code>: <code>n_bands * n_kx * n_ky * n_kz</code>, energy eigenvalues</li></ul><p>This is a more user-friendly version. The <code>rgrid</code> contains the information of the grid origin and spanning vectors.</p><p>See also <a href="api/@ref"><code>WannierIO.write_bxsf</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/bxsf.jl#L25-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.read_cube-Tuple{AbstractString}" href="#Wannier.read_cube-Tuple{AbstractString}"><code>Wannier.read_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">read_cube(filename::AbstractString)</code></pre><p>Read <code>cube</code> file.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>By default, <code>cube</code> use Bohr unit, here all returns are in Cartesian coordinates, Å unit.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/cube.jl#L7-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real" href="#Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real"><code>Wannier.write_cube</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_cube(filename, lattice, atom_positions, atom_numbers, wf_center, rgrid, W; radius=4.0)</code></pre><p>Write <code>cube</code> file for WF.</p><p><strong>Arguments</strong></p><ul><li><code>lattice</code>: each column is a lattice vector, Å</li><li><code>atom_positions</code>: <code>3 * n_atoms</code>, fractional coordinates</li><li><code>atom_numbers</code>: <code>n_atoms</code>, atomic numbers</li><li><code>wf_centers</code>: <code>3</code>, fractional coordinates w.r.t. lattice</li><li><code>rgrid</code>: <code>RGrid</code></li><li><code>W</code>: <code>nx * ny * nz</code>, volumetric data</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>radius</code>: Å. Periodic replica of atoms are written only for the region   within <code>radius</code> Å from <code>wf_center</code>.</li></ul><p>See also <a href="#Wannier.write_cube-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractMatrix{T}, AbstractVector{Int64}, AbstractVector{T}, Wannier.RGrid, AbstractArray{T, 3}}} where T&lt;:Real"><code>write_cube(filename, filename, atom_positions, atom_numbers, origin, span_vectors, W)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/volume/cube.jl#L22-L41">source</a></section></article><h2 id="Interface-to-DFT-codes"><a class="docs-heading-anchor" href="#Interface-to-DFT-codes">Interface to DFT codes</a><a id="Interface-to-DFT-codes-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-to-DFT-codes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.compute_mud-Tuple{AbstractString, AbstractString}" href="#Wannier.compute_mud-Tuple{AbstractString, AbstractString}"><code>Wannier.compute_mud</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_mud(dir_up, dir_dn)</code></pre><p>Compute the overlap matrix between spin up and down from UNK files.</p><p class="math-container">\[M^{\uparrow\downarrow}_{m n \bm{k}} =
\langle u^{\uparrow}_{m \bm{k}} | u^{\downarrow}_{n \bm{k}} \rangle\]</p><p>This function compute <code>mud</code> matrix in real space (thus much slower), checked with QE <code>pw2wannier90.x</code> function which computes <code>mud</code> in reciprocal space, the difference is on the order of 1e-13.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This only works for norm-conserving pseudopotentials since in that case the overlap operator is just identity; for ultrasoft or PAW, a simple dot product is not enough. Also I assume the UNK files are written with a normalization factor of <span>$N$</span> (total points of the FFT grid) over the unit cell, i.e., the UNK generated by QE <code>pw2wannier90.x</code>. If the UNK files are normalized to 1, the result should be multiplied by <span>$N$</span>.</p></div></div><p><strong>Arguments</strong></p><ul><li><code>dir_up</code>: directory of spin up UNK files</li><li><code>dir_dn</code>: directory of spin down UNK files</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/ca20929683bda50ed7f94c0c021ff53deb7f2a1f/src/io/interface/mud.jl#L2-L28">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../util/">« Utility</a><a class="docs-footer-nextpage" href="../model/">Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 7 August 2023 18:04">Monday 7 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
