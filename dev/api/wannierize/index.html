<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Wannierize · Wannier.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Wannier.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../start/">Getting Started</a></li><li><span class="tocitem">Examples</span></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/algorithm/">Algorithm</a></li><li><a class="tocitem" href="../../theory/normalization/">Normalization</a></li><li><a class="tocitem" href="../../theory/initial_projection/">Initial projection</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../util/">Utility</a></li><li><a class="tocitem" href="../io/">Input/Output</a></li><li><a class="tocitem" href="../bvector/">B vector</a></li><li><a class="tocitem" href="../model/">Model</a></li><li class="is-active"><a class="tocitem" href>Wannierize</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Disentanglement"><span>Disentanglement</span></a></li><li><a class="tocitem" href="#Maximal-localization"><span>Maximal localization</span></a></li><li><a class="tocitem" href="#Parallel-transport"><span>Parallel transport</span></a></li><li><a class="tocitem" href="#Optimal-rotation"><span>Optimal rotation</span></a></li><li><a class="tocitem" href="#Splitting-the-Model"><span>Splitting the Model</span></a></li><li><a class="tocitem" href="#Co-optimization-of-spin-polarized-WFs"><span>Co-optimization of spin-polarized WFs</span></a></li><li><a class="tocitem" href="#Constraining-WF-centers"><span>Constraining WF centers</span></a></li></ul></li><li><a class="tocitem" href="../interpolation/">Interpolation</a></li><li><a class="tocitem" href="../realspace/">Real space</a></li><li><a class="tocitem" href="../cli/">Command line</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Wannierize</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Wannierize</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qiaojunfeng/Wannier.jl/blob/main/docs/src/api/wannierize.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Wannierize"><a class="docs-heading-anchor" href="#Wannierize">Wannierize</a><a id="Wannierize-1"></a><a class="docs-heading-anchor-permalink" href="#Wannierize" title="Permalink"></a></h1><p>These are some Wannierization algorithms.</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Wannierize">Wannierize</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Disentanglement">Disentanglement</a></li><li><a href="#Maximal-localization">Maximal localization</a></li><li><a href="#Parallel-transport">Parallel transport</a></li><li><a href="#Optimal-rotation">Optimal rotation</a></li><li><a href="#Splitting-the-Model">Splitting the Model</a></li><li><a href="#Co-optimization-of-spin-polarized-WFs">Co-optimization of spin-polarized WFs</a></li><li><a href="#Constraining-WF-centers">Constraining WF centers</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Wannier.MagModel"><code>Wannier.MagModel</code></a></li><li><a href="#Wannier.GU_to_GX_GY-Union{Tuple{T}, Tuple{Array{T, 3}, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector}} where T"><code>Wannier.GU_to_GX_GY</code></a></li><li><a href="#Wannier.U_to_X_Y-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Vector{BitVector}}} where T&lt;:Complex"><code>Wannier.U_to_X_Y</code></a></li><li><a href="#Wannier.XY_to_X_Y-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:Complex"><code>Wannier.XY_to_X_Y</code></a></li><li><a href="#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>Wannier.X_Y_to_U</code></a></li><li><a href="#Wannier.X_Y_to_XY-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>Wannier.X_Y_to_XY</code></a></li><li><a href="#Wannier.check_frozen_bands-Tuple{AbstractVector{AbstractVector{Bool}}, Int64}"><code>Wannier.check_frozen_bands</code></a></li><li><a href="#Wannier.choose_pole-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{Int64}, Matrix{T}}} where T&lt;:Complex"><code>Wannier.choose_pole</code></a></li><li><a href="#Wannier.compute_error-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}} where T&lt;:Real"><code>Wannier.compute_error</code></a></li><li><a href="#Wannier.disentangle-Union{Tuple{Wannier.MagModel{T}}, Tuple{T}, Tuple{Wannier.MagModel{T}, T}} where T&lt;:Real"><code>Wannier.disentangle</code></a></li><li><a href="#Wannier.disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real"><code>Wannier.disentangle</code></a></li><li><a href="#Wannier.disentangle_center-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real"><code>Wannier.disentangle_center</code></a></li><li><a href="#Wannier.get_fg!_center_disentangle-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real"><code>Wannier.get_fg!_center_disentangle</code></a></li><li><a href="#Wannier.get_fg!_disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T"><code>Wannier.get_fg!_disentangle</code></a></li><li><a href="#Wannier.get_fg!_disentangle"><code>Wannier.get_fg!_disentangle</code></a></li><li><a href="#Wannier.get_fg!_maxloc-Tuple{Wannier.AbstractPenalty, Wannier.Model}"><code>Wannier.get_fg!_maxloc</code></a></li><li><a href="#Wannier.get_fg!_rotate-Tuple{Wannier.Model}"><code>Wannier.get_fg!_rotate</code></a></li><li><a href="#Wannier.get_frozen_bands"><code>Wannier.get_frozen_bands</code></a></li><li><a href="#Wannier.get_frozen_proj-Union{Tuple{T}, Tuple{AbstractArray{AbstractVector{T}, 1}, AbstractArray{AbstractArray{Complex{T}, 2}, 1}, T}} where T&lt;:Real"><code>Wannier.get_frozen_proj</code></a></li><li><a href="#Wannier.interpolate_vec-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{FT}}} where {T&lt;:Union{Real, Complex}, FT&lt;:Real}"><code>Wannier.interpolate_vec</code></a></li><li><a href="#Wannier.matrix_parallel_transport-Union{Tuple{T}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}, Bool}} where T&lt;:Complex"><code>Wannier.matrix_parallel_transport</code></a></li><li><a href="#Wannier.matrix_transport-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, Vector{T}}} where T&lt;:Real"><code>Wannier.matrix_transport</code></a></li><li><a href="#Wannier.max_localize-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real"><code>Wannier.max_localize</code></a></li><li><a href="#Wannier.omega_updn-Tuple{AbstractMatrix}"><code>Wannier.omega_updn</code></a></li><li><a href="#Wannier.opt_rotate-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.opt_rotate</code></a></li><li><a href="#Wannier.orthonorm_freeze-Union{Tuple{T}, Tuple{Matrix{T}, BitVector}} where T&lt;:Complex"><code>Wannier.orthonorm_freeze</code></a></li><li><a href="#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}"><code>Wannier.overlap_updn</code></a></li><li><a href="#Wannier.overlap_updn_grad-Tuple{Vector, Vector, Vector}"><code>Wannier.overlap_updn_grad</code></a></li><li><a href="#Wannier.overlap_updn_grad-Tuple{Wannier.MagModel, Vararg{Any, 4}}"><code>Wannier.overlap_updn_grad</code></a></li><li><a href="#Wannier.parallel_transport-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.parallel_transport</code></a></li><li><a href="#Wannier.propagate!-Union{Tuple{R}, Tuple{T}, Tuple{Array{Matrix{T}, 1}, Vector{Int64}, Vector{R}, Array{Array{Matrix{T}, 1}, 1}, Array{StaticArraysCore.SVector{3, R}, 1}, Vector{Vector{Int64}}, Vector{Vector{StaticArraysCore.SVector{3, Int64}}}}} where {T&lt;:Complex, R&lt;:Real}"><code>Wannier.propagate!</code></a></li><li><a href="#Wannier.rotate_U-Union{Tuple{T}, Tuple{Vector, Matrix{T}}} where T&lt;:Complex"><code>Wannier.rotate_U</code></a></li><li><a href="#Wannier.set_frozen_degen!-Union{Tuple{T}, Tuple{AbstractMatrix{Bool}, Vector}, Tuple{AbstractMatrix{Bool}, Vector, T}} where T&lt;:Real"><code>Wannier.set_frozen_degen!</code></a></li><li><a href="#Wannier.set_frozen_proj!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}} where T&lt;:Real"><code>Wannier.set_frozen_proj!</code></a></li><li><a href="#Wannier.set_frozen_win!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}, Tuple{Wannier.Model{T}, T, T}} where T&lt;:Real"><code>Wannier.set_frozen_win!</code></a></li><li><a href="#Wannier.split_eig-Union{Tuple{R}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractVector{Int64}}"><code>Wannier.split_eig</code></a></li><li><a href="#Wannier.split_eig-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, Int64}} where T&lt;:Real"><code>Wannier.split_eig</code></a></li><li><a href="#Wannier.split_model-Tuple{Wannier.Model, Int64}"><code>Wannier.split_model</code></a></li><li><a href="#Wannier.split_model-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}"><code>Wannier.split_model</code></a></li><li><a href="#Wannier.split_unk-Union{Tuple{T}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString, AbstractString}} where T&lt;:Complex"><code>Wannier.split_unk</code></a></li><li><a href="#Wannier.split_unk-Union{Tuple{R}, Tuple{T}, Tuple{AbstractString, AbstractArray{T}, AbstractVector{R}}} where {T&lt;:(AbstractArray{&lt;:Complex, 3}), R&lt;:AbstractString}"><code>Wannier.split_unk</code></a></li><li><a href="#Wannier.split_wannierize-Tuple{Wannier.Model, Int64}"><code>Wannier.split_wannierize</code></a></li><li><a href="#Wannier.split_wannierize-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}"><code>Wannier.split_wannierize</code></a></li><li><a href="#Wannier.zero_froz_grad!-Tuple{AbstractMatrix, Vector}"><code>Wannier.zero_froz_grad!</code></a></li></ul><h2 id="Disentanglement"><a class="docs-heading-anchor" href="#Disentanglement">Disentanglement</a><a id="Disentanglement-1"></a><a class="docs-heading-anchor-permalink" href="#Disentanglement" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.GU_to_GX_GY-Union{Tuple{T}, Tuple{Array{T, 3}, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector}} where T" href="#Wannier.GU_to_GX_GY-Union{Tuple{T}, Tuple{Array{T, 3}, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector}} where T"><code>Wannier.GU_to_GX_GY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GU_to_GX_GY(G, X, Y, frozen)</code></pre><p>Compute dΩ/dX and dΩ/dY from dΩ/dU.</p><p>Acutally they are the conjugate gradients, e.g., <span>$\frac{d \Omega}{d U^*}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>G</code>: <code>n_bands * n_wann * n_kpts</code> array for gradient dΩ/dU</li><li><code>X</code>: <code>n_wann * n_wann * n_kpts</code> array for X</li><li><code>Y</code>: <code>n_bands * n_wann * n_kpts</code> array for Y</li><li><code>frozen</code>: <code>n_bands * n_kpts</code> BitMatrix for frozen bands</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L468-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.U_to_X_Y-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Vector{BitVector}}} where T&lt;:Complex" href="#Wannier.U_to_X_Y-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, Vector{BitVector}}} where T&lt;:Complex"><code>Wannier.U_to_X_Y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">U_to_X_Y(U::Array{T,3}, frozen::BitMatrix) where {T&lt;:Complex}</code></pre><p>Convert the <code>U</code> layout to the <code>(X, Y)</code> layout.</p><p>See also <a href="#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>X_Y_to_U</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>U</code>: <code>n_bands * n_wann * n_kpts</code></li><li><code>frozen</code>: <code>n_bands * n_kpts</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L358-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.XY_to_X_Y-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:Complex" href="#Wannier.XY_to_X_Y-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:Complex"><code>Wannier.XY_to_X_Y</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">XY_to_X_Y(XY::Matrix{T}, n_bands::Int, n_wann::Int)</code></pre><p>Convert the <code>XY</code> layout to the <code>(X, Y)</code> layout.</p><p>See also <a href="#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>X_Y_to_U</code></a>.</p><p><strong>Arguments</strong></p><ul><li><code>XY</code>: <code>n_bands * n_wann * n_kpts</code> contiguous array</li><li><code>n_bands</code>: number of bands, to be used to reshape <code>XY</code></li><li><code>n_wann</code>: number of wannier functions, to be used to reshape <code>XY</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L404-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex" href="#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>Wannier.X_Y_to_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X_Y_to_U(X::Array{T,3}, Y::Array{T,3})</code></pre><p>Convert the <code>(X, Y)</code> layout to the <code>U</code> layout.</p><p>There are three formats: <code>U</code>, <code>(X, Y)</code>, and <code>XY</code> stored contiguously in memory. For each kpoint,</p><ul><li><code>U</code>: <code>size(U) = (n_bands, n_wann)</code>, the format used in the rest of the code</li><li><code>(X, Y)</code>: <code>size(X) = (n_wann, n_wann)</code>, <code>size(Y) = (n_bands, n_wann)</code>, intermediate format</li><li><code>XY</code>: this is the format used in the optimizer</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L330-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.X_Y_to_XY-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex" href="#Wannier.X_Y_to_XY-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>Wannier.X_Y_to_XY</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">X_Y_to_XY(X::Array{T,3}, Y::Array{T,3}) where {T&lt;:Complex}</code></pre><p>Convert the <code>(X, Y)</code> layout to the <code>XY</code> layout.</p><p>See also <a href="#Wannier.X_Y_to_U-Union{Tuple{T}, Tuple{AbstractVector{&lt;:AbstractMatrix{T}}, AbstractVector{&lt;:AbstractMatrix{T}}}} where T&lt;:Complex"><code>X_Y_to_U</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L437-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.check_frozen_bands-Tuple{AbstractVector{AbstractVector{Bool}}, Int64}" href="#Wannier.check_frozen_bands-Tuple{AbstractVector{AbstractVector{Bool}}, Int64}"><code>Wannier.check_frozen_bands</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_frozen_bands(frozen_bands, n_wann)</code></pre><p>Sanity check that the number of frozen bands at each kpoint &lt;= <code>n_wann</code>.</p><p><strong>Arguments</strong></p><ul><li><code>frozen_bands</code>: the <code>BitMatrix</code> of frozen bands</li><li><code>n_wann</code>: the number of wannier functions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real" href="#Wannier.disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real"><code>Wannier.disentangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disentangle(model; random_gauge=false, f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)</code></pre><p>Run disentangle on the <code>Model</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>random_gauge</code>: use random <code>U</code> matrices as initial guess</li><li><code>f_tol</code>: tolerance for spread convergence</li><li><code>g_tol</code>: tolerance for gradient convergence</li><li><code>max_iter</code>: maximum number of iterations</li><li><code>history_size</code>: history size of LBFGS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L616-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_fg!_disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T" href="#Wannier.get_fg!_disentangle-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T"><code>Wannier.get_fg!_disentangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fg!_disentangle(model::Model)</code></pre><p>Return a tuple of two functions <code>(f, g!)</code> for spread and gradient, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L581-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_frozen_bands" href="#Wannier.get_frozen_bands"><code>Wannier.get_frozen_bands</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_frozen_bands(E, dis_froz_max, dis_froz_min)</code></pre><p>Generate a <code>BitMatrix</code> of frozen bands by checking the two frozen windows.</p><p><strong>Arguments</strong></p><ul><li><code>E</code>: the energy eigenvalues of the Hamiltonian</li><li><code>dis_froz_max</code>: the upper bound of the frozen window</li><li><code>dis_froz_min</code>: the lower bound of the frozen window</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>dis_froz_max</code> and <code>dis_froz_min</code> work similarly as <code>Wannier90</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L6-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_frozen_proj-Union{Tuple{T}, Tuple{AbstractArray{AbstractVector{T}, 1}, AbstractArray{AbstractArray{Complex{T}, 2}, 1}, T}} where T&lt;:Real" href="#Wannier.get_frozen_proj-Union{Tuple{T}, Tuple{AbstractArray{AbstractVector{T}, 1}, AbstractArray{AbstractArray{Complex{T}, 2}, 1}, T}} where T&lt;:Real"><code>Wannier.get_frozen_proj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_frozen_proj(E, U, dis_proj_max)</code></pre><p>Get frozen bands according to band projectability.</p><p><strong>Arguments</strong></p><ul><li><code>E</code>: the energy eigenvalues of the Hamiltonian</li><li><code>U</code>: the gauge rotation matrices</li><li><code>dis_proj_max</code>: the upper bound projectability.   Bands with projectability &gt;= <code>dis_proj_max</code> are frozen.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The band projectability for band <span>$n$</span> at kpoint <span>$\bm{k}$</span> is calculated by <span>$p_{n \bm{k}} = \sum_{m=1}^{m=n_{wann}} | U_{nm \bm{k}} |^2$</span>, and usually each element <span>$p_{n \bm{k}} \in [0.0, 1.0]$</span>. In such cases, the <code>dis_proj_max</code> is usually set to sth. like <code>0.9</code> to freeze high-projectability bands.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L124-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.orthonorm_freeze-Union{Tuple{T}, Tuple{Matrix{T}, BitVector}} where T&lt;:Complex" href="#Wannier.orthonorm_freeze-Union{Tuple{T}, Tuple{Matrix{T}, BitVector}} where T&lt;:Complex"><code>Wannier.orthonorm_freeze</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">orthonorm_freeze(U, frozen)</code></pre><p>Normalize and freeze a block of a matrix.</p><p>Conditions:</p><ul><li>Block form:  <code>U = vcat(Uf, Ur)</code></li><li>Semiunitary<ul><li><code>U&#39; * U = I</code></li><li><code>Uf&#39; * Uf + Ur&#39; * Ur = I</code></li></ul></li><li>Frozen:      <code>Uf * Uf&#39; = I</code></li><li>Also:        <code>Uf * Ur&#39; = 0</code></li></ul><p>Strategy:</p><ol><li>orthogonalize <code>Uf</code></li><li>project <code>Uf</code> out of <code>Ur</code></li><li>orthogonalize the range of <code>Ur</code></li></ol><p><strong>Arguments</strong></p><ul><li><code>U</code>: the matrix to be orthonormalized and frozen</li><li><code>frozen</code>: the <code>BitVector</code> specifying which bands are frozen</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L201-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.set_frozen_degen!-Union{Tuple{T}, Tuple{AbstractMatrix{Bool}, Vector}, Tuple{AbstractMatrix{Bool}, Vector, T}} where T&lt;:Real" href="#Wannier.set_frozen_degen!-Union{Tuple{T}, Tuple{AbstractMatrix{Bool}, Vector}, Tuple{AbstractMatrix{Bool}, Vector, T}} where T&lt;:Real"><code>Wannier.set_frozen_degen!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_frozen_degen!(frozen_bands, E, atol=1e-4)</code></pre><p>Freeze bands which are degenerate with the <code>frozen_bands</code>.</p><p>In some cases, we might want to freeze the whole set of degenerated eigen vectors.</p><p><strong>Arguments</strong></p><ul><li><code>frozen_bands</code>: the <code>BitMatrix</code> of frozen bands</li><li><code>E</code>: the energy eigenvalues of the Hamiltonian</li><li><code>atol</code>: the tolerance of degeneracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L25-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.set_frozen_proj!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}} where T&lt;:Real" href="#Wannier.set_frozen_proj!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}} where T&lt;:Real"><code>Wannier.set_frozen_proj!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_frozen_proj!(model, dis_proj_max; degen=false, degen_atol=1e-4)</code></pre><p>Set frozen bands of the <code>Model</code> according to projectability.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be set</li><li><code>dis_proj_max</code>: the upper bound projectability.   Bands with projectability &gt;= <code>dis_proj_max</code> are frozen.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>degen</code>: whether to freeze the whole set of degenerated eigen vectors</li><li><code>degen_atol</code>: the tolerance of degeneracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L171-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.set_frozen_win!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}, Tuple{Wannier.Model{T}, T, T}} where T&lt;:Real" href="#Wannier.set_frozen_win!-Union{Tuple{T}, Tuple{Wannier.Model{T}, T}, Tuple{Wannier.Model{T}, T, T}} where T&lt;:Real"><code>Wannier.set_frozen_win!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_frozen_win!(model, dis_froz_max, dis_froz_min=-Inf; degen=false, degen_atol=1e-4)</code></pre><p>Set frozen bands of the <code>Model</code> according to two energy windows.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be set</li><li><code>dis_froz_max</code>: the upper bound of the frozen window</li><li><code>dis_froz_min</code>: the lower bound of the frozen window</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>degen</code>: whether to freeze the whole set of degenerated eigen vectors</li><li><code>degen_atol</code>: the tolerance of degeneracy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L90-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.zero_froz_grad!-Tuple{AbstractMatrix, Vector}" href="#Wannier.zero_froz_grad!-Tuple{AbstractMatrix, Vector}"><code>Wannier.zero_froz_grad!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_froz_grad!(G, frozen)</code></pre><p>Set gradient of frozen bands to 0.</p><p>This is used in test.</p><p><strong>Arguments</strong></p><ul><li><code>G</code>: gradient of the spread, in <code>XY</code> layout</li><li><code>frozen</code>: <code>BitMatrix</code> for frozen bands, <code>n_bands * n_kpts</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/disentangle.jl#L550-L560">source</a></section></article><h2 id="Maximal-localization"><a class="docs-heading-anchor" href="#Maximal-localization">Maximal localization</a><a id="Maximal-localization-1"></a><a class="docs-heading-anchor-permalink" href="#Maximal-localization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_fg!_maxloc-Tuple{Wannier.AbstractPenalty, Wannier.Model}" href="#Wannier.get_fg!_maxloc-Tuple{Wannier.AbstractPenalty, Wannier.Model}"><code>Wannier.get_fg!_maxloc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fg!_maxloc(model::Model)</code></pre><p>Return a tuple of two functions <code>(f, g!)</code> for spread and gradient, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/max_localize.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.max_localize-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real" href="#Wannier.max_localize-Union{Tuple{T}, Tuple{Wannier.AbstractPenalty, Wannier.Model{T}}} where T&lt;:Real"><code>Wannier.max_localize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">max_localize(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)</code></pre><p>Maximally localize spread functional w.r.t. all kpoints on a unitary matrix manifold.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>f_tol</code>: tolerance for spread convergence</li><li><code>g_tol</code>: tolerance for gradient convergence</li><li><code>max_iter</code>: maximum number of iterations</li><li><code>history_size</code>: history size of LBFGS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/max_localize.jl#L30-L43">source</a></section></article><h2 id="Parallel-transport"><a class="docs-heading-anchor" href="#Parallel-transport">Parallel transport</a><a id="Parallel-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-transport" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.compute_error-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}} where T&lt;:Real" href="#Wannier.compute_error-Union{Tuple{T}, Tuple{Wannier.Model{T}, Array{Array{Complex{T}, 2}, 1}}} where T&lt;:Real"><code>Wannier.compute_error</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_error(model, U::Array{Complex{T},3})</code></pre><p>Compute the smoothness error of the gauge.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/parallel_transport.jl#L321-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.parallel_transport-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real" href="#Wannier.parallel_transport-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.parallel_transport</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_transport(model::Model{T}; use_U=false, log_interp=false)</code></pre><p>Parallel transport the gauge from the first kpoint to all other kpoints.</p><p>Assumptions:</p><ul><li>the kpoints are contained in a <code>N1 * N2 * N3</code> cartesian grid</li><li>the neighbor list must contain the six cartesian neighbors along x, y, z directions</li></ul><p><strong>Arguments</strong></p><ul><li><code>model</code>: model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>use_U</code>: use the gauge <code>U</code> instead of random matrix</li><li><code>log_interp</code>: use logarithmic interpolation method</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/parallel_transport.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.choose_pole-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{Int64}, Matrix{T}}} where T&lt;:Complex" href="#Wannier.choose_pole-Union{Tuple{T}, Tuple{Array{T, 3}, Vector{Int64}, Matrix{T}}} where T&lt;:Complex"><code>Wannier.choose_pole</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Choose the column and the target point to contract the vector path of the columns of matrix_path</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/contraction.jl#L55-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.interpolate_vec-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{FT}}} where {T&lt;:Union{Real, Complex}, FT&lt;:Real}" href="#Wannier.interpolate_vec-Union{Tuple{FT}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, AbstractVector{FT}}} where {T&lt;:Union{Real, Complex}, FT&lt;:Real}"><code>Wannier.interpolate_vec</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create an interpolation path between x and y, unit vectors by normalizing the linear interpolation of parameter t[i].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/contraction.jl#L233-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.matrix_parallel_transport-Union{Tuple{T}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}, Bool}} where T&lt;:Complex" href="#Wannier.matrix_parallel_transport-Union{Tuple{T}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}}, Tuple{Array{T, 4}, Array{T, 3}, Vector{Int64}, Bool}} where T&lt;:Complex"><code>Wannier.matrix_parallel_transport</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute the parallel transport of the matrix path (matrix<em>path) along the homotopy of the frame (frame</em>path) that starts with the columns (columns[]) of matrix_path.</p><p>size(frame<em>path) = (n</em>col, n<em>col, n</em>k, n<em>t) size(matrix</em>path) = (n<em>col, n</em>col, n_k)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/contraction.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.matrix_transport-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, Vector{T}}} where T&lt;:Real" href="#Wannier.matrix_transport-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, Vector{T}}} where T&lt;:Real"><code>Wannier.matrix_transport</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Contract the matrix_path to a single matrix point in the space of unitaries using parallel transport.</p><p>i.e., contract Obs(k) matrices to constant vectors.</p><p>size(matrix<em>path) = n</em>wann x n<em>wann x n</em>k t: vector of kpoint indexes along a different k direction</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/contraction.jl#L260-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.propagate!-Union{Tuple{R}, Tuple{T}, Tuple{Array{Matrix{T}, 1}, Vector{Int64}, Vector{R}, Array{Array{Matrix{T}, 1}, 1}, Array{StaticArraysCore.SVector{3, R}, 1}, Vector{Vector{Int64}}, Vector{Vector{StaticArraysCore.SVector{3, Int64}}}}} where {T&lt;:Complex, R&lt;:Real}" href="#Wannier.propagate!-Union{Tuple{R}, Tuple{T}, Tuple{Array{Matrix{T}, 1}, Vector{Int64}, Vector{R}, Array{Array{Matrix{T}, 1}, 1}, Array{StaticArraysCore.SVector{3, R}, 1}, Vector{Vector{Int64}}, Vector{Vector{StaticArraysCore.SVector{3, Int64}}}}} where {T&lt;:Complex, R&lt;:Real}"><code>Wannier.propagate!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Propagate U, defined at the first kpt, to the given list of kpts. Those must be neighbors, and only the first kpoint is assumed to have been rotated.</p><p><strong>Arguments</strong></p><ul><li><code>U</code>: <code>n_wann * n_wann * n_kpts</code> gauge matrices</li><li><code>kpts</code>: list of kpoints along which to propagate the gauge matrices</li><li><code>dk</code>: the distance between two consecutive kpoints, in fractional coordinates</li><li><code>M</code>: overlap matrices</li><li><code>kpoints</code>: <code>BVectors.kpoints</code>, kpoint coordinates of the grid</li><li><code>kpb_k</code>: <code>BVectors.kpb_k</code></li><li><code>kpb_G</code>: <code>BVectors.kpb_G</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/parallel_transport/contraction.jl#L3-L15">source</a></section></article><h2 id="Optimal-rotation"><a class="docs-heading-anchor" href="#Optimal-rotation">Optimal rotation</a><a id="Optimal-rotation-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-rotation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_fg!_rotate-Tuple{Wannier.Model}" href="#Wannier.get_fg!_rotate-Tuple{Wannier.Model}"><code>Wannier.get_fg!_rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fg!_rotate(model::Model)</code></pre><p>Return a tuple of two functions <code>(f, g!)</code> for spread and gradient, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/opt_rotate.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.opt_rotate-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real" href="#Wannier.opt_rotate-Union{Tuple{Wannier.Model{T}}, Tuple{T}} where T&lt;:Real"><code>Wannier.opt_rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">opt_rotate(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)</code></pre><p>Maximally localize spread functional w.r.t. single unitary matrix <code>W</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: model</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>f_tol</code>: tolerance for spread convergence</li><li><code>g_tol</code>: tolerance for gradient convergence</li><li><code>max_iter</code>: maximum number of iterations</li><li><code>history_size</code>: history size of LBFGS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/opt_rotate.jl#L83-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.rotate_U-Union{Tuple{T}, Tuple{Vector, Matrix{T}}} where T&lt;:Complex" href="#Wannier.rotate_U-Union{Tuple{T}, Tuple{Vector, Matrix{T}}} where T&lt;:Complex"><code>Wannier.rotate_U</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate_U(U::Array{T,3}, W::Matrix{T}) where {T&lt;:Complex}</code></pre><p>Rotate the <code>U</code> matrices at each kpoint by the same <code>W</code> matrix.</p><p><span>$\forall \bm{k}$</span>, <span>$U_{\bm{k}} W$</span></p><p>Useful once we have the optimal rotation matrix <code>W</code>, then update the initial <code>U</code> matrices by rotating them by <code>W</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/opt_rotate.jl#L154-L163">source</a></section></article><h2 id="Splitting-the-Model"><a class="docs-heading-anchor" href="#Splitting-the-Model">Splitting the Model</a><a id="Splitting-the-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Splitting-the-Model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_eig-Union{Tuple{R}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractVector{Int64}}" href="#Wannier.split_eig-Union{Tuple{R}, Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, AbstractVector{R}}} where {T&lt;:Real, R&lt;:AbstractVector{Int64}}"><code>Wannier.split_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_eig(E, U, eig_groups)</code></pre><p>Split eigenvalues into several groups.</p><p>The separation is done by</p><ol><li>construct Wannier gauge Hamiltonian,  <span>$H_{\bm{k}} = U_{\bm{k}}^\dagger [\epsilon_{n \bm{k}}] U_{\bm{k}}$</span></li><li>diagonalize the Hamiltonian, the eigenvalues are sorted in ascending order,  and they are split into several groups according to the indices in <code>eig_groups</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>E</code>: eigenvalues</li><li><code>U</code>: (semi-)Unitary matrices gauge transformation</li><li><code>eig_groups</code>: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For example, if one wants to split valence+conduction into two groups, valence and conduction, respectively, then <code>eig_groups</code> should be <code>[[1:n_val], [n_val+1:n_wann]]</code>. Usually, the <code>U</code> are the maximally localized gauge matrices from a valence+conduction band Wannierization, this function split the gauge matrices <code>U</code> into two groups by diagonalizing the Hamiltonian, so we have two set of eigenvalues and gauge matrices for valence and conduction bands, respectively. However, the diagonalization introduce random gauges, so the returned two gauge matrices for valence and conduction are bad, we new to run a parallel transport to smoothen the gauges.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L5-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_eig-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, Int64}} where T&lt;:Real" href="#Wannier.split_eig-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Array{Array{Complex{T}, 2}, 1}, Int64}} where T&lt;:Real"><code>Wannier.split_eig</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_eig(E, U, n_val)</code></pre><p>Split eigenvalues into two groups.</p><p>The separation is done by</p><ol><li>construct Wannier gauge Hamiltonian,  <span>$H_{\bm{k}} = U_{\bm{k}}^\dagger [\epsilon_{n \bm{k}}] U_{\bm{k}}$</span></li><li>diagonalize the Hamiltonian, the eigenvalues are sorted in ascending order,  so that the first <code>n_val</code> eigenvalues are the occupied states,  and the rest are the unoccupied states.</li></ol><p><strong>Arguments</strong></p><ul><li><code>E</code>: eigenvalues</li><li><code>U</code>: (semi-)Unitary matrices gauge transformation</li><li><code>n_val</code>: number of valence states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L76-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_model-Tuple{Wannier.Model, Int64}" href="#Wannier.split_model-Tuple{Wannier.Model, Int64}"><code>Wannier.split_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_model(model, n_val)</code></pre><p>Split the <code>Model</code> into two <code>Model</code>s.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be split</li><li><code>n_val</code>: number of valence WFs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L241-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_model-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}" href="#Wannier.split_model-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}"><code>Wannier.split_model</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_model(model, eig_groups)</code></pre><p>Split the <code>Model</code> into several <code>Model</code>s.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be split</li><li><code>eig_groups</code>: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Rotation eigenvectors are also returned, useful for further rotation of <code>UNK</code> files or other operators.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L205-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_unk-Union{Tuple{R}, Tuple{T}, Tuple{AbstractString, AbstractArray{T}, AbstractVector{R}}} where {T&lt;:(AbstractArray{&lt;:Complex, 3}), R&lt;:AbstractString}" href="#Wannier.split_unk-Union{Tuple{R}, Tuple{T}, Tuple{AbstractString, AbstractArray{T}, AbstractVector{R}}} where {T&lt;:(AbstractArray{&lt;:Complex, 3}), R&lt;:AbstractString}"><code>Wannier.split_unk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_unk(dir, Us, outdirs)</code></pre><p>Rotate <code>UNK</code> files.</p><p>These are large matrices, so we read/write to disk for each kpoint sequentially, inside the function.</p><p><strong>Arguments</strong></p><ul><li><code>dir</code>: directory where <code>UNK</code> files are stored</li><li><code>Us</code>: a Vector of Wannier (semi-)unitary gauge matrices for rotating band groups</li><li><code>outdirs</code>: a Vector of output directories for each band group</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>binary</code>: whether to write in Fortran binary format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L103-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_unk-Union{Tuple{T}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString, AbstractString}} where T&lt;:Complex" href="#Wannier.split_unk-Union{Tuple{T}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString}, Tuple{AbstractString, Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, AbstractString, AbstractString}} where T&lt;:Complex"><code>Wannier.split_unk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_unk(dir, Uv, Uc, outdir_val=&quot;val&quot;, outdir_cond=&quot;cond&quot;)</code></pre><p>Rotate <code>UNK</code> files.</p><p>These are large matrices, so we read/write to disk for each kpoint sequentially, inside the function.</p><p><strong>Arguments</strong></p><ul><li><code>dir</code>: directory where <code>UNK</code> files are stored</li><li><code>Uv</code>: the Wannier (semi-)unitary matrix for rotating valence bands</li><li><code>Uc</code>: the Wannier (semi-)unitary matrix for rotating conduction bands</li><li><code>outdir_val</code>: output directory for valence bands</li><li><code>outdir_cond</code>: output directory for conduction bands</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>binary</code>: whether to write in Fortran binary format</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L169-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_wannierize-Tuple{Wannier.Model, Int64}" href="#Wannier.split_wannierize-Tuple{Wannier.Model, Int64}"><code>Wannier.split_wannierize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_wannierize(model::Model, n_val::Int)</code></pre><p>Split the model and run parallel transport to smoothen the gauge.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be split</li><li><code>n_val</code>: number of valence WFs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L286-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.split_wannierize-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}" href="#Wannier.split_wannierize-Union{Tuple{R}, Tuple{Wannier.Model, AbstractVector{R}}} where R&lt;:AbstractVector{Int64}"><code>Wannier.split_wannierize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_wannierize(model::Model, eig_groups)</code></pre><p>Split the model and run parallel transport to smoothen the gauge.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: the <code>Model</code> to be split</li><li><code>eig_groups</code>: a Vector, in which each element is a Vector of indices of eigenvalues   that belong to the same group.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Return two separated <code>Model</code>s and rotation matrices which are useful for <code>UNK</code> files or other operators.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/split.jl#L258-L272">source</a></section></article><h2 id="Co-optimization-of-spin-polarized-WFs"><a class="docs-heading-anchor" href="#Co-optimization-of-spin-polarized-WFs">Co-optimization of spin-polarized WFs</a><a id="Co-optimization-of-spin-polarized-WFs-1"></a><a class="docs-heading-anchor-permalink" href="#Co-optimization-of-spin-polarized-WFs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Wannier.MagModel" href="#Wannier.MagModel"><code>Wannier.MagModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Model for spin polarized system with constraint.</p><p>Traditionally, we run two independent Wannierizations for spin up and spin down. Here we add a constraint to maximally overlap the spin-up and spin-down WFs, so that they map one-by-one to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.disentangle-Union{Tuple{Wannier.MagModel{T}}, Tuple{T}, Tuple{Wannier.MagModel{T}, T}} where T&lt;:Real" href="#Wannier.disentangle-Union{Tuple{Wannier.MagModel{T}}, Tuple{T}, Tuple{Wannier.MagModel{T}, T}} where T&lt;:Real"><code>Wannier.disentangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disentangle(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)</code></pre><p>Run disentangle on a <code>MagModel</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: MagModel</li><li><code>λ</code>: Lagrange multiplier of the ↑↓ overlap term</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>f_tol</code>: tolerance for spread convergence</li><li><code>g_tol</code>: tolerance for gradient convergence</li><li><code>max_iter</code>: maximum number of iterations</li><li><code>history_size</code>: history size of LBFGS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L335-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_fg!_disentangle" href="#Wannier.get_fg!_disentangle"><code>Wannier.get_fg!_disentangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_fg!_disentangle(model::MagModel)</code></pre><p>Return a tuple of two functions <code>(f, g!)</code> for spread and gradient, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L259-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.omega_updn-Tuple{AbstractMatrix}" href="#Wannier.omega_updn-Tuple{AbstractMatrix}"><code>Wannier.omega_updn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">omega_updn(M)</code></pre><p>Compute QPPM Eq. 8.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: the overlap matrix between up and down WFs, size: (n<em>wann, n</em>wann),   should be the matrix returned from <a href="#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}"><code>overlap_updn</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L137-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.overlap_updn-Tuple{Vector, Vector, Vector}" href="#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}"><code>Wannier.overlap_updn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap_updn(up::Model{T}, dn::Model{T}, M::Array{Complex{T},3}) where {T&lt;:Real}</code></pre><p>Compute the overlap between up and down WFs.</p><p>Actually N - Ω↑↓, according to QPPM Eq. 8, where N = n_wann.</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: the <code>MagModel.M</code> matrices, size (n<em>bands, n</em>bands, n_kpts)</li><li><code>Uup</code>: the up gauge matrices, size: (n<em>bands, n</em>wann, n_kpts)</li><li><code>Udn</code>: the down gauge matrices, size: (n<em>bands, n</em>wann, n_kpts)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L102-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.overlap_updn_grad-Tuple{Vector, Vector, Vector}" href="#Wannier.overlap_updn_grad-Tuple{Vector, Vector, Vector}"><code>Wannier.overlap_updn_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap_updn_grad(model::MagModel, Uup, Udn)</code></pre><p>Compute gradients of <a href="#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}"><code>overlap_updn</code></a>.</p><p><span>$\frac{d \Omega}{d U^{\uparrow}}$</span> and <span>$\frac{d \Omega}{d U^{\downarrow}}$</span>.</p><p>TODO: this is actually the gradient of Tr[overlap_updn]</p><p><strong>Arguments</strong></p><ul><li><code>M</code>: the <code>MagModel.M</code> matrices, size (n<em>bands, n</em>bands, n_kpts)</li><li><code>Uup</code>: the up gauge matrices, size: (n<em>bands, n</em>wann, n_kpts)</li><li><code>Udn</code>: the down gauge matrices, size: (n<em>bands, n</em>wann, n_kpts)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L161-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.overlap_updn_grad-Tuple{Wannier.MagModel, Vararg{Any, 4}}" href="#Wannier.overlap_updn_grad-Tuple{Wannier.MagModel, Vararg{Any, 4}}"><code>Wannier.overlap_updn_grad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlap_updn_grad(model::MagModel, Xup, Yup, Xdn, Ydn)</code></pre><p>Compute gradient of <a href="#Wannier.overlap_updn-Tuple{Vector, Vector, Vector}"><code>overlap_updn</code></a>.</p><p><span>$\frac{d \Omega}{d X^{\uparrow}}$</span>, <span>$\frac{d \Omega}{d Y^{\uparrow}}$</span>, <span>$\frac{d \Omega}{d X^{\downarrow}}$</span>, <span>$\frac{d \Omega}{d Y^{\downarrow}}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/coopt.jl#L207-L214">source</a></section></article><h2 id="Constraining-WF-centers"><a class="docs-heading-anchor" href="#Constraining-WF-centers">Constraining WF centers</a><a id="Constraining-WF-centers-1"></a><a class="docs-heading-anchor-permalink" href="#Constraining-WF-centers" title="Permalink"></a></h2><h3 id="Disentanglement-2"><a class="docs-heading-anchor" href="#Disentanglement-2">Disentanglement</a><a class="docs-heading-anchor-permalink" href="#Disentanglement-2" title="Permalink"></a></h3><h3 id="Maximal-localization-2"><a class="docs-heading-anchor" href="#Maximal-localization-2">Maximal localization</a><a class="docs-heading-anchor-permalink" href="#Maximal-localization-2" title="Permalink"></a></h3><h3 id="Co-optimization-of-spin-polarized-WFs-2"><a class="docs-heading-anchor" href="#Co-optimization-of-spin-polarized-WFs-2">Co-optimization of spin-polarized WFs</a><a class="docs-heading-anchor-permalink" href="#Co-optimization-of-spin-polarized-WFs-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Wannier.disentangle_center-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real" href="#Wannier.disentangle_center-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real"><code>Wannier.disentangle_center</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disentangle(model; f_tol=1e-7, g_tol=1e-5, max_iter=200, history_size=3)</code></pre><p>Run disentangle on a <code>MagModel</code>, with center constraints.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: MagModel</li><li><code>r₀</code>: <code>3 * n_wann</code>, WF centers in cartesian coordinates</li><li><code>λc</code>: Lagrange multiplier of the center term</li><li><code>λs</code>: Lagrange multiplier of the spin-up and spin-down overlap term</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>f_tol</code>: tolerance for spread convergence</li><li><code>g_tol</code>: tolerance for gradient convergence</li><li><code>max_iter</code>: maximum number of iterations</li><li><code>history_size</code>: history size of LBFGS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/constrain_center/coopt.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Wannier.get_fg!_center_disentangle-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real" href="#Wannier.get_fg!_center_disentangle-Union{Tuple{T}, Tuple{Wannier.MagModel{T}, Array{StaticArraysCore.SVector{3, T}, 1}, T, T}} where T&lt;:Real"><code>Wannier.get_fg!_center_disentangle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_fg!_center_disentangle(model::MagModel, r₀, λc, λs)</code></pre><p>Return a tuple of two functions <code>(f, g!)</code> for spread and gradient, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/qiaojunfeng/Wannier.jl/blob/3e678ff90f8f5a42f67dc6dd98ac5eff73512967/src/wannierize/constrain_center/coopt.jl#L22-L26">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../model/">« Model</a><a class="docs-footer-nextpage" href="../interpolation/">Interpolation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 19 July 2023 14:53">Wednesday 19 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
