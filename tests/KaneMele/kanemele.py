import sys
import numpy as np
import matplotlib.pyplot as plt

PLOT_EIG = True
WRITE_AMN = True

#Define some useful matrices   
I = np.eye(2)
sigma_x = np.array([[0, 1],[1, 0]])
sigma_y = np.array([[0, -1j],[1j, 0]])
sigma_z = np.array([[1, 0],[0, -1]])    
GammaA = np.zeros((5,4,4), dtype=complex)
GammaA[0,:,:] = np.kron(sigma_x, I)
GammaA[1,:,:] = np.kron(sigma_z, I)
GammaA[2,:,:] = np.kron(sigma_y, sigma_x)
GammaA[3,:,:] = np.kron(sigma_y, sigma_y)
GammaA[4,:,:] = np.kron(sigma_y, sigma_z)
GammaAB = np.zeros((5,5,4,4), dtype=complex)
for i in range(5):
    for j in range(5):
        GammaAB[i,j,:,:] = (GammaA[i].dot(GammaA[j]) - GammaA[j].dot(GammaA[i]))/(2*1j)

spin_op = np.zeros((3,4,4), dtype=complex)
spin_op[0,:,:] = np.kron(I, sigma_x)
spin_op[1,:,:] = np.kron(I, sigma_y)
spin_op[2,:,:] = np.kron(I, sigma_z)

#This function defines the Hamiltonian matrix of the Kane-Mele model.    
def Ham_KM(a,t,l_nu,l_R,l_SO,k):
    x = k[0]*a/2
    y = np.sqrt(3)*k[1]*a/2
    d1 = t*(1+2*np.cos(x)*np.cos(y))
    d2 = l_nu
    d3 = l_R*(1 - np.cos(x)*np.cos(y))
    d4 = -np.sqrt(3)*l_R*np.sin(x)*np.sin(y)

    d12 = -2*t*np.cos(x)*np.sin(y)
    d15 = l_SO*(2*np.sin(2*x) - 4*np.sin(x)*np.cos(y))
    d23 = -l_R*np.cos(x)*np.sin(y)
    d24 = np.sqrt(3)*l_R*np.sin(x)*np.cos(y)
    
    ham = d1*GammaA[0,:,:] + d2*GammaA[1,:,:] + d3*GammaA[2,:,:] + d4*GammaA[3,:,:]
    ham += d12*GammaAB[0,1,:,:] + d15*GammaAB[0,4,:,:] + d23*GammaAB[1,2,:,:] + d24*GammaAB[1,3,:,:]

    return ham

if (len(sys.argv)>1):
    N = int(sys.argv[1])
    l_nu = float(sys.argv[2])
else:
    N = 0
    l_nu = 0

#Define parameters
a = 1
t = 1
l_R = 1 #1#0 #1.5 
l_SO = 1

l_R = 0 #.05
l_SO = .06
l_nu = .4

if N==0:
    N1 = 100
    N2 = 100
    l_nu = 1.0 #6  
else:
    N1 = N
    N2 = N

N3 = 1
Ntot = N1*N2*N3
nband = 2
nwannier = 2
nneighbors = 4
#Reciprocal unit cell
Lx = 4*np.pi/a
Ly = 4*np.pi/a/np.sqrt(3)
Lz = 1.


#Create the array of k-points: the mesh of the Brillouin Zone
#Create the correspondence arrays between (i,j,k)-notation (3D) and K-notation (linear)
k_pts = np.zeros((N1,N2,N3,3))
K_to_ijk = np.zeros((Ntot,3),dtype = np.int64)
ijk_to_K = np.zeros((N1,N2,N3),dtype = np.int64)
for i in range(N1):
    for j in range(N2):
        for k in range(N3):
            K = i*N2*N3+j*N3+k
            ijk_to_K[i,j,k] = K
            K_to_ijk[K,:] = [i, j, k]
            k_pts[i,j,k,:] = [i*Lx/N1,j*Ly/N2,k*Lz/N3]



#Open mmn file to write stream
mmn = open("kanemele_"+str(l_nu)+"_"+str(N1)+".mmn",'w')
mmn.write("This mmn file was generated by kanemele.py")
mmn.write("Ntot = "+ str(Ntot) + " nband = " + str(nband) + "\n")
mmn.write(str(nband) + " " + str(Ntot) + " " + str(nneighbors)+"\n")

#Open amn file to write stream
if WRITE_AMN:
    amn = open("kanemele_"+str(l_nu)+"_"+str(N1)+".amn",'w')
    amn.write("This amn file was generated by kanemele.py")
    amn.write("Ntot = "+ str(Ntot) + " nband = " + str(nband) + "\n")
    amn.write(str(nband) + " " + str(Ntot) + " " + str(nwannier)+"\n")

WRITE_SPN = True
if WRITE_SPN:
    spn = open("kanemele_"+str(l_nu)+"_"+str(N1)+".spn",'w')
    spn.write("This spn file was generated by kanemele.py")
    spn.write("Ntot = "+ str(Ntot) + " nband = " + str(nband) + "\n")
    spn.write(str(nband) + " " + str(Ntot) +"\n")

WRITE_EIG = True
if WRITE_EIG:
    eig = open("kanemele_"+str(l_nu)+"_"+str(N1)+".eig",'w')

#Define the container array for the eigenvalues of the Hamiltonian
eigs = np.zeros((N1,N2,N3,4))

#MAIN LOOP
#Go through all points in the Brillouin Zone, and compute the matrix Mmn of overlap
#of the eigenvalues at a k-point and its neighbors
for i in range(N1):
    for j in range(N2):
        for k in range(N3):
            K = ijk_to_K[i,j,k]

            #Fill the list of neighboring points of K in K-notation
            Kpb_list = []
            if(N1>1):
                Kpb_list.append( ijk_to_K[(i+1)%N1,j,k])
                Kpb_list.append( ijk_to_K[(i-1)%N1,j,k])
            if(N2>1):
                Kpb_list.append( ijk_to_K[i,(j+1)%N2,k])
                Kpb_list.append( ijk_to_K[i,(j-1)%N2,k])
            if(N3>1):
                Kpb_list.append( ijk_to_K[i,j,(k+1)%N3])
                Kpb_list.append( ijk_to_K[i,j,(k-1)%N3])

            #Compute the eigenvalues at point K
            wK, vK = np.linalg.eigh(Ham_KM(a,t,l_nu,l_R,l_SO, k_pts[i,j,k,0:2]))
            eigs[i,j,k,:] = wK
            
            #Write eigenvector in amn file
            if WRITE_AMN:
                for mn in range(nband**2):
                    m,n = np.mod(mn,nband), int(mn/nband)
                    amn.write(str(m+1)+ ' ' + str(n+1) + ' ' + str(K+1) + ' ' + str(np.real(vK[n,m])) + ' ' + str(-np.imag(vK[n,m])) +'\n') 
            
            #Write spin in spn file
            if WRITE_SPN:
                for mn in range(nband**2):
                    m,n = np.mod(mn,nband), int(mn/nband)
                    for s in range(3):
                        sp = np.matmul(np.conj(vK[:,m]), np.matmul(spin_op[s], vK[:,n]))
                        # print(f'sp.shape {sp.shape}')
                        spn.write(str(np.real(sp)) + ' ' + str(np.imag(sp)) +'\n')

            if WRITE_EIG:
                for m in range(nband):
                    eig.write(f'{m+1} {K+1} {eigs[i,j,k,m]} + \n')

            #Compute the eigenvalues at neighboring points
            for Kpb in Kpb_list:
                iN = K_to_ijk[Kpb,0]
                jN = K_to_ijk[Kpb,1]
                kN = K_to_ijk[Kpb,2]
                k_pt = k_pts[iN,jN,kN,:]
                wKpb, vKpb = np.linalg.eigh(Ham_KM(a,t,l_nu,l_R,l_SO,[k_pt[0], k_pt[1]]))

                #Compute the overlap at points K and Kpb,
                #and write it to mmn file
                disp_vec = [0, 0, 0]
                if(N1>1):
                    if((i==0) & (iN == N1-1)): 
                        disp_vec[0] = -1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                    if((i==N1-1) & (iN == 0)):
                        disp_vec[0] = 1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                if(N2>1):
                    if((j==0) & (jN == N2-1)): 
                        disp_vec[1] = -1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                    if((j==N2-1) & (jN == 0)):
                        disp_vec[1] = 1
                        #print "i,j = "+str((i,j))+" iN,jN = "+str((iN,jN))+" K = "+str(K)+" Kpb = "+str(Kpb)
                        #print disp_vec
                if(N3>1):
                    if((k==0) & (kN == N3-1)): 
                        disp_vec[2] = -1
                    if((k==N3-1) & (kN == 0)):
                        disp_vec[2] = 1

                mmn.write(str(K+1) + '       ' + str(Kpb+1)+' '+ str(disp_vec[0]) + ' ' + str(disp_vec[1])+ ' ' + str(disp_vec[2]) + '\n')# TODO this should have the displacement vector

                for mn in range(nband**2):
                    m,n = np.mod(mn,nband), int(mn/nband)
                    overlap = np.dot(np.conj(vK[:,m]),vKpb[:,n]) 
                    mmn.write(str(np.real(overlap)) + '    ' + str(np.imag(overlap)) + '\n')
    
print(f'vk.shape {vK.shape}')
mmn.close()
amn.close()
if WRITE_SPN:
    spn.close()
if WRITE_EIG:
    eig.close()

win = open("kanemele_"+str(l_nu)+"_"+str(N1)+".win",'w')
win.write("""num_bands         =   2
num_wann          =   2
num_iter          = 500
num_print_cycles  = 1

bands_plot    = true
# wannier_plot      = true
# auto_proj     = false

devel_flag=kmesh_degen
skip_b1_tests = true

kpath = true
kpath_task = bands
kpath_bands_colour = spin
kpath_num_points = 200
spn_formatted = true

begin unit_cell_cart 
bohr
""")

with open("kanemele_"+str(l_nu)+"_"+str(N1)+".kshell",'w') as kshell:
    kshell.write("1 2 3 4\n")

win.write(str(2*np.pi) + " 0 0\n")
win.write("0 " + str(2*np.pi) + " 0\n")
win.write("0 0 " + str(2*np.pi) + "\n")
win.write("""end unit_cell_cart

""")

win.write("""
begin kpoint_path
G 0.00  0.00  0.00    A 0.50  0.00  0.00
A 0.50  0.00  0.00    B 1.00  0.00  0.00
end kpoint_path
""")

win.write("mp_grid      = " + str(N1) + " " + str(N2) + " " + str(N3) + "\n")
win.write("begin kpoints\n")

t1 = [i/N1 for i in range(N1)]
t2 = [i/N2 for i in range(N2)]
t3 = [i/N3 for i in range(N3)]

for i in range(N1): 
    for j in range(N2): 
        for k in range(N3):
            t1_ = np.floor(t1[i]*10000)/10000. 
            t2_ = np.floor(t2[j]*10000)/10000. 
            t3_ = np.floor(t3[k]*10000)/10000. 
            win.write(str(t1_) + " " + str(t2_) + " "  + str(t3_) + "\n")

win.write("end kpoints\n")

win.close()


if(PLOT_EIG):
    #Plot eigenvalue surfaces
    fig = plt.figure()
    ax = fig.add_subplot(projection='3d')
    
    X, Y = np.meshgrid(range(N1),range(N2))
    Z = np.zeros((N1,N2,4))
    for i in range(N1):
        for j in range(N2):
            for n in range(4):
                Z[i,j,n] = eigs[X[i,j],Y[i,j],0,n]
    
    for n in range(4):
        ax.plot_surface(X,Y,Z[:,:,n])
    
    l_nu_val = bool(l_nu>3*np.sqrt(3))*"+ " + bool(l_nu!=3*np.sqrt(3))*str(l_nu - 3*np.sqrt(3))
    plt.title("Eigenvalues of the Hamiltonian, l_nu = l_nu,c " +l_nu_val)
    l_nu_readable = str(int(l_nu*100)/100.)
    
    plt.savefig("eigenvalues_ham_"+l_nu_readable+".pdf")
    plt.show()
